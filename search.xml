<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>思维导图测试用例-EN</title>
    <url>/en/2023/minds.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这是页面用来测试思维导图在不同插件上的效果<br><a id="more"></a></p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

<div class="markmap-container" style="height:1000px">
  <svg data="{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;markmap&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;Demo&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;links&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;&lt;strong&gt;inline&lt;/strong&gt; &lt;del&gt;text&lt;/del&gt; &lt;em&gt;styles&lt;/em&gt;&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;multiline&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;&lt;a href=\&quot;\&quot;&gt;BufferedInputStream&lt;/a&gt;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;content&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;HTML code is quite long&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;Test&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;Soundfreaq&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;国外市场&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;&lt;a href=\&quot;\&quot;&gt;BufferedInputStream&lt;/a&gt;&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;地区经销商&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;连锁商超&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;数码店&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;星级酒店&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;Four Seasons&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;Ritz-Calton&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;Trump Hotels&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;Renaissance&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;Loews&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;Hyatt&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;Novotel&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;St. Regis&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;Langham&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;Crown Plaza&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;Hilton&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;Marriott&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;The Standard&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;Thompson&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;One &amp;amp; Only&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;线上渠道&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;美亚&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;英亚&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;国内市场&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;淘宝店（自营）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;京东旗舰店（筹备）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;国内经销商&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[38,39]},&quot;v&quot;:&quot;酒店连锁&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;Niccolo&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[40,41]},&quot;v&quot;:&quot;Hilton&quot;}]}"/>
</div>


<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;Soundfreaq&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;国外市场&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;&lt;a href=\&quot;\&quot;&gt;BufferedInputStream&lt;/a&gt;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;地区经销商&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;连锁商超&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;数码店&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;星级酒店&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;Four Seasons&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;Ritz-Calton&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;Trump Hotels&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;Renaissance&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;Loews&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;Hyatt&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;Novotel&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;St. Regis&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;Langham&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;Crown Plaza&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;Hilton&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;Marriott&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;The Standard&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;Thompson&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;One &amp;amp; Only&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;线上渠道&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;美亚&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;英亚&quot;}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;国内市场&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;淘宝店（自营）&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;京东旗舰店（筹备）&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;国内经销商&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;酒店连锁&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;Niccolo&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;Hilton&quot;}]}]}]}]}"/>
</div>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>en_Hexo</category>
      </categories>
      <tags>
        <tag>en_Hexo-tag</tag>
      </tags>
  </entry>
  <entry>
    <title>Murmurhash初步学习-EN</title>
    <url>/en/2019/MurMurhash-Learning.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;Murmurhash是由Austin Appleby在2008年发明的一种非常简单的、不具有加密特性的散列函数.</p>
<a id="more"></a>
<p>&emsp;&emsp;作者在C版本的代码中对Murmurhash的运行提出了一些假设和解释：</p>
<ol>
<li>假设系统可以一次性读取4个字节；</li>
<li>假设int类型数据的长度是4个字节；</li>
<li>算法不会按照增量的方式工作；</li>
<li>算法在大端（big-endian）和小端（little-endian）结构下的执行结果不一致。</li>
</ol>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Code Review</category>
      </categories>
      <tags>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】一文了解Chrome的十年“加速”历程</title>
    <url>/2018/10-years-of-speed-in-chrome.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;自十年前 Chrome 浏览器首次推出后，速度已经成为 Chrome 的<a href="https://www.chromium.org/developers/core-principles" target="_blank" rel="noopener">四个核心原则</a>之一。我们一直都想让 Web 开发者能够向用户提供快速的、优秀的上网体验。在 Chrome 诞生十周年之际，我们认为回顾在这十年中为提高速度所付出的努力，以及我们接下来要进行的尝试将会是一件非常有趣的事情。<br><a id="more"></a></p>
<p>&emsp;</p>
<h2 id="致力于提速的多个浏览器组件"><a href="#致力于提速的多个浏览器组件" class="headerlink" title="致力于提速的多个浏览器组件"></a>致力于提速的多个浏览器组件</h2><p>&emsp;&emsp;<a href="https://v8project.blogspot.com" target="_blank" rel="noopener">V8</a> 是 Chrome 的一个 JavaScript 和 WebAssembly 引擎。随着网页使用 JavaScript 脚本数量的快速增长，一个能够处理这些 JavaScript 脚本的高速引擎成为一个非常重要的基础。这些年，我们为 V8 研发了一个<a href="https://v8project.blogspot.com/2017/05/launching-ignition-and-turbofan.html" target="_blank" rel="noopener">新的 JavaScript 执行管道(pipeline)</a>，启用了 <a href="https://github.com/v8/v8/wiki/Interpreter" target="_blank" rel="noopener">Ignition</a>（一个新的解释器）和 <a href="https://github.com/v8/v8/wiki/TurboFan" target="_blank" rel="noopener">TurboFan</a>(一个优化的编译器)。这些举措使得我们关于速度基准测试方面的性能提升了 5%-10%。<a href="https://blog.chromium.org/2015/03/new-javascript-techniques-for-rapid.html" target="_blank" rel="noopener">脚本流(Script streaming)</a>使得我们在 JavaScript 脚本开始下载的时候就在一个后台线程中解析这些 JavaScript 脚本，而这可以将页面加载速度提高最多 10%。后来加入的<a href="https://v8project.blogspot.com/2018/03/background-compilation.html" target="_blank" rel="noopener">后台编译过程</a>将主线程的编译时间减少了最多 20%。 </p>
<div align="center"><img src="https://res.cloudinary.com/jknight/image/upload/v1537670868/BlogImages/10-years-of-speed-in-chrome/ba9342523d46d2fbf21fa934cbc6019e2e2.png" width="600" height="346" align="center/"></div>

<p>&emsp;</p>
<p>&emsp;&emsp;我们在 <a href="https://v8project.blogspot.com/2016/04/jank-busters-part-two-orinoco.html" target="_blank" rel="noopener">Orinoco</a> 项目上的工作启用了并发的垃圾回收处理，释放了主线程的同时也减少了 jank。久而久之，我们也转而专注于<a href="https://blog.chromium.org/2017/04/real-world-javascript-performance.html" target="_blank" rel="noopener">实际的 JavaScript 性能</a>，此举帮助我们将 React 的运行时性能<a href="https://v8project.blogspot.com/2018/01/speedometer-2.html" target="_blank" rel="noopener">提升了一倍</a>，同时也将 Vue，Preact 和 Angular 等库的性能提高了最多 40%。自最初的 V8 提交上线后，并行的、并发的、增量的垃圾回收减少到了因 jank 引起的垃圾回收的百分之一。我们也实现了 <a href="https://webassembly.org/" target="_blank" rel="noopener">WebAssembly</a>，允许开发者在 Web 上凭借可以预测的性能来运行非 JavaScript 代码，同时启用了 <a href="https://v8project.blogspot.com/2018/08/liftoff.html" target="_blank" rel="noopener">Liftoff 基线编译器</a>来保证 WASM 应用的快速启动时间。这些新组件都是<a href="https://v8project.blogspot.com/2018/09/10-years.html" target="_blank" rel="noopener">近十年</a>用来提升 V8 性能的最新成果，而由此带来的性能提升超过了 20 倍。 </p>
<div align="center"><img src="https://res.cloudinary.com/jknight/image/upload/v1537670867/BlogImages/10-years-of-speed-in-chrome/6f489f514ddca1b2242262eda8813bb1900.png" width="600" height="276" align="center/">

</div>

<div align="center">

<div align="left" style="font-style:italic">

&emsp;&emsp;上图是近几年 V8 平台关于 Chrome 的一系列已发行版本的得分。V8 平台是旧的 Octane 基准的前身，我们在这张图表中使用 V8 平台是因为不同于 Octane，V8 平台可以运行在所有的 Chrome 版本中，包括最新的测试版本。

</div></div>

<p>&emsp;</p>
<p>&emsp;&emsp;Chrome 在借助 <a href="https://www.chromium.org/spdy" target="_blank" rel="noopener">SPDY</a>, <a href="https://developers.google.com/web/fundamentals/performance/http2/" target="_blank" rel="noopener">HTTP/2</a> 和 <a href="https://www.chromium.org/quic" target="_blank" rel="noopener">QUIC</a> 协助发展更新网络协议和传输层中也扮演了一个关键角色。SPDY 被用来解决 HTTP/1.1 的限制并且成为了 HTTP/2 的基础，而后者现在已经被所有的现代浏览器所支持。与此同时，团队积极地在旨在更好的改善延迟和用户体验的 QUIC 上执行迭代，而在 QUIC 背后，有一个积极的工程任务组(ITEF)在努力。QUIC 的效果在像 YouTube 这样的视频网站上是显而易见的，在借助 QUIC 观看视频时，用户报告的重新缓存率<a href="https://blog.chromium.org/2015/04/a-quic-update-on-googles-experimental.html" target="_blank" rel="noopener">降低了 30%</a>。</p>
<p>&emsp;&emsp;接下来是 Chrome 的<a href="https://www.chromium.org/developers/the-rendering-critical-path" target="_blank" rel="noopener">渲染管道</a>(rendering pipeline)。这个组件用来确保网页对用户的响应同时保证每秒 60 帧的展示。为了以 60fps 的速率展示内容，Chrome 必须<a href="https://developers.google.com/web/fundamentals/performance/rendering/" target="_blank" rel="noopener">在 16 毫秒内渲染每一帧</a>。这其中包括了 JavaScript 脚本的执行、样式、层叠布局、绘制和向用户屏幕推送像素。在这 16 毫秒内，Chrome 使用的越少，就会留给开发人员更多的时间为用户带来更好的体验效果。我们渲染管道的实现涵盖了<a href="https://blog.chromium.org/2017/01/performance-improvements-in-chromes.html" target="_blank" rel="noopener">优化</a>如何确认页面上需要重新绘制的元素以及更好地追踪视觉上不重叠元素的集合。这个过程使得绘制新的帧图像到屏幕的时间缩短了最高 35%。</p>
<div align="center"><img src="https://res.cloudinary.com/jknight/image/upload/v1537670868/BlogImages/10-years-of-speed-in-chrome/e4ec482a2bf86f5cba8996785c22cfc009e.png" width="600" height="279" align="center/">

</div>

<div align="center">

<div align="left" style="font-style:italic">

&emsp;&emsp;在 2015 年，Chrome 团队提出了一种名为 <a href="https://www.youtube.com/watch?v=wO9GGY17NXY" target="_blank" rel="noopener">RAIL</a>的以用户为中心的性能模型。我们在近期对其<a href="https://developers.google.com/web/fundamentals/performance/rail" target="_blank" rel="noopener">进行了更新</a>。

</div></div>

<p>&emsp;</p>
<p>&emsp;&emsp;关于内存消耗，在 Chrome 的 63 到 66 版本之间，渲染器处理的内存使用率提升了大概 20% 到 30%。我们希望在站点隔离已经就绪的情况下继续探索基于 RAIL 的构建途径。Ignition 和 TurboFan 的使用<a href="https://v8project.blogspot.com/2017/05/launching-ignition-and-turbofan.html" target="_blank" rel="noopener">减少</a>了 V8 引擎的整体内存占用，在 V8 支持的所有设备和平台上内存占用降低了 5%-10%。今年，有一些调查发现互联网上 7% 的站点因为内存泄漏受到了影响，而这些问题我们已经完全修复。用来提升 Chrome 浏览器速度的组件涵盖了 DOM，CSS 和诸如 IndexedDB 的存储系统。如果想学习更多的关于我们在性能提升方面的内容，可以持续关注 Chromium 博客。</p>
<p>&emsp;</p>
<h2 id="赋予-Web-开发者更多测量及优化网页的能力"><a href="#赋予-Web-开发者更多测量及优化网页的能力" class="headerlink" title="赋予 Web 开发者更多测量及优化网页的能力"></a><strong>赋予 Web 开发者更多测量及优化网页的能力</strong></h2><p>&emsp;&emsp;了解从哪里开始改进你的网站可能是一个单调乏味的过程。为了提供帮助，我们探索了几种工具，用于了解用户感受到的 <a href="https://developers.google.com/web/fundamentals/performance/speed-tools/#lab_data" target="_blank" rel="noopener">lab</a> 信号和<a href="https://developers.google.com/web/fundamentals/performance/speed-tools/#field_data" target="_blank" rel="noopener">真实</a>体验。多年来，<a href="https://developers.google.com/web/tools/chrome-devtools/" target="_blank" rel="noopener">Chrome DevTools</a> 性能面板成为了一种可视化的方式，可直观地了解网页在实验室环境中如何展示的方法。为了继续降低冲突以寻找网站的<a href="https://developers.google.com/web/updates/2018/05/lighthouse" target="_blank" rel="noopener">性能改善的可能性</a>，我们随后致力于 <a href="https://developers.google.com/web/tools/lighthouse/" target="_blank" rel="noopener">Lighthouse</a>—— 一个分析网站质量的工具，为你提供网站性能的明确度量标准以及改善用户体验的具体指南。Lighthouse 可以直接从 DevTools Audits 面板中访问，从命令行运行，或与其他开发产品（如 <a href="http://webpagetest.org/easy" target="_blank" rel="noopener">WebPageTest</a>）集成。 </p>
<div align="center"><img src="https://res.cloudinary.com/jknight/image/upload/v1537670868/BlogImages/10-years-of-speed-in-chrome/d5604c28fd884240f584696049639c2a374.png" width="600" height="357" align="center/">

</div>

<div align="center" style="font-style:italic">

&emsp;&emsp;运行在 Chrome DevTools Audits 面板中的 Lighthouse

</div>

<p>&emsp;</p>
<p>&emsp;&emsp;为了补充 Lighthouse 提供的实验数据，我们发布了 <a href="https://developers.google.com/web/tools/chrome-user-experience-report/" target="_blank" rel="noopener">Chrome 用户体验报告</a>来为开发者提供诸如<a href="https://developers.google.com/web/fundamentals/performance/user-centric-performance-metrics" target="_blank" rel="noopener">首次内容绘制</a>和<a href="https://developers.google.com/web/updates/2018/07/first-input-delay-in-crux" target="_blank" rel="noopener">首次输入延迟</a>等关于产品使用人群的真实用户体验的数据信息。如今，开发者可以生成他们自己的个性化网站性能报告，同时可以通过 <a href="https://g.co/chromeuxdash" target="_blank" rel="noopener">CrUX 数据报表</a>关注数百万来源的处理进度。</p>
<p>&emsp;&emsp;我们同时也引入了一些 Web 平台功能来帮助开发者优化他们的站点加载性能。我们借助资源提示符<a href="https://w3c.github.io/resource-hints/" target="_blank" rel="noopener">(Resource Hints)</a> 和 <a href="https://developers.google.com/web/updates/2016/03/link-rel-preload" target="_blank" rel="noopener"></a>可以让开发者告知浏览器哪些关键资源是需要尽早加载的。Chrome 是最早实现了支持诸如<a href="https://github.com/google/brotli" target="_blank" rel="noopener">应用于压缩方面的 Brotli</a>、<a href="https://developers.googleblog.com/2015/02/smaller-fonts-with-woff-20-and-unicode.html" target="_blank" rel="noopener">小号网页字体的 WOFF2</a> 和<a href="https://caniuse.com/webp" target="_blank" rel="noopener">图片方面的 WebP</a> 等字节保存方案(byte-saving)的浏览器之一。</p>
<p>&emsp;&emsp;我们很高兴看到支持上述特征的浏览器数量越来越多。Chrome 实现了 <a href="https://developers.google.com/web/fundamentals/primers/service-workers/" target="_blank" rel="noopener">Service Workers</a>，弃用了离线缓存和网络弹性以用于支持重复访问网页。我们也很高兴看到该功能已经<a href="https://caniuse.com/#search=service%20workers" target="_blank" rel="noopener">被大多数的现代浏览器所支持</a>。 </p>
<div align="center"><img src="https://res.cloudinary.com/jknight/image/upload/v1537670867/BlogImages/10-years-of-speed-in-chrome/ffe752d7f39eb8592d6cad734b643b8fd7c.png" width="600" height="210" align="center/">

</div>

<p>&emsp;</p>
<p>&emsp;&emsp;事实上，Google 搜索已经将 Servier Worker 和导航预加载(<a href="https://developers.google.com/web/updates/2017/02/navigation-preload" target="_blank" rel="noopener">navigation preload</a>)应用在了重复搜索方面的条件缓存上。而这使得重复访问的页面加载耗时性能提升了两倍。</p>
<p>&emsp;&emsp;放眼未来，我们也对关于原生的图片和内嵌框架的延迟加载等新兴标准、诸如 <a href="https://en.wikipedia.org/wiki/AV1" target="_blank" rel="noopener">AV1</a> 这样的图像格式有助于高效地向用户提供内容感到兴奋。</p>
<p>&emsp;</p>
<h2 id="在你的数据规划中借助-Chrome-更好的享受网络"><a href="#在你的数据规划中借助-Chrome-更好的享受网络" class="headerlink" title="在你的数据规划中借助 Chrome 更好的享受网络"></a><strong>在你的数据规划中借助 Chrome 更好的享受网络</strong></h2><p>&emsp;&emsp;在过去十年，网页的数量发生了前所未有的增长，但很多用户是第一次使用网络，上网流量对于他们来说可能花费巨大，或者上网速度非常慢。鉴于此，Chrome 在近些年推出了像 Data saver 这样的具有数据意识的功能。Data saver 会智能地优化网页，节省了最多 92% 的上网流量消耗。</p>
<p>&emsp;&emsp;我们也在探索新的可以节省数据的新方法。对那些连接速度最慢的用户来说，我们已经开发出了 Android 平台上的 Chrome，可以让智能网页优化器尽早展示必要的内容。这些页面转换加载相比于整个页面加载而言非常快，除此之外，我们也在持续的提高我们的精确性、覆盖范围和性能。</p>
<p>&emsp;&emsp;我们也在尝试为数据或者网络受限的用户提供一些支持和协助。例如，我们向 Chrome 中加入了原生的延迟加载机制，以及为用户提供在使用大量数据时停止来自页面的其他请求的选项。</p>
<p><strong>我们才刚刚开始</strong></p>
<p>&emsp;&emsp;综上，这些改变帮助开发者和企业可以尽快地向他们的用户投放有用的内容。我们知道这仍需要有很多工作要做，在下一个十年我们也将会做出更多关于页面加载性能的改进和提高。</p>
<p>&emsp;</p>
<h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>&emsp;&emsp;本文由<a href="https://my.oschina.net/tocy" target="_blank" rel="noopener">Tocy</a>和作者共同完成，在这里向Tocy表示感谢并期待下一次的合作。</p>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>原文链接：<a href="https://blog.chromium.org/2018/09/10-years-of-speed-in-chrome_11.html" target="_blank" rel="noopener">10 years of Speed in Chrome</a> </li>
</ol>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>外文翻译</category>
      </categories>
      <tags>
        <tag>协作翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>CPC作弊与反作弊分析</title>
    <url>/2018/CPC-click-fraud-and-anti-fraud.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;点击是用户在使用互联网过程中最频繁的操作之一，用户通过点击一个跳转链接来访问非当前页面的网络资源。在广告行业，每点击扣费(Cost Per Click)是一种很常见且受欢迎的计费模式。<br><a id="more"></a><br>在Wikipedia中，对CPC做了如下定义：</p>
<blockquote>
<p>Pay-per-click (PPC), also known as cost per click (CPC), is an internet advertising model used to direct traffic to websites, in which an advertiser pays a publisher (typically a website owner or a network of websites) when the ad is clicked.</p>
</blockquote>
<p>&emsp;&emsp;在这种模式中，会有三种角色参与其中：广告内容提供者(广告主)、广告内容发布平台、广告内容受众群体。受众群体点击了某个跳转链接(广告)，广告主则向发布平台支付该次点击的费用，而发布平台则需要保证广告主的内容在预算一定的情况下可以得到最大范围的传播和宣传。</p>
<h2 id="什么是网络点击作弊-Click-fraud"><a href="#什么是网络点击作弊-Click-fraud" class="headerlink" title="什么是网络点击作弊(Click fraud)"></a><b>什么是网络点击作弊(Click fraud)</b></h2><blockquote>
<p>Click fraud is a type of fraud that occurs on the Internet in pay-per-click (PPC) online advertising. In this type of advertising, the owners of websites that post the ads are paid an amount of money determined by how many visitors to the sites click on the ads. Fraud occurs when a person, automated script or computer program imitates a legitimate user of a web browser, clicking on such an ad without having an actual interest in the target of the ad’s link. Click fraud is the subject of some controversy and increasing litigation due to the advertising networks being a key beneficiary of the fraud.</p>
</blockquote>
<p>&emsp;&emsp;点击作弊通常带有一定的金钱目的或者商业竞争目的。作弊者通过一定的不正当的技术手段对网络广告进行大量的恶意点击，而这些点击通常都是无效点击。比较明显的例子就是广告内容发布平台通过点击其平台上的广告来向广告主收取点击费用，或者广告主的同行业竞争者通过点击对方的广告消耗其广告预算进而实现其广告无法继续展示而使得竞争者可以获得更多的展示资源。这里的无效表示这些点击不代表点击操作发生人（真实用户）的兴趣和关注点，不代表真实用户的实际需求，仅仅是为了迎合某种目的，同时这些点击也不能为广告主带来期望回报和收益，相反还会增加广告主的宣传成本。</p>
<p>&emsp;&emsp;互联网因为其结构的特殊性导致了信任需要通过互联网中每个节点自身保证自身可以被其他节点信任。网络广告也越来越成为最迅速、传播范围最广的广告投放方式之一。网络广告所产生的经济收入逐渐的成为广告行业的重要收入来源和组成部分。而点击作弊的出现会对互联网这个虚拟空间中的相互信任产生很难修复的破坏，成为破坏在线广告生态系统信任度的源泉之一。由此带来了广告主不会再信任并选择互联网平台来发布广告推广自己的产品，广告发布平台不会被得到信任，自身业务和发展受到了限制，相关的技术和理论支撑得不到有效的验证和发展。</p>
<h2 id="谁会从中受益"><a href="#谁会从中受益" class="headerlink" title="谁会从中受益"></a><b>谁会从中受益</b></h2><p>&emsp;&emsp;如下是前述三种角色的常见出现场景和身份：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">角色</th>
<th style="text-align:center">场景</th>
<th style="text-align:center">身份</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">广告内容提供者（广告主）</td>
<td style="text-align:center">互联网背景</td>
<td style="text-align:center">希望可以引入流量的站点拥有者</td>
</tr>
<tr>
<td style="text-align:center">广告内容提供者（广告主）</td>
<td style="text-align:center">电商背景</td>
<td style="text-align:center">入驻商家或者企业</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;广告内容提供者还可以分为两类，提供者自身和其他竞争者。这两种身份之间在同一个发布平台中存在一种争夺优秀展示位置和机会的竞争关系，因为同一个发布平台中展示效果最优秀的展示位置总是有限的，可是想要占有这个位置的广告主却有很多，都想占据有利的广告展示位置来实现投入和收益最大化。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">角色</th>
<th style="text-align:center">场景</th>
<th style="text-align:center">身份</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">广告内容发布平台</td>
<td style="text-align:center">互联网背景</td>
<td style="text-align:center">具有高人气、高流量的网站或者专业平台</td>
</tr>
<tr>
<td style="text-align:center">广告内容发布平台</td>
<td style="text-align:center">电商背景</td>
<td style="text-align:center">电商网站平台</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">角色</th>
<th style="text-align:center">场景</th>
<th style="text-align:center">身份</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">广告内容受众群体</td>
<td style="text-align:center">互联网背景</td>
<td style="text-align:center">任何可上网人群</td>
</tr>
<tr>
<td style="text-align:center">广告内容受众群体</td>
<td style="text-align:center">电商背景</td>
<td style="text-align:center">为满足某种购物需求的消费者</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;首先，广告内容发布平台是最能从点击作弊中获利的角色。发布平台存在的意义就是为了帮助广告主在对如何做广告投放了解不足的情况下利用自身的优势和专业能力帮助广告主最大范围的投放广告。因为CPC模式的特点决定了不管广告点击是否合法有效，只要产生了点击行为，广告主都要支付相应的费用给发布平台。有时为了产生或者增加这种收益，发布平台自身会利用一些方式方法去执行一些点击操作来向广告主收取广告费用。但是这种收益是一种竭泽而渔的收益，其实已经构成了点击欺诈，由此带来的是发布平台和广告主之间的合作关系被破坏，广告主需要为此承担更多的经济损失。</p>
<p>&emsp;&emsp;其次，广告主的其他竞争者也是点击作弊的获益方。因为优秀的广告展示位置总是有限的，所以其他竞争者通过制造大量点击行为消耗掉广告主的广告预算，增加广告主的广告投放成本，最终让广告主无法继续投放广告。这样其他竞争者相对而言就有了一定的竞争优势可以获得更多的展示机会。</p>
<h2 id="网络点击欺诈作弊的常见形式-手段-特征"><a href="#网络点击欺诈作弊的常见形式-手段-特征" class="headerlink" title="网络点击欺诈作弊的常见形式\手段\特征"></a><b>网络点击欺诈作弊的常见形式\手段\特征</b></h2><h3 id="作弊方式"><a href="#作弊方式" class="headerlink" title="作弊方式"></a>作弊方式</h3><h4 id="人工作弊"><a href="#人工作弊" class="headerlink" title="人工作弊"></a>人工作弊</h4><ol>
<li><p>作弊联盟。若干个广告发布平台结成联盟，互相点击联盟中其他成员平台上展示的广告。</p>
</li>
<li><p>诱骗点击。这种点击也被称为欺诈流量。这种点击通常并不是由点击获益方发起的，更多时候是由真实用户产生并执行的，但是用户并不清楚在这种情况下他们是在执行带有作弊性质的点击行为。广告内容发布平台在设计广告展示时，会通过一些设计和交互手段让用户大概率的产生一些用户关注度很少的点击，尽管这些点击很有可能是用户不想执行的，或者这些广告内容对用户产生了一定的诱导而使用户执行了点击。更有甚者，点击广告是实现用户目的的必要操作之一。</p>
</li>
<li><p>人海点击。某太祖兔在《论持久战》里说过一句话：让敌人陷入人民战争的汪洋大海。通过雇佣大量的廉价人力，在给予一定酬劳的情况下可以对指定广告内容不停的进行点击操作。这些人力不需要技术门槛，只需要一台可以上网的电脑、手机，按照作弊者编写的操作手册按部就班的执行就可以完成操作。由于这种方法近似等同于真实用户的真实点击，所以对于这种类型的作弊点击区分是否为真实用户还是有困难的。</p>
</li>
<li><p>代理服务。因为每次请求时服务器都会记录请求的ip地址信息，所以作弊方在通过使用代理服务后可以随时改变自己的ip地址。这样的一个结果就是每次点击都是同一个人，在同一台电脑上完成的，而服务器会认为发过来的每个请求来自于不同的机器，进而不会将这样的点击判定为作弊点击。</p>
</li>
<li><p>清空cookie。</p>
</li>
</ol>
<h4 id="机器作弊"><a href="#机器作弊" class="headerlink" title="机器作弊"></a>机器作弊</h4><ol>
<li><p>使用程序自动重复执行广告的点击过程。</p>
</li>
<li><p>肉鸡控制。关于肉鸡(Zombie computer)一词，Wikipedia给出了如下定义：</p>
<blockquote>
<p>In computer science, a zombie is a computer connected to the Internet that has been compromised by a hacker, computer virus or trojan horse program and can be used to perform malicious tasks of one sort or another under remote direction. Botnets of zombie computers are often used to spread e-mail spam and launch denial-of-service attacks (DOS attacks). Most owners of “zombie” computers are unaware that their system is being used in this way. Because the owner tends to be unaware, these computers are metaphorically compared to fictional zombies. A coordinated DDoS attack by multiple botnet machines also resembles a “zombie horde attack”, as depicted in fictional zombie films.</p>
</blockquote>
</li>
</ol>
<p>&emsp;&emsp;这种作弊方式其实已经超出了点击作弊的范畴了，因为一旦获得了肉鸡资源，可以做的事情就远不止点击作弊这一种了，一个非常普遍的用途就是用来发动DDoS攻击。对于作弊者来说，只需要对肉鸡发出控制指令，之后肉鸡机器便会根据指令去执行广告点击操作。和人海点击类似，这也是一种近似于真实点击的作弊点击，会增加服务端判定这种点击是否合法的难度。</p>
<p>&emsp;3. 爬虫程序。一些爬虫程序在抓取页面数据时，可能会不加区分的将CPC广告的数据一并获取，这种情况下当事人有可能其本意并非要参与作弊，只是为了实现其他目的的同时附带性的执行了一些点击操作。</p>
<h3 id="常见现象"><a href="#常见现象" class="headerlink" title="常见现象"></a>常见现象</h3><ol>
<li><p>搜索情境下CPC广告关键词数据异常。某个关键词的相关展示数据在排除掉一些当下热点事件因素外与历史同期相比差异比较悬殊时可以推测是被执行了点击作弊。</p>
</li>
<li><p>同一IP访问。最简单的作弊方式，最容易被发现，但是依旧有大量的使用案例。</p>
</li>
<li><p>点显比异常。点显比（Click-Through-Rate）过低表示可能点击数过小，说明相关广告信息无法满足用户需求。还有一种可能是展示数过低，表示用户甚至没有多少机会可以看到广告。相反，点显比过高则可以理解成成点击次数的增长速度大于展示次数的增长速度，最终会慢慢趋近于1。这种情况下就意味着有展示必定有点击，然而，这是不正常的，根据Google AdSense的统计，通常情况下的CTR在2%左右。也就是说，平均百次展示才会带来两个点击。</p>
</li>
<li><p>展示/点击来源不匹配。作弊者为了满足特征(2)，会使用代理服务器不停的更换IP地址，这么做虽然避免了特征(2)的检测，但是为带来下面的这个问题。有些广告的展示是基于区域的，可能会在A区域展示的广告在B区域就不会展示，代理服务器会动态更新IP地址的时候可能会产生非A区域的IP地址，那么这种情况下根本就不可能会产生点击结果实际上产生了，那么可以判定这种点击是作弊点击了。</p>
</li>
<li><p>用户页面停留时间过短。页面停留时间目前通常使用的计算方法是，从用户点击广告链接到达当前页面开始计算，到用户离开当前页面到达下一个页面结束。这段时间正常情况下会由需求转变为寻找和关注，再决定是否有点击的必要。如果时间过短会认为用户在执行了点击操作之后在页面尚未加载完成或者尚未有充足的时间去浏览页面内容就关闭了页面。</p>
</li>
<li><p>点击坐标分析。包括点击坐标值是否存在大量的相同值，这种情况下需要判定是否为机器作弊。除此之外，可以考虑建议点击坐标分布热图，依靠一些生物特性来协助判定是否存在作弊点击。如果点击偏离热图集中区域过于严重，则需要检测当前点击是否为作为点击了。</p>
</li>
<li><p>时间先后顺序异常。网页加载时间、用户离开时间、用户进入时间、用户点击时间之间的先后关系判定，时间间隔范围是否有效。</p>
</li>
</ol>
<h3 id="数据分析指标"><a href="#数据分析指标" class="headerlink" title="数据分析指标"></a>数据分析指标</h3><p>&emsp;&emsp;可以收集到的一些必要点击属性值（包括但不限于如下）：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">uuid/guid</td>
<td style="text-align:center">用户标识</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">IP</td>
<td style="text-align:center">IP地址</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">refere</td>
<td style="text-align:center">http请求引用</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">clicktime</td>
<td style="text-align:center">点击时间</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">click_h</td>
<td style="text-align:center">点击坐标</td>
<td style="text-align:center">垂直坐标值</td>
</tr>
<tr>
<td style="text-align:center">click_w</td>
<td style="text-align:center">点击坐标</td>
<td style="text-align:center">水平坐标值</td>
</tr>
<tr>
<td style="text-align:center">screen_h</td>
<td style="text-align:center">屏幕可视区域高度</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">screen_w</td>
<td style="text-align:center">屏幕可视区域宽度</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">screen_s</td>
<td style="text-align:center">屏幕分辨率色彩度</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">siteUrl</td>
<td style="text-align:center">用户访问地址</td>
<td style="text-align:center">&nbsp;</td>
</tr>
</tbody>
</table>
</div>
<p>。。。</p>
<h2 id="如何判定网络点击欺诈作弊"><a href="#如何判定网络点击欺诈作弊" class="headerlink" title="如何判定网络点击欺诈作弊"></a><b>如何判定网络点击欺诈作弊</b></h2><h3 id="单一指标根据阈值判定是否作弊"><a href="#单一指标根据阈值判定是否作弊" class="headerlink" title="单一指标根据阈值判定是否作弊"></a>单一指标根据阈值判定是否作弊</h3><p>&emsp;&emsp;最简单的一种判定方法，根据历史经验或者一些得到认可的统计数据设置作弊规则的阈值范围，在获取到点击数据后根据作弊规则和对应阈值判定点击是否正常。如果设计了多条作弊规则，那么依次判定，多个判定结果取或集最终判定点击是否作弊。一些常见的判定如下：</p>
<ol>
<li><p>IP判定。判断同一IP连续点击次数和连续点击时间。除此之外，可以根据动态代理生成的IP地址的特点判定当前IP地址是否为代理生成的IP地址，如果是，则可以怀疑该点击有作弊嫌疑，需要进行进一步的判定；</p>
</li>
<li><p>通过一些软硬件信息判定。诸如网卡MAC地址、硬盘序列号、移动设备的一些唯一序列号都可以用来进行作弊判定。这些信息的特点是很难去频繁修改，因此这些信息可以和用户形成一种稳定的一一对应关系。但是这些信息在web应用上很难获取得到，所以很难在web应用上得到应用；</p>
</li>
<li><p>……</p>
</li>
</ol>
<p>&emsp;&emsp;显然，这种方法的优点是容易实现，而且逻辑简单。但是这种方法的缺点也很明显，那就是非常容易误判和漏判，产生一种非黑即白的判定结果。举例来说，根据同一IP地址来判定是否作弊这个条规则就不适用于企业局域网。在企业局域网里，所有的局域网成员通过有限的几个公网IP与外界进行联系。这种情况下，尽管是同样的IP地址点击了同一个广告，但实际上是由不同的有真实需求的用户进行了点击操作，这种情况下的点击可以为广告主带来真实的有效收益，所以就不能判定该点击为作弊点击。除此之外，由于作弊者可以利用动态代理去随时改变IP地址，这样会使得IP地址黑名单的命中率不够理想，会导致黑名单内容不断增加，但是命中率却没有随着黑名单的增加而得到提升。</p>
<p>&emsp;&emsp;由于每条指标都有阈值范围，而作弊者会随着作弊判定规则作出一定的改变，所以需要建立一种调节机制来使得阈值可以通过学习历史数据来动态改变进而可以更好的匹配和判定作弊行为。</p>
<h3 id="根据时间差和连续点击次数判定作弊"><a href="#根据时间差和连续点击次数判定作弊" class="headerlink" title="根据时间差和连续点击次数判定作弊"></a>根据时间差和连续点击次数判定作弊</h3><p>&emsp;&emsp;一种比较常见的算法是根据浏览时间差和点击次数来判断点击是否生效，在具体的实现中需要依赖历史数据来协助判定点击是否有效。该算法的主要思想是根据两次点击之间的时间差和连续点击次数是否同时满足阈值条件来判定作弊。具体逻辑如下：</p>
<ol>
<li><p>当前用户点击某个广告后记录点击IP、当前点击的时刻信息，根据用户唯一标识获取点击次数和最近一次点击的时刻；</p>
</li>
<li><p>判断点击次数是否小于设定阈值，如果小于阈值则执行下一步，否则判定最近一次点击和当前点击的时间差是否大于阈值，如果大于阈值则认为点击正常通过判定并将点击次数清0重新计数。如果时间差小于阈值，则认为作弊；</p>
</li>
<li><p>判定用户在当前页面的停留时间，如果停留时间小于设定阈值，那么认为是用户错点或者是雇佣人力进行的点击，这两种情况都不能判定为正常点击。反之执行作弊判定之后的诸如扣费等后续操作。</p>
</li>
</ol>
<p>&emsp;&emsp;在收到每次点击请求后都需要把响应的点击数据信息保存下来供日后分析使用。这种方法建立在根据IP地址识别用户的基础之上，也就是说这种方法对于IP地址随时变更的情况则基本上无法处理，而会把每个不同的IP地址当做一个不同的用户会执行上述的判断。所以这种方法需要IP地址判定结合在一起公共使用，如果判定当前IP地址是一个正常的IP地址，那么就根据该IP的历史点击次数记录和点击时间差阈值去判定该IP地址发送的点击请求是否正常有效，如果IP地址判定都未通过，那么可以直接认为该点击存在作弊嫌疑。</p>
<p>&emsp;&emsp;还有一些变异方法和这种方法类似，也是基于连续点击次数和点击时间差来判断是否属于正常点击。现有的一些判定方法是计算在设定时间长度范围内同用户(根据IP地址或者UUID/GUID)产生的点击请求数量是否超过阈值来判定是否存在作弊行为。具体做法是在收到点击请求时根据当时时间往前延伸设定的时间长度，并计算这段时间内当前用户的点击记录数，根据记录数和阈值进行比较判定当前点击是否有效。这种做法相对来说更加简单，每次得到点击请求后只需要记录该次点击请求，然后统计设定的时间长度范围内的点击记录数即可判定当前点击请求是否正常。</p>
<h3 id="孤立点检测和贝叶斯分类判定"><a href="#孤立点检测和贝叶斯分类判定" class="headerlink" title="孤立点检测和贝叶斯分类判定"></a>孤立点检测和贝叶斯分类判定</h3><p>&emsp;&emsp;在收到用户发出的点击请求之后，首先利用关联聚类建立一个关于当前被点击广告的指定时间段内的疑似点击集合。这个集合中的点击可能是正常用户的真实点击，也可能是作弊者制造的欺诈点击，所以接下来就需要通过孤立点检测和贝叶斯分类分离出其中的作弊点击和有效点击。</p>
<p>&emsp;&emsp;孤立点指的是在一个数据集合中与大多数数据元素差异很大的元素，差异会大到让人难以用正常误差去解释这种差异。基于关联聚类得到的欺诈点击集合可以根据设定的点击属性维度把作弊点击和正常点击分离开来并把作弊点击看做是一种孤立点，然后根据事先设定的孤立点最大数量阈值N排除掉指定阈值数量的点击数据。根据定义的两条记录属性差异度计算公式，可以计算出任意两条点击记录之间的一个属性差异度，然后可以基于任意两个点击数据之间构建出一个相异度矩阵，计算出矩阵中每行相异度大于相异度阈值的数量。将相异度矩阵根据每行超过相异度阈值的记录个数重新排序，排在最前面的被认定为作弊点击的可能性更大。剔除掉排名前K位的孤立点数据，剩下的就构成了一个候选欺诈群组。</p>
<p>&emsp;&emsp;采用孤立点检测方法得到候选欺诈组后，其中的点击记录还是会由欺诈点击和正常点击构成。因此为了提出真正的正常点击、分离出所有的欺诈点击，需要采用贝叶斯分类的方法来判定每个点击是否为作弊点击。贝叶斯公式是概率统计中的应用所观察到的现象对有关概率分布的主观判断（即先验概率）进行修正的标准方法。假设有若干个类，C<sub>1</sub>，C<sub>2</sub>，……..C<sub>m</sub>，对于指定数据样本X，且所有的类条件独立，贝叶斯分类将判定X属于C<sub>i</sub>当且仅当：</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;P(C<sub>i</sub>|X) &gt; P(C<sub>j</sub>|X), 1 ≤ j ≤ m, j ≠ i &emsp;&emsp;&emsp;&emsp;(1)</p>
<p>&emsp;&emsp;根据贝叶斯公式：</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;P(C<sub>i</sub>|X) = P(X|C<sub>i</sub>) * P(C<sub>i</sub>) / P(X)&emsp;&emsp;&emsp;&emsp;(2)</p>
<p>&emsp;&emsp;P(X)对于所有的类都是一个常量，所以只需要计算P(X|C<sub>i</sub>) * P(C<sub>i</sub>)这个算式的结果即可。由于每条数据样本X（此处为每条点击记录）具有若干个属性值，所以假设各属性值之间相互独立，取值概率不会受到其他属性值的影响也不会影响其他属性值的取值，即给定的样本属性值条件独立，则：</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;P(X|C<sub>i</sub>) = P(x<sub>1</sub>, x<sub>2</sub>……x<sub>k</sub>|C<sub>i</sub>) = P(x<sub>1</sub>|C<sub>i</sub>) × P(x<sub>2</sub>|C<sub>i</sub>) × …… × P(x<sub>k</sub>|C<sub>i</sub>)&emsp;&emsp;&emsp;&emsp;(3)</p>
<p>&emsp;&emsp;在公式三中，x<sub>k</sub>为点击记录样本X中的第k个属性的属性值。</p>
<p>&emsp;&emsp;我们基于一定的训练集可以把点击记录分为两个类别，C<sub>1</sub>为正常点击，C<sub>2</sub>为作弊点击。这两个类可分别对应（无先后关系）公式(1)-(3)中C<sub>i</sub>和C<sub>j</sub>，点击事件样本X中包含的属性可参考但不限于表格<b>数据分析指标</b>中提及的属性。基于训练数据集分别计算点击事件样本X中每个属性值的先验概率，获取乘积计算P(X|C<sub>i</sub>)的结果。同一条样本X分别就C<sub>1</sub>和C<sub>2</sub>计算其概率值，如果P(C<sub>1</sub>|X) &gt; P(C<sub>2</sub>|X)，则当前点击样本X可以被认定为一条正常点击，反之则认为是一条作弊点击。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><b>参考文献</b></h2><ol>
<li>在线广告投放系统及技术的演变</li>
<li>网络广告中反CPC点击作弊研究</li>
<li>一种有效预防点击欺诈的算法</li>
<li>点击欺诈群体检测与发现</li>
<li>Web挖掘在网络广告点击欺诈检测中的应用</li>
<li>Wikipedia<br>&emsp;<br>&emsp;<br>&emsp;</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>计算广告</category>
      </categories>
      <tags>
        <tag>CPC广告</tag>
      </tags>
  </entry>
  <entry>
    <title>I am Iron Man</title>
    <url>/2019/For-Tony.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><a id="more"></a>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1587274390/BlogImages/Others/I-Am-Iron-Man-Begin.jpg" alt></p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1587274389/BlogImages/Others/I-Am-Iron-Man-End.jpg" alt></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>影视</category>
      </categories>
      <tags>
        <tag>Iron Man</tag>
        <tag>Marval</tag>
      </tags>
  </entry>
  <entry>
    <title>IP子网划分方法简述</title>
    <url>/2021/IP-Subnet-Mask.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;在计算机网络中，IP协议（Internet Protocol，互联网络协议）是TCP/IP协议簇中的核心协议，该协议作用于网络层，要求计算机通过遵循一套相同的规则，从而实现计算机之间可以相互通信。在网络层中，数据以IP报文的形式存在，报文通过IP地址标识来源和目的主机。当前IP地址普遍遵循的是第四版互联网络协议（Internet Protocol version 4）也就是IPv4，在该版本协议中，一台主机的IP地址以<strong>点分十进制（Dotted Decimal Notation）</strong>方式表示，同时按照&lt;网络地址/网络号&gt;+&lt;主机地址/主机号&gt;的方式进行寻址。其中，网络地址（网络号）表示当前主机所在的网段，主机地址（主机号）表示当前主机在其所在网段中的唯一ID。</p>
<a id="more"></a>
<p>&emsp;&emsp;为了便于对IP地址进行管理，IETF（Internet Engineering Task Force，互联网工程任务组）在RFC 791<sup id="fnref:1" style="font-size:80%;line-height:80%;"><a href="#fn:1" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[1]</span></a></sup>中将IP地址定义为5种类型：<br>&emsp;&emsp;表 - 1：IP地址分类<sup id="fnref:2" style="font-size:80%;line-height:80%;"><a href="#fn:2" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[2]</span></a></sup></p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1619230671/BlogImages/InternetSerials/ip-subnet-mask/ip-subnet-mask-ip-classes-range.png" style="margin: 0 auto;">
</div>

<p>对于A类网络，网络号”X”部分全为0的IP地址是个保留地址，网络号”X”部分全为1的IP地址是个环回地址，保留用作本地软件环回测试本主机的进程之间相互通信，所以A类网络可用的网络数量为$ 2^7 $ - 2。对B类和C类网络而言，128.0.0.0和192.0.0.0也是不对外分配使用的<sup id="fnref:3" style="font-size:80%;line-height:80%;"><a href="#fn:3" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[3]</span></a></sup>，所以可用网络数量分别为$ 2^{14} $ -1和$ 2^{21} $ -1。<br>&emsp;&emsp;在每个类别的每个网段中，都有两个特殊的地址：</p>
<ul>
<li>主机位全为0的网络地址；</li>
<li>主机位全为1的广播地址；</li>
</ul>
<p>所以各个网段的可用主机号为$ 2^n $ （n为主机号位数）减去一个网络地址和一个广播地址，即为$ 2^n $  -2。 </p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1619053351/BlogImages/InternetSerials/ip-subnet-mask/Ip-network-classes.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 1 IP地址分类结构 <sup id="fnref:4" style="font-size:80%;line-height:80%;"><a href="#fn:4" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[4]</span></a></sup> </div>
&emsp;
</div>

<p>&emsp;&emsp;因此，诸如互联网名称与数字地址分配机构（ICANN，The Internet Corporation for Assigned Names and Numbers）等IP地址分配和管理机构会根据实际需求分配一个IP地址段给申请者，根据RFC791的描述，A类网络每个网段可容纳$ 2^{24} $ -2个主机，B类网络每个网段可容纳$ 2^{16} $  -2个主机，C类网络每个网段可容纳$ 2^8 $ -2个主机，如果申请者的需求小于A,B,C类网络各个网段的可用主机数，那么如果将整个网段全都分配出去，会造成IP地址的浪费，从而加剧IP地址的消耗速度。出于</p>
<ol>
<li>节约IP地址避免浪费；</li>
<li>限制广播风暴的影响范围；</li>
<li>通过分隔网段的方式保证各个网络的安全性；</li>
</ol>
<p>等目的，故在RFC 950<sup id="fnref:5" style="font-size:80%;line-height:80%;"><a href="#fn:5" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[5]</span></a></sup>中定义了子网掩码的相关概念及操作流程，从而按照实际需要分配IP地址，使得分配后的IP地址数量能在满足实际需要的前提下最大程度的减少浪费。</p>
<h2 id="子网及子网掩码"><a href="#子网及子网掩码" class="headerlink" title="子网及子网掩码"></a>子网及子网掩码</h2><p>&emsp;&emsp;子网是对于IP地址网络的一种逻辑划分，把一个网段划分成两个及以上更小网段的过程就称为子网划分。划分子网后，寻址方式便由之前的&lt;网络号&gt;+&lt;主机号&gt;变成了&lt;网络号&gt;+&lt;子网号&gt;+&lt;主机号&gt;：</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1619054007/BlogImages/InternetSerials/ip-subnet-mask/Ip-network-subnet-model.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 2 子网划分结构 <sup id="fnref:5" style="font-size:80%;line-height:80%;"><a href="#fn:5" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[5]</span></a></sup> </div>
&emsp;
</div>

<p>&emsp;&emsp;为了区分同一网段下的不同子网，需要使用<strong>子网掩码</strong>来进行区分。通常情况下，子网掩码由从左起若干个值为1的进制位表示。RFC950和RFC 1219<sup id="fnref:6" style="font-size:80%;line-height:80%;"><a href="#fn:6" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[6]</span></a></sup>中指出，<strong>1进制位可以不连续，但是并不推荐这么做</strong>。需要注意的是，在RFC950中，子网号全为0或者1的子网是不会被实际分配使用的，但是在RFC 1878<sup id="fnref:8" style="font-size:80%;line-height:80%;"><a href="#fn:8" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[8]</span></a></sup>废除了这个约定，所以本文也会遵照RFC 1878这个约定不再另行说明。在构成一个网段的所有子网段中，各个子网的子网掩码的长度是固定的，因此这种子网掩码也被称为FLSM(Fixed Length Subnet Masking)。子网掩码由如下的方式表示（以B类地址130.130.200.34为例）：</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1619053350/BlogImages/InternetSerials/ip-subnet-mask/Ip-network-subnet-demo1.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 3 子网掩码表示方法 <sup id="fnref:5" style="font-size:80%;line-height:80%;"><a href="#fn:5" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[5]</span></a></sup> </div>
&emsp;
</div>

<p>&emsp;&emsp;鉴于在某些场景下这种表示方法可能有些繁琐和不便，可采用<strong>CIDR斜线记法</strong>在IP地址后加“/n”表示当前IP地址所对应的子网掩码值，n为从主机号中“借走”的位数，在此例中n为4。故图 - 3的子网掩码可表示为130.130.200.34/20，这里的“/20”表示子网掩码由自左向右连续的20个1进制位和12个0进制位表示。<br>&emsp;&emsp;在得知子网掩码后，便可以根据IP地址和子网掩码计算该地址所处的子网和在子网中的主机号，子网号的具体计算方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IP地址点分十进制表示法：130.     130.     200.     34</span><br><span class="line">IP地址对应二进制表示法：10000010 10000010 11001000 00100010</span><br><span class="line">子网掩码点分十进制表示: 255.     255.     240.     0</span><br><span class="line">子网掩码二进制表示法：  11111111 11111111 11110000 00000000</span><br><span class="line">IP地址所处子网号：      10000010 10000010 11000000 00000000 //将IP地址与子网掩码按位做AND运算得到子网号</span><br><span class="line">IP地址所处子网号：      130.     130.     192.     0        //点分十进制表示</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;当前IP地址在所处子网中的对应主机号计算方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IP地址点分十进制表示法：130.     130.     200.     34</span><br><span class="line">IP地址对应二进制表示法：10000010 10000010 11001000 00100010</span><br><span class="line">子网掩码点分十进制表示: 255.     255.     240.     0</span><br><span class="line">子网掩码二进制表示法：  11111111 11111111 11110000 00000000</span><br><span class="line">子网掩码按位取反:       00000000 00000000 00001111 11111111 //先将子网掩码按位取反</span><br><span class="line">IP地址在子网中的主机号: 00000000 00000000 00001000 00100010 //再与IP地址按位做AND运算得到对应主机号</span><br><span class="line">IP地址在子网中的主机号: 0.       0.       8.       34       //点分十进制表示</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;一般情况下，会有两种子网划分的分配场景：根据期望的子网数进行划分和根据每个子网区域内期望的主机数进行划分。下面会以一个B类地址为背景说明这两种场景是如何进行子网划分的。</p>
<h3 id="根据期望的子网数进行划分"><a href="#根据期望的子网数进行划分" class="headerlink" title="根据期望的子网数进行划分"></a>根据期望的子网数进行划分</h3><p>&emsp;&emsp;当给定期望的子网数x后，计算得到一个能使$ 2^n $大于等于x的最小整数n，此时这个n值就是需要从主机号位数中借出来用作子网划分的位数。<br><strong>e.g. 1.  给定一个B类地址，默认子网掩码是255.255.0.0</strong><br>&emsp;&emsp;期望得到一个包含有6个子网的B类网络，那么x=6，由此可得能使$ 2^n $大于等于6的最小整数n=3，所以实际的子网掩码是255.255.224.0。由于在子网划分时从主机位借走了n=3位，所以实际的主机位数为16 - 3 = 13，那么当前的每个子网可容纳$ 2^{13} $个主机，其中有效主机数为$ 2^{13} $ - 2。</p>
<h3 id="根据单个子网内期望的主机数进行划分"><a href="#根据单个子网内期望的主机数进行划分" class="headerlink" title="根据单个子网内期望的主机数进行划分"></a>根据单个子网内期望的主机数进行划分</h3><p>&emsp;&emsp;当给定单个子网内期望的主机数x时，计算得到一个能使$ 2^n $大于等于x + 3的最小整数n，此时这个n值就是目的子网需要的主机号位数，而用来进行子网划分的位数N = 主机位数 - n（PS：主机位数等于当前地址对应的主机号位数）。这里的“+ 3”表示除了实际需要的主机数外，还需要包含一个主机号全为0的网络地址，一个主机号全为1的广播地址和一个网关地址。<br><strong>e.g. 2.  给定一个B类地址，默认子网掩码是255.255.0.0</strong><br>&emsp;&emsp;由于某些原因，每个网段能容纳的主机数为49，那么x=49，由此可得能使$ 2^n $大于等于49 + 3的最小整数n=6，划分后每个子网可用主机数为62。所以划分到子网号部分的二进制位数N = 16 - 6 = 10，所以实际的子网掩码是255.255.255.192。<br>&emsp;&emsp;子网划分虽然可以通过将一个大的网段划分成若干个小的网段来更加高效的使用IP地址资源，但是子网划分也带来了一些缺点和不足：</p>
<ol>
<li>网络复杂性提高<br> 子网划分实施后，有可能使得划分前处在同一个网段的的IP地址在划分后处在两个不同的网段，尤其是当IP地址相邻时。这使得网络的复杂度和维护成本显著提高。</li>
<li>通信成本开销上升<br> 由于划分子网后，不同子网之间是无法直接通信的，必须通过网关等中间层实现相互通信，通信成本也会上升。</li>
<li>还是会造成可观的IP地址浪费<br> 尽管实施了子网划分，但是划分出的每个子网的可用主机数量是相同的，实际中还是会出现某些子网的可用主机数量利用率高，而有些子网的可用主机数量利用率低的问题。</li>
</ol>
<h2 id="可变长子网掩码（VLSM）"><a href="#可变长子网掩码（VLSM）" class="headerlink" title="可变长子网掩码（VLSM）"></a>可变长子网掩码（VLSM）</h2><p>&emsp;&emsp;可变长子网掩码（Variable Length Subnet Masking）<sup id="fnref:8" style="font-size:80%;line-height:80%;"><a href="#fn:8" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[8]</span></a></sup>是为了更合理的利用IP地址资源而设计的一种可以多次进行子网划分以产生不同大小网络的网络分配机制。通过前面的介绍我们已经知道，固定长度子网掩码使得每个子网的子网掩码位数是相同的，每个子网包含的主机数也是相同的。一旦子网分配后，该子网内尚未使用的IP地址便无法供不属于当前子网所有者的主机使用，造成了浪费。通过应用VLSM可以最小程度的避免IP地址资源的浪费，在公共IP地址分类方面VLSM的优势更加明显。下面会通过一个例子来说明可变长度子网掩码是如何工作的。<br><strong>背景：</strong><br>&emsp;&emsp;张三最近新成立了组织，需要构建组织的办公网络，于是向当地的互联网地址分配机构申请了一个B类地址130.130.0.0/16。这个组织有4个部门，部门概要如表 - 2所示：</p>
<div style="text-align: left; width: 100%;">
    &emsp;&emsp;&emsp;&emsp;&emsp;表 - 2：部门网络设计概要
    <div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1619232346/BlogImages/InternetSerials/ip-subnet-mask/ip-subnet-mask-table-2.png" style="margin: 0 auto;">
</div></div>

<p>&emsp;&emsp;于是乎，组织的网络划分架构实施过程如下：</p>
<ol>
<li>首先根据从大到小的顺序将各个部门的网络接口数排序，结果是：<br> A（160） &gt; B（100） &gt; D（80）&gt; C（20）</li>
<li><p>先对部门A进行子网划分</p>
<ol>
<li>A需要160个网络接口，根据公式<script type="math/tex; mode=display">2^n \ge x + 3 \tag{1}</script> 计算得到满足公式的最小整数n = 8，子网号占据16 - 8 = 8位。所以便把130.130.0.0/16划分成了如下的255个子网号： <div style="text-align: left; width: 100%;">
     &emsp;&emsp;表 - 3：子网划分及其子网号表示
     <div style="text-align: left; width: 100%;">
 <img src="https://res.cloudinary.com/jknight/image/upload/v1619230992/BlogImages/InternetSerials/ip-subnet-mask/ip-subnet-mask-table-3.png" style="margin: 0 auto;">
 </div></div></li>
<li>部门A的网络规划配置如下<br> 部门A的子网掩码：255.255.255.0<br> 部门A的子网号：130.130.0.0/24（表 - 3中1号子网）<br> 第一个可用地址为：130.130.0.1<br> 最后一个可用地址为：130.130.0.254<br> 可用地址数量：254<br> 已用数量：160<br> 剩余数量：94</li>
</ol>
</li>
<li><p>对部门B进行网络规划</p>
<ol>
<li><p>B需要100个网络接口，在（2）中我们可知使用24位子网掩码时可以满足B的需求。我们选择将表 - 3中2号子网<strong>130.130.1.0/24</strong>分配给部门B并进行进一步的划分。尝试继续增加子网号位数，当子网掩码位数为25时，每个子网可容纳126个主机。所以对<strong>130.130.1.0/24</strong>做如下划分：</p>
 <div style="text-align: left; width: 100%;">
     &emsp;&emsp;表 - 4：子网130.130.1.0/24的划分结果
     <div style="text-align: left; width: 100%;">
 <img src="https://res.cloudinary.com/jknight/image/upload/v1619232346/BlogImages/InternetSerials/ip-subnet-mask/ip-subnet-mask-table-4.png" style="margin: 0 auto;">
 </div></div></li>
<li>部门B的网络规划配置如下：<br> 部门B的子网掩码：255.255.255.128<br> 部门B的子网号：130.130.1.0/25（表 - 4中1号子网）<br> 第一个可用地址为：130.130.1.1<br> 最后一个可用地址为：130.130.1.126<br> 可用地址数量:126<br> 已用数量：100<br> 剩余数量：26</li>
</ol>
</li>
<li><p>对部门D进行网络规划</p>
<ol>
<li>D需要80个网络接口，在（3）中我们知道可以使用和部门B相同的子网掩码位数，每个子网可容纳126个主机。所以将表 - 4 中2号子网<strong>130.130.1.128/25</strong>分配给部门D使用。</li>
<li>部门D的网络规划配置如下：<br> 部门D的子网掩码为：255.255.255.128<br> 部门D的子网号：130.130.1.128/25（表 - 4中2号子网）<br> 第一个可用地址为：130.130.1.129<br> 最后一个可用地址为：130.130.1.254<br> 可用地址数量:126<br> 已用数量：80<br> 剩余数量：46</li>
</ol>
</li>
<li><p>对部门C进行网络规划</p>
<ol>
<li><p>C需要20个网络接口，故划分后主机位数为5位，子网位数为11位。所以将表 - 3中3号子网<strong>130.130.2.0/24</strong>分配给部门C并做出如下划分：</p>
 <div style="text-align: left; width: 100%;">
     &emsp;&emsp;表 - 5：子网130.130.2.0/24的划分结果
     <div style="text-align: left; width: 100%;">
 <img src="https://res.cloudinary.com/jknight/image/upload/v1619232346/BlogImages/InternetSerials/ip-subnet-mask/ip-subnet-mask-table-5.png" style="margin: 0 auto;">
 </div></div></li>
<li>部门C的网络规划配置如下：<br> 部门C的子网掩码为：255.255.255.224<br> 部门C的子网号：130.130.2.0/27（表 - 5中1号子网）<br> 第一个可用地址为：130.130.2.1<br> 最后一个可用地址为：130.130.1.30<br> 可用地址数量:30<br> 已用数量：20<br> 剩余数量：10</li>
</ol>
</li>
<li><p>综上所述，整个组织的网络规划配置如下：</p>
 <div style="text-align: center; width: 100%;">
 <img src="https://res.cloudinary.com/jknight/image/upload/v1619232346/BlogImages/InternetSerials/ip-subnet-mask/ip-subnet-mask-table-6.png" style="margin: 0 auto;">
 </div>
</li>
<li><p>网络规划结束</p>
</li>
</ol>
<p>&emsp;&emsp;需要注意的是，如果要使用VLSM对网络进行划分，那么包括但不限于路由器、网关等设施都需要支持VLSM。</p>
<h2 id="无类别域间路由-CIDR"><a href="#无类别域间路由-CIDR" class="headerlink" title="无类别域间路由(CIDR)"></a>无类别域间路由(CIDR)</h2><p>&emsp;&emsp;标准的IP地址格式（也就是&lt;网络号&gt;+&lt;主机号&gt;格式）虽然简单易行，但是也有一些缺点，首先就是分配时很容易产生浪费，且这种浪费是不可再分配的。对于个人或者小型组织而言，一个C类网络很明显太大了，而对于多数企业而言又不太够。一个可容纳6万5千多台主机的B类网络很显然对大多数企业而言也会浪费很多IP地址资源。其次，不同网段之间相互通信需要建立路由表信息，随着网络数的增加，路由表的规模越来越大，对其进行有效维护变得越来越复杂。再加上IP地址耗尽等问题，ITEF尝试了一些优化和解决办法，其中一个就是于1993年提出的无类别域间路由技术。<br>&emsp;&emsp;无类别域间路由（Classless Inter-Domain Routing，CIDR /ˈsaɪdər, ˈsɪ-/） <sup id="fnref:9" style="font-size:80%;line-height:80%;"><a href="#fn:9" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[9]</span></a></sup><sup id="fnref:10" style="font-size:80%;line-height:80%;"><a href="#fn:10" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[10]</span></a></sup><sup id="fnref:11" style="font-size:80%;line-height:80%;"><a href="#fn:11" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[11]</span></a></sup>是一种应用于IP地址分配和IP路由的方法和技术。ITEF期望通过CIDR取代早先的A/B/C类IP地址分类架构。CIDR的实现依赖于可变长子网掩码，借助于可变长子网掩码技术，CIDR可以使用自最高位起8 ~ 30位二进制位构建网络号前缀。前文提到的”X.X.X.X/N”表示法也是CIDR首先提出来的。CIDR通过路由聚合，使得若干个小的子网聚合一个更大的网络，即所谓的<strong>超网（Supernetting）</strong><sup id="fnref:12" style="font-size:80%;line-height:80%;"><a href="#fn:12" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[12]</span></a></sup><sup id="fnref:13" style="font-size:80%;line-height:80%;"><a href="#fn:13" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[13]</span></a></sup>，将路由表中的按照规则尝试合并为成更少的数目，缓解了路由表数量快速攀升的问题，减少路由通告，同时也相应的提高了网络通信的速度和性能。<br>&emsp;&emsp;CIDR以二进制位为单位、使用基于前缀的标准和规则来表示IP地址和路由表条目属性，它通过将多个IP地址块合并成组并映射到一条路由表条目来简化路由操作，减少了不必要的路由表条目冗余。这些合并成组的地址块被称为<strong>CIDR地址块</strong>，块内的每个IP地址自最高位起具有若干位相同的二进制位表示，采用“X.X.X.X/n”表示，“/n”表示自最高位起共n位是相同的。比如，“130.130.13.23/24”表示自最高位起24位是相同的IP地址共有$ 2^{32 - 24} $个。如果n越小，那么每个网段可用的IP地址越多，反之亦然。下面通过维基百科的一段说明来了解CIDR是如何工作的：</p>
<blockquote>
<p>&ensp;&ensp;For example, in the late 1990s, the IP address <em>208.130.29.33</em> (since reassigned) was used by www.freesoft.org. An analysis of this address identified three CIDR prefixes. <em>208.128.0.0/11</em>, a large CIDR block containing over 2 million addresses, had been assigned by <a href="https://en.wikipedia.org/wiki/American_Registry_for_Internet_Numbers" target="_blank" rel="noopener">ARIN</a> (the North American RIR) to <a href="https://en.wikipedia.org/wiki/MCI_Communications" target="_blank" rel="noopener">MCI</a>. Automation Research Systems, a Virginia <a href="https://en.wikipedia.org/wiki/Value-added_reseller" target="_blank" rel="noopener">VAR</a>, leased an Internet connection from MCI and was assigned the <em>208.130.28.0/22</em> block, capable of addressing just over 1000 devices. ARS used a <em>/24</em> block for its publicly accessible servers, of which <em>208.130.29.33</em> was one. All of these CIDR prefixes would be used, at different locations in the network. Outside MCI’s network, the <em>208.128.0.0/11</em> prefix would be used to direct to MCI traffic bound not only for <em>208.130.29.33</em>, but also for any of the roughly two million IP addresses with the same initial 11 bits. Within MCI’s network, <em>208.130.28.0/22</em> would become visible, directing traffic to the leased line serving ARS. Only within the ARS corporate network would the <em>208.130.29.0/24</em> prefix have been used.</p>
<p>​                                                                                                                                                       — wikipedia</p>
</blockquote>
<p>ARIN机构向MCI分配了一个<strong>208.128.0.0/11</strong>的CIDR地址块，这个地址块包含了超过200万个IP地址资源。Automation Research Systems从MCI申请接入互联网，得到了一个可以容纳超过1000台设备的网段，地址是<strong>208.130.28.0/22</strong>。ARS则申请得到了一个“<strong>208.130.29.0/24</strong>”的地址块。在MCI之外所有目的地址自最高位起11位与<strong>208.128.0.0/11</strong>相同的流量都会被转发到MCI，当流量到达MCI后，再根据自最高位起22位或者24位的匹配情况，决定是否将流量转发到Automation Research Systems或者ARS。</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1619169940/BlogImages/InternetSerials/ip-subnet-mask/Ip-cidr-demo1.png" style="margin: 0 auto;">
</div>

<div align="center">
    <div align="center">图 - 4 CIDR示例图 </div>
&emsp;
</div>

<p>&emsp;&emsp;从上述例子中，我们看到原来需要2个及以上的全局路由表条目现在只需要一个到MCI的路由表条目就能完成流量路由和转发，大大减少了路由表条目的维护成本。所以可以将CIDR看做是子网划分的逆过程：子网划分通过向右划出二进制位给子网号部分使得子网数量增多，每个子网所包含的主机数量下降，而CIDR则向左归还二进制给主机位部分使得子网数量减少，单个子网的规模增加。二者看似截然相反，但是两者的目的和使用场景是完全不同的，所以二者本质上并无矛盾。实际上，两者只有结合起来才能更加灵活地进行IP地址资源分配，既保证IP地址利用率最大化，同时又保证了一定的网络通信性能和网络复杂度。</p>
<p>&emsp;&emsp;综上，由于IPv4地址结构的固有性质决定了IPv4地址资源的耗尽是一个不容忽视的问题。为了减缓IPv4地址资源消耗的速度和避免浪费，子网划分技术被提出并得到了广泛应用。子网划分可以固定长度的子网掩码进行，也可以采用可变长子网掩码技术，相较于固定长度子网掩码而言，可变长子网掩码技术更加灵活，能更好的避免IP地址资源浪费。但是子网划分带来的一个副作用就是需要为每个子网维护一个路由表条目，结果就是导致路由表规模越来越大，维护成本越来越高。为了解决这个问题，CIDR基于可变长子网掩码技术将多个小的子网聚合成一个大的超网，这些子网共享相同的指向超网的路由表信息和子网掩码，既保证了路由表条目不会增长太快，同时也保留了网络划分的灵活性。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top;">Postel, J., Internet protocol―DARPA internet program protocol specification, ITEF <a href="https://tools.ietf.org/pdf/rfc791" target="_blank" rel="noopener">RFC 791</a>, September 1981.</span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top;">Wikipedia contributors. <a href="https://en.wikipedia.org/w/index.php?title=Classful_network&amp;oldid=1016356303" target="_blank" rel="noopener">Classful network.</a> Wikipedia, The Free Encyclopedia, 6 April 2021.</span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top;">Comer, Douglas E. Internetworking with TCP/IP Vol. 1: Principles, Protocols and Applications, 6ed. Pearson, 2014.</span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top;">Postel, J., Address Mappings, ITEF <a href="https://tools.ietf.org/pdf/rfc796.pdf" target="_blank" rel="noopener">RFC 796</a>, September 1981.</span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top;">Mogul J., and J. Postel, Internet Standard Subnetting Procedure, STD 5, ITEF <a href="https://tools.ietf.org/pdf/rfc950.pdf" target="_blank" rel="noopener">RFC 950</a>, Stanford, USC/Information, August 1985.</span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top;">Tsuchiya, P. F. On the assignment of subnet numbers, ITEF <a href="https://tools.ietf.org/pdf/rfc1219.pdf" target="_blank" rel="noopener">RFC 1219</a>, April 1991.</span></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline-block; vertical-align: top;">Wikipedia contributors. <a href="https://en.wikipedia.org/w/index.php?title=Subnetwork&amp;oldid=1017756328" target="_blank" rel="noopener">Subnetwork.</a> Wikipedia, The Free Encyclopedia, 14 April 2021.</span></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">8.</span><span style="display: inline-block; vertical-align: top;">Pummill, T., and B. Manning. Variable Length Subnet Table For IPv4, ITEF <a href="https://tools.ietf.org/pdf/rfc1878.pdf" target="_blank" rel="noopener">RFC 1878</a>, December 1995.</span></li><li id="fn:9"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">9.</span><span style="display: inline-block; vertical-align: top;">Wikipedia contributors. <a href="https://en.wikipedia.org/w/index.php?title=Classless_Inter-Domain_Routing&amp;oldid=1018827207" target="_blank" rel="noopener">Classless Inter-Domain Routing</a>. Wikipedia, The Free Encyclopedia, 20 April 2021.</span></li><li id="fn:10"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">10.</span><span style="display: inline-block; vertical-align: top;">Fuller, Vince, et al. Classless inter-domain routing (CIDR): an address assignment and aggregation strategy, ITEF <a href="https://tools.ietf.org/pdf/rfc1519.pdf" target="_blank" rel="noopener">RFC 1519</a>, September 1993.</span></li><li id="fn:11"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">11.</span><span style="display: inline-block; vertical-align: top;">Rekhter, Y., and T. Li. An Architecture for IP Address Allocation with CIDR, ITEF <a href="https://tools.ietf.org/pdf/rfc1518.pdf" target="_blank" rel="noopener">RFC 1518</a>, September 1993.</span></li><li id="fn:12"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">12.</span><span style="display: inline-block; vertical-align: top;">Wikipedia contributors. <a href="https://en.wikipedia.org/w/index.php?title=Supernetwork&amp;oldid=1004215564" target="_blank" rel="noopener">Supernetwork.</a> Wikipedia, The Free Encyclopedia, 1 Febuary. 2021.</span></li><li id="fn:13"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">13.</span><span style="display: inline-block; vertical-align: top;">Fuller, Vince, et al. Supernetting: An address assignment and aggregation strategy, ITEF <a href="https://tools.ietf.org/pdf/rfc1338.pdf" target="_blank" rel="noopener">RFC-1338</a>, June, 1992.</span></li></ol></div><p><br><br><br><br></p></div></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>IP地址</tag>
        <tag>子网划分</tag>
      </tags>
  </entry>
  <entry>
    <title>Java I/O 04 - BufferedInputStream &amp; BufferedOutputStream</title>
    <url>/2018/Java-source-BufferedInput-OutputStream.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;关于<em> <strong>java.io.BufferedInputStream</strong> </em> 和 <em> <strong>java.io.BufferedOutputStream</strong> </em>的部分笔记，这两个类配套完成带缓存处理的字节输入、输出流操作。本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<p>&emsp;</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;BufferedInputStream和BufferedOutputStream两个类完成带缓存处理的字节输入、输出流操作。BufferedInputStream继承的InputStream负责从外部资源将数据移动到Java程序中 ，BufferedOutputStream继承的OutputStream负责从Java程序中将数据移动到外部目标 。这两个类分别继承了FilterInputStream和FilterOutputStream这两个类，内部引用了InputStream和OutputStream，在初始化实例BufferedInputStream和BufferedOutputStream时分别需要传入一个InputStream和OutputStream。BufferedInputStream和BufferedOutputStream两个类在设计时借鉴了装饰器模式的设计思想。BufferedInputStream和BufferedOutputStream在读写数据时，从数据源一次读入多个字节的数据存储在内存缓存中，待内存缓存写满后再一次性将读入的数据写入到其他目的位置，然后再重新填充新的输入流数据到内存缓存中，直至整个输入流的数据全部读完。通过内存缓存作为临时存储空间向磁盘读写数据的处理方式避免了很多对磁盘IO的操作，而读写内存相对于读写磁盘来说，速度更快，由此带来的好处就是在读写大容量数据时通过带缓存的读取比不带缓存的读取效率更高，会节省很多时间。</p>
<p>&emsp;</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BufferedInputStream</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">	--java.io.InputStream</span><br><span class="line">		--java.io.FilterInputStream</span><br><span class="line">			--java.io.BufferedInputStream</span><br><span class="line"></span><br><span class="line"><span class="comment">// BufferedOutputStream</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">	--java.io.OutputStream</span><br><span class="line">		--java.io.FilterOutputStream</span><br><span class="line">			--java.io.BufferedOutputStream</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类名</th>
<th style="text-align:center">实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">BufferedInputStream</td>
<td style="text-align:center">Closeable, AutoCloseable</td>
</tr>
<tr>
<td style="text-align:center">BufferedOutputStream</td>
<td style="text-align:center">Closeable, Flushable, AutoCloseable</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h2><h3 id="Fields"><a href="#Fields" class="headerlink" title="Fields"></a>Fields</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span></span><br><span class="line">        AtomicReferenceFieldUpdater&lt;BufferedInputStream, <span class="keyword">byte</span>[]&gt; bufUpdater = AtomicReferenceFieldUpdater.newUpdater</span><br><span class="line">        (BufferedInputStream.class,  <span class="keyword">byte</span>[].class, <span class="string">"buf"</span>);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;用来做缓存内容的原子更新，保证多线程下对缓存数组访问的安全性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当前缓存区的存储内容的字节数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前缓存区已经读到的位置。</span></span><br><span class="line"><span class="comment">//仅BufferedInputStream持有</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> pos;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前缓存区已经被标记的位置，通过mark()方法会将pos的值保存在markpos里，</span></span><br><span class="line"><span class="comment">//通过reset()方法会将markpos的值赋给pos，这样就实现缓存区数据的重读操作。</span></span><br><span class="line"><span class="comment">//仅BufferedInputStream持有</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> markpos = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//它的值表示在调用mark方法后reset方法前最多允许读取的字节数，如果超过这个限制，</span></span><br><span class="line"><span class="comment">//系统将不会再维护markpos位置值。也就是说，将不会再重新读到markpos之后的数据内容，</span></span><br><span class="line"><span class="comment">//同时在调用reset方法时会报：Resetting to invalid mark异常。</span></span><br><span class="line"><span class="comment">//这个变量的存在可以用来限制buffer数组的长度，使之不会无限制的增长导致过多的内存占用。</span></span><br><span class="line"><span class="comment">//仅BufferedInputStream持有</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> marklimit;</span><br></pre></td></tr></table></figure>
<h3 id="Constructor-Summary"><a href="#Constructor-Summary" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="public-BufferedInputStream-InputStream-in"><a href="#public-BufferedInputStream-InputStream-in" class="headerlink" title="public BufferedInputStream(InputStream in)"></a>public BufferedInputStream(InputStream in)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedInputStream</span><span class="params">(InputStream in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(in, defaultBufferSize);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="public-BufferedInputStream-InputStream-in-int-size"><a href="#public-BufferedInputStream-InputStream-in-int-size" class="headerlink" title="public BufferedInputStream(InputStream in, int size)"></a>public BufferedInputStream(InputStream in, int size)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedInputStream</span><span class="params">(InputStream in, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(in);</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Buffer size &lt;= 0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    buf = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="public-BufferedOutputStream-OutputStream-out"><a href="#public-BufferedOutputStream-OutputStream-out" class="headerlink" title="public BufferedOutputStream(OutputStream out)"></a>public BufferedOutputStream(OutputStream out)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedOutputStream</span><span class="params">(OutputStream out)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(out, <span class="number">8192</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="public-BufferedOutputStream-OutputStream-out-int-size"><a href="#public-BufferedOutputStream-OutputStream-out-int-size" class="headerlink" title="public BufferedOutputStream(OutputStream out, int size)"></a>public BufferedOutputStream(OutputStream out, int size)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedOutputStream</span><span class="params">(OutputStream out, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(out);</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Buffer size &lt;= 0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    buf = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="private-void-fill"><a href="#private-void-fill" class="headerlink" title="private void fill()"></a>private void fill()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = getBufIfOpen();</span><br><span class="line">    <span class="keyword">if</span> (markpos &lt; <span class="number">0</span>)</span><br><span class="line">        pos = <span class="number">0</span>;            <span class="comment">/* no mark: throw away the buffer */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pos &gt;= buffer.length)  <span class="comment">/* no room left in buffer */</span></span><br><span class="line">        <span class="keyword">if</span> (markpos &gt; <span class="number">0</span>) &#123;  <span class="comment">/* can throw away early part of the buffer */</span></span><br><span class="line">            <span class="keyword">int</span> sz = pos - markpos;</span><br><span class="line">            System.arraycopy(buffer, markpos, buffer, <span class="number">0</span>, sz);</span><br><span class="line">            pos = sz;</span><br><span class="line">            markpos = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buffer.length &gt;= marklimit) &#123;</span><br><span class="line">            markpos = -<span class="number">1</span>;   <span class="comment">/* buffer got too big, invalidate mark */</span></span><br><span class="line">            pos = <span class="number">0</span>;        <span class="comment">/* drop buffer contents */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;            <span class="comment">/* grow buffer */</span></span><br><span class="line">            <span class="keyword">int</span> nsz = pos * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nsz &gt; marklimit)</span><br><span class="line">                nsz = marklimit;</span><br><span class="line">            <span class="keyword">byte</span> nbuf[] = <span class="keyword">new</span> <span class="keyword">byte</span>[nsz];</span><br><span class="line">            System.arraycopy(buffer, <span class="number">0</span>, nbuf, <span class="number">0</span>, pos);</span><br><span class="line">            <span class="keyword">if</span> (!bufUpdater.compareAndSet(<span class="keyword">this</span>, buffer, nbuf)) &#123;</span><br><span class="line">                <span class="comment">// Can't replace buf if there was an async close.</span></span><br><span class="line">                <span class="comment">// Note: This would need to be changed if fill()</span></span><br><span class="line">                <span class="comment">// is ever made accessible to multiple threads.</span></span><br><span class="line">                <span class="comment">// But for now, the only way CAS can fail is via close.</span></span><br><span class="line">                <span class="comment">// assert buf == null;</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Stream closed"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            buffer = nbuf;</span><br><span class="line">        &#125;</span><br><span class="line">    count = pos;</span><br><span class="line">    <span class="keyword">int</span> n = getInIfOpen().read(buffer, pos, buffer.length - pos);</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">        count = n + pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;用来负责向缓冲区数组中填充新的原始流数据。这里有几个比较重要的判断：</p>
<ol>
<li>通过 if (pos &gt;= count) 判断判断是否读完缓冲区数组中的数据(这个判断在read方法中)； </li>
<li>通过 if (markpos &lt; 0) 判断判断输入流有没有被标记为需要重读的数据；</li>
<li>通过 if (pos &gt;= buffer.length) 判断判断缓冲区数组中有没有多余的空间来容纳新数据；</li>
</ol>
<p>第2行代码负责获取缓冲区数组的信息，第3 ~ 4行代码的判断用来处理用户未设置mark位置的场景。在这种场景下，不存在需要重读的数据，所以直接将pos位置的归零。第5 ~ 29行代码则考虑当前缓存数据中存在需要重读的数据，且pos已经超过了缓冲数组存储数据的有效长度，当前缓冲数组中已经没有空闲位置来容纳新读入的数据。第6 ~ 10行代码处理在markpos位置之前存在不需要重读可以被丢弃的额数，那么这种场景下只需要将自markpos位置之后的数据全部左移至缓冲区数组最左端即可，这样便释放了缓冲区数组的空闲存储位置来存放新读入的数据。第11 ~ 13行代码则处理markpos在缓冲区数组最左端且需要保存的数据满满的充斥着缓冲区，同时缓冲区数组存储数据的有效长度大于marklimit的场景，这种场景下由于数组长度（同时也是需要重读的数据内容长度）已经超过了允许重读读取的最大长度，所以这种情况下markpos已经不再起作用了，所以直接废弃现有markpos位置，重新归零。第15 ~ 29行则处理markpos在缓冲区数组最左端且需要保存的数据满满的充斥着缓冲区，同时缓冲区数组存储数据的有效长度不大于marklimit的场景，这种场景下markpos依旧有效，但是没有新位置容纳新读入的数据。所以需要执行扩容操作，将现有缓冲区数组的数据复制到一个新的长度更大的数组中。第31行代码则向缓冲区数组读入新的数据，最后更新缓冲区数组存储数据的有效长度。</p>
<h3 id="public-synchronized-int-read"><a href="#public-synchronized-int-read" class="headerlink" title="public synchronized int read()"></a>public synchronized int read()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &gt;= count) &#123;</span><br><span class="line">        fill();</span><br><span class="line">        <span class="keyword">if</span> (pos &gt;= count)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getBufIfOpen()[pos++] &amp; <span class="number">0xff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;获取数据的API。如果下一个读取位置比缓存数组中实际存储内容的有效长度大(pos &gt;= count)，那么就认为当前缓存中的内容已经被读完了，需要重新向缓存中写入新的数据，所以接下来会通过fill()方法来执行新数据的写入操作。如果写入操作执行后，下一个读取位置依旧比实际存储内容的有效长度大，那么会认为已经没有新的数据被写入了。最后会返回下一个位置的数据。但是在返回前需要与0XFF（1111 1111）执行一次与操作。因为缓存数组的类型是byte，而返回的类型是32位比特长度的int类型，在行5代码中，会返回<strong>-1</strong>标识数据已经读完。所以如果缓存数组中含有内容值-1时，需要确认-1的含义是什么。通过与0XFF相与，返回的内容中高24比特位都会被填充为0，所以即可辨别返回数据的含义。</p>
<h3 id="public-synchronized-void-write-int-b"><a href="#public-synchronized-void-write-int-b" class="headerlink" title="public synchronized void write(int b)"></a>public synchronized void write(int b)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &gt;= buf.length) &#123;</span><br><span class="line">        flushBuffer();</span><br><span class="line">    &#125;</span><br><span class="line">    buf[count++] = (<span class="keyword">byte</span>)b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushBuffer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        out.write(buf, <span class="number">0</span>, count);</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;用于向外部数据写数据。如果当前缓冲区数组已经存满了内容，那么就调用flushBuffer()方法将缓冲区数组中的内容写入到输出流中，同时清空缓冲区数组。</p>
<h3 id="public-synchronized-void-flush"><a href="#public-synchronized-void-flush" class="headerlink" title="public synchronized void flush()"></a>public synchronized void flush()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    flushBuffer();</span><br><span class="line">    out.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;用户主动触发向输出流写数据的操作，而不用等到缓冲区数组被写满后再执行。</p>
<h3 id="public-synchronized-int-read-byte-b-int-off-int-len"><a href="#public-synchronized-int-read-byte-b-int-off-int-len" class="headerlink" title="public synchronized int read(byte b[], int off, int len)"></a>public synchronized int read(byte b[], int off, int len)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	getBufIfOpen(); <span class="comment">// Check for closed stream</span></span><br><span class="line">    <span class="keyword">if</span> ((off | len | (off + len) | (b.length - (off + len))) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> nread = read1(b, off + n, len - n);</span><br><span class="line">        <span class="keyword">if</span> (nread &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (n == <span class="number">0</span>) ? nread : n;</span><br><span class="line">        n += nread;</span><br><span class="line">        <span class="keyword">if</span> (n &gt;= len)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="comment">// if not closed but no bytes available, return</span></span><br><span class="line">        InputStream input = in;</span><br><span class="line">        <span class="keyword">if</span> (input != <span class="keyword">null</span> &amp;&amp; input.available() &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">read1</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> avail = count - pos;</span><br><span class="line">    <span class="keyword">if</span> (avail &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* If the requested length is at least as large as the buffer, and</span></span><br><span class="line"><span class="comment">               if there is no mark/reset activity, do not bother to copy the</span></span><br><span class="line"><span class="comment">               bytes into the local buffer.  In this way buffered streams will</span></span><br><span class="line"><span class="comment">               cascade harmlessly. */</span></span><br><span class="line">         <span class="keyword">if</span> (len &gt;= getBufIfOpen().length &amp;&amp; markpos &lt; <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> getInIfOpen().read(b, off, len);</span><br><span class="line">         &#125;</span><br><span class="line">         fill();</span><br><span class="line">         avail = count - pos;</span><br><span class="line">         <span class="keyword">if</span> (avail &lt;= <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt = (avail &lt; len) ? avail : len;</span><br><span class="line">    System.arraycopy(getBufIfOpen(), pos, b, off, cnt);</span><br><span class="line">    pos += cnt;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个方法和前面谈论过的read()目的都是一样的，用于从原始输入流中读取数据。但是read()方法一次只会读取一个字节的数据到缓存区数组中，而这个方法会一次尽量读取多个字节的数据并返回，并且在没有读够指定长度的数据之前是不会结束操作的，除非数据流已经完全被读完。第5 ~ 9行负责做边界校验。第12 ~ 23行则每次分别从原始数据流中尽可能多的读数据到指定数组b中。第13行会得到从原始数据流中读取到的字节数量。第14 ~ 15行表示从原始数据流中读到的字节数是0，说明原始数据流中已经没有可读的数据了。第16行负责统计到当前循环已经得到的字节数。第17 ~ 18行表示已经获取到了指定数量的字节数，可以结束操作并返回了。第20 ~ 22行和第14 ~ 15行的含义相似，都表示当前原始数据流中已经没有新的可读数据了。</p>
<h3 id="public-synchronized-void-write-byte-b-int-off-int-len"><a href="#public-synchronized-void-write-byte-b-int-off-int-len" class="headerlink" title="public synchronized void write(byte b[], int off, int len)"></a>public synchronized void write(byte b[], int off, int len)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &gt;= buf.length) &#123;</span><br><span class="line">        <span class="comment">/* If the request length exceeds the size of the output buffer,</span></span><br><span class="line"><span class="comment">               flush the output buffer and then write the data directly.</span></span><br><span class="line"><span class="comment">               In this way buffered streams will cascade harmlessly. */</span></span><br><span class="line">        flushBuffer();</span><br><span class="line">        out.write(b, off, len);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; buf.length - count) &#123;</span><br><span class="line">        flushBuffer();</span><br><span class="line">    &#125;</span><br><span class="line">    System.arraycopy(b, off, buf, count, len);</span><br><span class="line">    count += len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;该方法会一次把多个字节的数据写入到外部流中。如果需写入数据的入参长度len大于缓冲区数组的长度，那么直接把缓冲区数组的内容写入到外部流中，同时把入参中的多个字节的数据也直接写入到外部流中。如果需写入数据的入参长度len大于缓冲区数组的空闲存储容量，那么把缓冲区数组的内容写入到外部流中。如果上述两种场景都不满足，那么就意味着当前缓冲区数组的空闲容量可以容纳全部需要写入的数据量，那么就把需要写入的数据存放到缓冲区数组中，同时更新缓冲区数组的长度。</p>
<h3 id="public-synchronized-long-skip-long-n"><a href="#public-synchronized-long-skip-long-n" class="headerlink" title="public synchronized long skip(long n)"></a>public synchronized long skip(long n)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    getBufIfOpen(); <span class="comment">// Check for closed stream</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> avail = count - pos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (avail &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// If no mark position set then don't keep in buffer</span></span><br><span class="line">        <span class="keyword">if</span> (markpos &lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> getInIfOpen().skip(n);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Fill in buffer to save bytes for reset</span></span><br><span class="line">        fill();</span><br><span class="line">        avail = count - pos;</span><br><span class="line">        <span class="keyword">if</span> (avail &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> skipped = (avail &lt; n) ? avail : n;</span><br><span class="line">    pos += skipped;</span><br><span class="line">    <span class="keyword">return</span> skipped;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;首先判断当前缓冲区数组是否有待读取的数据内容。如果没有的话就需要从数据源读取数据填充到缓冲区数组中，然后再次判断是否有待读取的数据内容。如果还是没有的话说明数据已经全部读完，所以第17行代码直接返回0。如果当前缓冲区数据中还有待读取的数据，那么判断入参n和剩余待读取数据长度的大小关系，并将pos移动到计算后的结果位置上。</p>
<h3 id="public-synchronized-int-available"><a href="#public-synchronized-int-available" class="headerlink" title="public synchronized int available()"></a>public synchronized int available()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">available</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = count - pos;</span><br><span class="line">    <span class="keyword">int</span> avail = getInIfOpen().available();</span><br><span class="line">    <span class="keyword">return</span> n &gt; (Integer.MAX_VALUE - avail)</span><br><span class="line">        ? Integer.MAX_VALUE</span><br><span class="line">        : n + avail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回剩余可读的字节数。</p>
<h3 id="public-synchronized-void-mark-int-readlimit-and-reset"><a href="#public-synchronized-void-mark-int-readlimit-and-reset" class="headerlink" title="public synchronized void mark(int readlimit) and reset()"></a>public synchronized void mark(int readlimit) and reset()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> readlimit)</span> </span>&#123;</span><br><span class="line">    marklimit = readlimit;</span><br><span class="line">    markpos = pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    getBufIfOpen(); <span class="comment">// Cause exception if closed</span></span><br><span class="line">    <span class="keyword">if</span> (markpos &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Resetting to invalid mark"</span>);</span><br><span class="line">    pos = markpos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;mark()方法用来设置需要重读数据的起始pos位置，同时限制了可以重读的数据的长度。也就是说，一旦调用了方法之后，就只能读取从markpos位置开始，长度为readlimit的内容。</p>
<p>&emsp;&emsp;reset()方法会将当前pos位置重新归为重读数据的起始位置，reset()方法调用之后再次读取时便会读到markpos位置起始的数据。</p>
<h3 id="public-void-close"><a href="#public-void-close" class="headerlink" title="public void close()"></a>public void close()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buffer;</span><br><span class="line">    <span class="keyword">while</span> ( (buffer = buf) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bufUpdater.compareAndSet(<span class="keyword">this</span>, buffer, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            InputStream input = in;</span><br><span class="line">            in = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (input != <span class="keyword">null</span>)</span><br><span class="line">                input.close();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Else retry in case a new buf was CASed in fill()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;关掉输入流，释放读取数据占用的资源。包括缓冲区数组和原始输入流对象，都要被关闭掉。在BufferedInputStream中，其他的几个主要方法都采用了synchronized关键字来修饰方法声明，以此来实现多线程下的数据安全访问。但是close()方法的声明中却没有采用该关键字，因为如果采用了synchronized关键字，会导致当前线程正在执行read方法时，如果想结束一个消耗巨大的读取操作却因为此时read()方法还没执行完，所以close方法必须等到read结束后才能执行，这会导致资源不能及时释放以致系统负载剧增。 但是该方法通过借助bufUpdater.compareAndSet()方法来保证多线程下的可以安全的释放输入流的相关资源。</p>
<p>&emsp;</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li><p>AtomicReferenceFieldUpdater：</p>
<p>AtomicReferenceFieldUpdater是一个基于反射的工具类，可以用来完成数据的原子更新。在本文中，通过使用<strong>AtomicReferenceFieldUpdater.newUpdater (BufferedInputStream.class,  byte[].class, “buf”)</strong>来生成一个BufferedInputStream类的byte数组类型的名字为buf的原子修改器，然后调用其compareAndSet()对buf字段进行修改。<br>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2></li>
<li>阿里中间件团队博客. <a href="http://jm.taobao.org/2012/07/31/bufferedinputstream-learn-source/" target="_blank" rel="noopener">BufferedInputStream 源码学习笔记</a> [E]</li>
<li>skywang12345. <a href="http://www.cnblogs.com/skywang12345/p/io_12.html" target="_blank" rel="noopener">java io系列12之 BufferedInputStream(缓冲输入流)的认知、源码和示例</a> [E]</li>
<li>zhihu. <a href="https://www.zhihu.com/question/60691393" target="_blank" rel="noopener">java的io缓冲区buffered，他们高效在哪里，底层还是一个一个字节读到底哪里高效了？</a> [E]</li>
<li>[中] 林信良. Java SE 7技術手冊[M]. 台北：碁峰, 2011.</li>
<li>chen_sg. <a href="https://hk.saowen.com/a/4d24aa3d25f9a5fc66600d4dd89b68c37a7b5114f324449544fc73f5a1e5bb67" target="_blank" rel="noopener">Java IO流學習總結三：緩衝流-BufferedInputStream、BufferedOutputStream</a> [E]</li>
<li>时间的朋友. <a href="https://www.cnblogs.com/doit8791/p/9098116.html" target="_blank" rel="noopener">Java原子属性更新器AtomicReferenceFieldUpdater的使用</a> [E]</li>
<li>tydhot. <a href="https://blog.csdn.net/weixin_40318210/article/details/82194986" target="_blank" rel="noopener">BufferedInputStream的read()方法源码解析</a> [E]</li>
<li>一mimo一. <a href="https://blog.csdn.net/u012814377/article/details/17137949" target="_blank" rel="noopener">InputStream mark()方法readlimit参数真实含义</a> [E]</li>
<li>DiaoCow. <a href="http://diaocow.iteye.com/blog/1746210" target="_blank" rel="noopener">BufferedInputStream实现原理分析</a> [E]</li>
<li>zhhphappy. <a href="http://zhhphappy.iteye.com/blog/1562427" target="_blank" rel="noopener">BufferedInputStream 源码学习笔记</a> [E]</li>
<li>stackoverflow. <a href="https://stackoverflow.com/questions/42389245/what-is-the-use-of-mark-read-limit-in-bufferedinputstream" target="_blank" rel="noopener">what is the use of mark read limit in bufferedinputstream</a> [E]<br>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java I/O  - JAVA I/O概述</title>
    <url>/2018/Java-source-IO-guide.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;在Java语言规范中，<strong>java.io</strong>下的接口和类设计负责完成系统输入、输出的功能，涵盖了数据流、序列化、文件、网络流多种应用场景，可以支持字节流、字符流的输入输出。所有测试及代码描述基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;在java.io包下，共有各种类51个，含有或涉及接口12个。具体信息参考表1和表2：</p>
<p>表1：包中含有类对象</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Class</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href>BufferedInputStream</a></td>
<td>A <code>BufferedInputStream</code> adds functionality to another input stream-namely, the ability to buffer the input and to support the <code>mark</code> and <code>reset</code> methods.</td>
</tr>
<tr>
<td><a href>BufferedOutputStream</a></td>
<td>The class implements a buffered output stream.</td>
</tr>
<tr>
<td><a href>BufferedReader</a></td>
<td>Reads text from a character-input stream, buffering characters so as to provide for the efficient reading of characters, arrays, and lines.</td>
</tr>
<tr>
<td><a href>BufferedWriter</a></td>
<td>Writes text to a character-output stream, buffering characters so as to provide for the efficient writing of single characters, arrays, and strings.</td>
</tr>
<tr>
<td><a href>ByteArrayInputStream</a></td>
<td>A <code>ByteArrayInputStream</code> contains an internal buffer that contains bytes that may be read from the stream.</td>
</tr>
<tr>
<td><a href>ByteArrayOutputStream</a></td>
<td>This class implements an output stream in which the data is written into a byte array.</td>
</tr>
<tr>
<td><a href>CharArrayReader</a></td>
<td>This class implements a character buffer that can be used as a character-input stream.</td>
</tr>
<tr>
<td><a href>CharArrayWriter</a></td>
<td>This class implements a character buffer that can be used as an Writer.</td>
</tr>
<tr>
<td>Console</td>
<td>Methods to access the character-based console device, if any, associated with the current Java virtual machine.</td>
</tr>
<tr>
<td><a href>DataInputStream</a></td>
<td>A data input stream lets an application read primitive Java data types from an underlying input stream in a machine-independent way.</td>
</tr>
<tr>
<td><a href>DataOutputStream</a></td>
<td>A data output stream lets an application write primitive Java data types to an output stream in a portable way.</td>
</tr>
<tr>
<td>File</td>
<td>An abstract representation of file and directory pathnames.</td>
</tr>
<tr>
<td>FileDescriptor</td>
<td>Instances of the file descriptor class serve as an opaque handle to the underlying machine-specific structure representing an open file, an open socket, or another source or sink of bytes.</td>
</tr>
<tr>
<td><a href>FileInputStream</a></td>
<td>A <code>FileInputStream</code> obtains input bytes from a file in a file system.</td>
</tr>
<tr>
<td><a href>FileOutputStream</a></td>
<td>A file output stream is an output stream for writing data to a <code>File</code> or to a <code>FileDescriptor</code>.</td>
</tr>
<tr>
<td>FilePermission</td>
<td>This class represents access to a file or directory.</td>
</tr>
<tr>
<td><a href>FileReader</a></td>
<td>Convenience class for reading character files.</td>
</tr>
<tr>
<td><a href>FileWriter</a></td>
<td>Convenience class for writing character files.</td>
</tr>
<tr>
<td>FilterInputStream</td>
<td>A <code>FilterInputStream</code> contains some other input stream, which it uses as its basic source of data, possibly transforming the data along the way or providing additional functionality.</td>
</tr>
<tr>
<td>FilterOutputStream</td>
<td>This class is the superclass of all classes that filter output streams.</td>
</tr>
<tr>
<td><a href>FilterReader</a></td>
<td>Abstract class for reading filtered character streams.</td>
</tr>
<tr>
<td><a href>FilterWriter</a></td>
<td>Abstract class for writing filtered character streams.</td>
</tr>
<tr>
<td><a href>InputStream</a></td>
<td>This abstract class is the superclass of all classes representing an input stream of bytes.</td>
</tr>
<tr>
<td><a href>InputStreamReader</a></td>
<td>An InputStreamReader is a bridge from byte streams to character streams: It reads bytes and decodes them into characters using a specified <code>charset</code>.</td>
</tr>
<tr>
<td>LineNumberInputStream</td>
<td>Deprecated<em>This class incorrectly assumes that bytes adequately represent characters.</em></td>
</tr>
<tr>
<td>LineNumberReader</td>
<td>A buffered character-input stream that keeps track of line numbers.</td>
</tr>
<tr>
<td><a href>ObjectInputStream</a></td>
<td>An ObjectInputStream deserializes primitive data and objects previously written using an ObjectOutputStream.</td>
</tr>
<tr>
<td><a href>ObjectInputStream.GetField</a></td>
<td>Provide access to the persistent fields read from the input stream.</td>
</tr>
<tr>
<td><a href>ObjectOutputStream</a></td>
<td>An ObjectOutputStream writes primitive data types and graphs of Java objects to an OutputStream.</td>
</tr>
<tr>
<td>ObjectOutputStream.PutField</td>
<td>Provide programmatic access to the persistent fields to be written to ObjectOutput.</td>
</tr>
<tr>
<td>ObjectStreamClass</td>
<td>Serialization’s descriptor for classes.</td>
</tr>
<tr>
<td>ObjectStreamField</td>
<td>A description of a Serializable field from a Serializable class.</td>
</tr>
<tr>
<td><a href>OutputStream</a></td>
<td>This abstract class is the superclass of all classes representing an output stream of bytes.</td>
</tr>
<tr>
<td><a href>OutputStreamWriter</a></td>
<td>An OutputStreamWriter is a bridge from character streams to byte streams: Characters written to it are encoded into bytes using a specified <code>charset</code>.</td>
</tr>
<tr>
<td><a href>PipedInputStream</a></td>
<td>A piped input stream should be connected to a piped output stream; the piped input stream then provides whatever data bytes are written to the piped output stream.</td>
</tr>
<tr>
<td><a href>PipedOutputStream</a></td>
<td>A piped output stream can be connected to a piped input stream to create a communications pipe.</td>
</tr>
<tr>
<td><a href>PipedReader</a></td>
<td>Piped character-input streams.</td>
</tr>
<tr>
<td><a href>PipedWriter</a></td>
<td>Piped character-output streams.</td>
</tr>
<tr>
<td><a href>PrintStream</a></td>
<td>A <code>PrintStream</code> adds functionality to another output stream, namely the ability to print representations of various data values conveniently.</td>
</tr>
<tr>
<td><a href>PrintWriter</a></td>
<td>Prints formatted representations of objects to a text-output stream.</td>
</tr>
<tr>
<td><a href>PushbackInputStream</a></td>
<td>A <code>PushbackInputStream</code> adds functionality to another input stream, namely the ability to “push back” or “unread” one byte.</td>
</tr>
<tr>
<td><a href>PushbackReader</a></td>
<td>A character-stream reader that allows characters to be pushed back into the stream.</td>
</tr>
<tr>
<td>RandomAccessFile</td>
<td>Instances of this class support both reading and writing to a random access file.</td>
</tr>
<tr>
<td><a href>Reader</a></td>
<td>Abstract class for reading character streams.</td>
</tr>
<tr>
<td><a href>SequenceInputStream</a></td>
<td>A <code>SequenceInputStream</code> represents the logical concatenation of other input streams.</td>
</tr>
<tr>
<td>SerializablePermission</td>
<td>This class is for Serializable permissions.</td>
</tr>
<tr>
<td>StreamTokenizer</td>
<td>The <code>StreamTokenizer</code> class takes an input stream and parses it into “tokens”, allowing the tokens to be read one at a time.</td>
</tr>
<tr>
<td>StringBufferInputStream</td>
<td>Deprecated<em>This class does not properly convert characters into bytes.</em></td>
</tr>
<tr>
<td><a href>StringReader</a></td>
<td>A character stream whose source is a string.</td>
</tr>
<tr>
<td><a href>StringWriter</a></td>
<td>A character stream that collects its output in a string buffer, which can then be used to construct a string.</td>
</tr>
<tr>
<td><a href>Writer</a></td>
<td>Abstract class for writing to character streams.</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<p>表2：含有或涉及接口</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Interface</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Closeable</td>
<td>A <code>Closeable</code> is a source or destination of data that can be closed.</td>
</tr>
<tr>
<td>DataInput</td>
<td>The <code>DataInput</code> interface provides for reading bytes from a binary stream and reconstructing from them data in any of the Java primitive types.</td>
</tr>
<tr>
<td>DataOutput</td>
<td>The <code>DataOutput</code> interface provides for converting data from any of the Java primitive types to a series of bytes and writing these bytes to a binary stream.</td>
</tr>
<tr>
<td>Externalizable</td>
<td>Only the identity of the class of an Externalizable instance is written in the serialization stream and it is the responsibility of the class to save and restore the contents of its instances.</td>
</tr>
<tr>
<td>FileFilter</td>
<td>A filter for abstract pathnames.</td>
</tr>
<tr>
<td>FilenameFilter</td>
<td>Instances of classes that implement this interface are used to filter filenames.</td>
</tr>
<tr>
<td>Flushable</td>
<td>A <code>Flushable</code> is a destination of data that can be flushed.</td>
</tr>
<tr>
<td>ObjectInput</td>
<td>ObjectInput extends the DataInput interface to include the reading of objects.</td>
</tr>
<tr>
<td>ObjectInputValidation</td>
<td>Callback interface to allow validation of objects within a graph.</td>
</tr>
<tr>
<td>ObjectOutput</td>
<td>ObjectOutput extends the DataOutput interface to include writing of objects.</td>
</tr>
<tr>
<td>ObjectStreamConstants</td>
<td>Constants written into the Object Serialization Stream.</td>
</tr>
<tr>
<td>Serializable</td>
<td>Serializability of a class is enabled by the class implementing the java.io.Serializable interface.</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;关于Java.io包下的类和接口设计，大致可做如下分类：</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1542809473/BlogImages/21568302018/java_io_structure.png" alt></p>
<p>&emsp;&emsp;在接下来的若干篇文章中将逐个学习IO类的设计思路和使用场景。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><p>许 令波 . <a href="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/index.html" target="_blank" rel="noopener">深入分析 Java I/O 的工作机制</a> [E]</p>
</li>
<li><p>Oracle. <a href="https://docs.oracle.com/javase/7/docs/api/java/io/package-summary.html" target="_blank" rel="noopener">Java Platform Standard Edition 7</a> [M]</p>
</li>
<li><p>小明. <a href="https://zhuanlan.zhihu.com/p/28286559" target="_blank" rel="noopener">Java IO，硬骨头也能变软</a> [E]</p>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
      </tags>
  </entry>
  <entry>
    <title>Java源码阅读笔记01 - Integer</title>
    <url>/2018/Java-source-Integer.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;关于<em> <strong>java.lang.Integer</strong> </em>的部分笔记，基于JDK版本<strong>1.7</strong>。<br><a id="more"></a></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;Java语言中关于基础数据类型<strong>int</strong>的封装类型，包含了一些类型之间的相互转换封装方法，除此之外还有一些关于机器数操作的封装API供开发人员使用。</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">--java.lang.Object</span><br><span class="line">  --java.lang.Number</span><br><span class="line">    --java.lang.Integer</span><br></pre></td></tr></table></figure>
<h2 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h2><h3 id="getChars-int-i-int-index-char-buf"><a href="#getChars-int-i-int-index-char-buf" class="headerlink" title="getChars(int i, int index, char[] buf)"></a>getChars(int i, int index, char[] buf)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getChars</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> index, <span class="keyword">char</span>[] buf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q, r;</span><br><span class="line">    <span class="keyword">int</span> charPos = index;</span><br><span class="line">    <span class="keyword">char</span> sign = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        sign = <span class="string">'-'</span>;</span><br><span class="line">        i = -i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Generate two digits per iteration</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">65536</span>) &#123;</span><br><span class="line">        q = i / <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// really: r = i - (q * 100);</span></span><br><span class="line">        r = i - ((q &lt;&lt; <span class="number">6</span>) + (q &lt;&lt; <span class="number">5</span>) + (q &lt;&lt; <span class="number">2</span>));</span><br><span class="line">        i = q;</span><br><span class="line">        buf [--charPos] = DigitOnes[r];</span><br><span class="line">        buf [--charPos] = DigitTens[r];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fall thru to fast mode for smaller numbers</span></span><br><span class="line">    <span class="comment">// assert(i &lt;= 65536, i);</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        q = (i * <span class="number">52429</span>) &gt;&gt;&gt; (<span class="number">16</span>+<span class="number">3</span>);</span><br><span class="line">        r = i - ((q &lt;&lt; <span class="number">3</span>) + (q &lt;&lt; <span class="number">1</span>));  <span class="comment">// r = i-(q*10) ...</span></span><br><span class="line">        buf [--charPos] = digits [r];</span><br><span class="line">        i = q;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sign != <span class="number">0</span>) &#123;</span><br><span class="line">        buf [--charPos] = sign;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个方法是Integer转String 的核心方法，目的是为了将一个整数存入一个char数组中。如果传入的i是个负数，那么需要继续正负号并将入参转成正数去处理。关于乘除法和位运算的效率，<strong>位运算的效率高于乘法，乘法的效率高于除法</strong>，所以坚持尽可能优先使用位运算的原则。但是整型数int的范围最大为 $ 2^{31-1} $ ,所以使用位运算和乘法时入参<strong>i</strong>实际上有一个上界。接着将行24的代码抽象为等式： </p>
<script type="math/tex; mode=display">
q = (i * num1) >>> num2,</script><p>行25的等式说明行24需要计算入参i除以10后得到的商值。 行24可以继续转换成</p>
<script type="math/tex; mode=display">
q = i * (num1 / 2^{num2}).</script><p>根据上述两个等式，要保证i * num1不能超过int的范围，同时num1 / $ 2^{num2} $ 在保证精度的情况下尽可能等于0.1。所以对num2遍历取值判断，发现当num2=19，num1=52429时，小数后六位0可以满足精度要求，所以选定num1为52429，num2=19。因为i $*$ num1有最大值限制，而且行24的等式采用的是无符号右移方案，所以int的最大值可以是 $ 2^{32} $ ，因为num1为52429接近 $ 2^{15} $ ，所以i采用了65536( $ 2^{16} $ )作为判断边界。</p>
<h3 id="decode-String-nm"><a href="#decode-String-nm" class="headerlink" title="decode(String nm)"></a>decode(String nm)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">decode</span><span class="params">(String nm)</span> <span class="keyword">throws</span> NumberFormatException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> radix = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> negative = <span class="keyword">false</span>;</span><br><span class="line">    Integer result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nm.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(<span class="string">"Zero length string"</span>);</span><br><span class="line">    <span class="keyword">char</span> firstChar = nm.charAt(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Handle sign, if present</span></span><br><span class="line">    <span class="keyword">if</span> (firstChar == <span class="string">'-'</span>) &#123;</span><br><span class="line">        negative = <span class="keyword">true</span>;</span><br><span class="line">        index++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstChar == <span class="string">'+'</span>)</span><br><span class="line">        index++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle radix specifier, if present</span></span><br><span class="line">    <span class="keyword">if</span> (nm.startsWith(<span class="string">"0x"</span>, index) || nm.startsWith(<span class="string">"0X"</span>, index)) &#123;</span><br><span class="line">        index += <span class="number">2</span>;</span><br><span class="line">        radix = <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nm.startsWith(<span class="string">"#"</span>, index)) &#123;</span><br><span class="line">        index ++;</span><br><span class="line">        radix = <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nm.startsWith(<span class="string">"0"</span>, index) &amp;&amp; nm.length() &gt; <span class="number">1</span> + index) &#123;</span><br><span class="line">        index ++;</span><br><span class="line">        radix = <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nm.startsWith(<span class="string">"-"</span>, index) || nm.startsWith(<span class="string">"+"</span>, index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(<span class="string">"Sign character in wrong position"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = Integer.valueOf(nm.substring(index), radix);</span><br><span class="line">        result = negative ? Integer.valueOf(-result.intValue()) : result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        <span class="comment">// If number is Integer.MIN_VALUE, we'll end up here. The next line</span></span><br><span class="line">        <span class="comment">// handles this case, and causes any genuine format error to be</span></span><br><span class="line">        <span class="comment">// rethrown.</span></span><br><span class="line">        String constant = negative ? (<span class="string">"-"</span> + nm.substring(index))</span><br><span class="line">            : nm.substring(index);</span><br><span class="line">        result = Integer.valueOf(constant, radix);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个方法是将一个没有指定进制的字符串转换成响应进制的整型数字，具体采用的进制通过入参字符串前两位（前一位）字符判断得到。在行26中，有一个判断入参字符串长度的操作，这个操作只出现在了八进制中。这个判断的目的是确定是否应该采用八进制作为转换标准，因为八进制表示法的第一位是0，单纯通过第一位无法判断该采用八进制还是十进制。所以加入了长度的判断操作，如果第一位为0且之后还有数据，那么就采用八进制作为转换依据。</p>
<h3 id="reverse-int-i"><a href="#reverse-int-i" class="headerlink" title="reverse(int i)"></a>reverse(int i)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// HD, Figure 7-1</span></span><br><span class="line">    i = (i &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span> | (i &gt;&gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>;</span><br><span class="line">    i = (i &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span> | (i &gt;&gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>;</span><br><span class="line">    i = (i &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span> | (i &gt;&gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f</span>;</span><br><span class="line">    i = (i &lt;&lt; <span class="number">24</span>) | ((i &amp; <span class="number">0xff00</span>) &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">        ((i &gt;&gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff00</span>) | (i &gt;&gt;&gt; <span class="number">24</span>);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;实现入参int数值（以下简称为入参）的二进制补码的逆序返回。借鉴了分治的思想，首先将入参数值的补码每两位一组，左右交换码值。在行3中，0x55555555的二进制值是01010101010101010101010101010101，与入参执行按位与操作，再向左移动一位，低位补0，这样入参按两位分组后的低位码值即移到了左边。同时将入参向右移动一位，高位补0，与0x55555555执行按位与操作取得入参按两位分组后的高位码值即移动了右边，两个结果按位或执行后，即为入参按照两位分组后逆序交换后的结果。同理，在行4中，0x33333333的二进制值是00110011001100110011001100110011，会将行3执行后的补码序列按照每四位一组进行分组，每组中的高两位和低两位依次交换先后顺序。在行5中，则对行4操作执行完毕后的补码每八位一组，按照高四位和低四位依次交换先后顺序。至此，就已经完成了4个字节内部的补码逆序操作。行6 ~ 7以字节为单位，分别将低位第四字节左移到高位第一位，低位第三字节左移到高位第二位，高位第一字节右移到低位第四位，高位第二字节右移到低位第三位，四个结果按位取或结果，返回最后逆序的结果。</p>
<p>&emsp;&emsp;<strong>同理论方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverseBytes</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i &gt;&gt;&gt; <span class="number">24</span>)        ) |</span><br><span class="line">        ((i &gt;&gt;   <span class="number">8</span>) &amp;   <span class="number">0xFF00</span>) |</span><br><span class="line">        ((i &lt;&lt;   <span class="number">8</span>) &amp; <span class="number">0xFF0000</span>) |</span><br><span class="line">        ((i &lt;&lt; <span class="number">24</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bitCount-int-i"><a href="#bitCount-int-i" class="headerlink" title="bitCount(int i)"></a>bitCount(int i)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bitCount</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// HD, Figure 5-2</span></span><br><span class="line">    i = i - ((i &gt;&gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">    i = (i &amp; <span class="number">0x33333333</span>) + ((i &gt;&gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">    i = (i + (i &gt;&gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0f0f0f0f</span>;</span><br><span class="line">    i = i + (i &gt;&gt;&gt; <span class="number">8</span>);</span><br><span class="line">    i = i + (i &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> i &amp; <span class="number">0x3f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;统计入参int数值（以下简称为入参）补码表示中值为1的二进制位的个数。如下图：</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1533028543/Integer_bitCount_binary_tree_demo.png" alt></p>
<div align="center">
<div align="center">图 - 1</div>
&emsp;
</div>

<p>第一行是入参的补码表示，接着将补码两两分组，分别统计每个分组中二进制位为1的个数，并用两位二进制替换原来的分组，该两位二进制的值标识对应分组中二进制位为1的个数，于是得到第二行的补码序列。</p>
<p>&emsp;&emsp;根据第一行和第二行的补码序列，我们可以观察到：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">二进制位input</th>
<th style="text-align:center">用来标识1的个数的新二进制位output</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">00</td>
<td style="text-align:center">00</td>
<td style="text-align:center">没有1</td>
</tr>
<tr>
<td style="text-align:center">01</td>
<td style="text-align:center">01</td>
<td style="text-align:center">一个1</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">01</td>
<td style="text-align:center">一个1</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">10</td>
<td style="text-align:center">两个1</td>
</tr>
</tbody>
</table>
</div>
<p>现在需要通过input列的二进制序列计算出output序列。发现等式output = input - （input &gt;&gt;&gt; 1）。如果input不是两位二进制，例如四位、八位、十六位、三十二位，上述等式并不成立，原因在于左两位二进制的移动影响了后两位二进制中的高位，于是把高位全部记为0，即源码中行3的表述。</p>
<p>&emsp;&emsp;同理，图1中将第二行得到的补码序列两两相加构成一个四位二进制序列，之后再将新生成的四位二进制序列两两相加，构成一个八位二进制序列，直至最后得到一个32位的补码序列，该序列的值即为入参的补码表示中二进制位为1的个数。</p>
<p>&emsp;&emsp;关于源码实现，行4首先计算低两位与11的与和，然后将序列右移两位计算高两位与11的与和，结果相加构成若干个四位二进制序列分组。行5将序列右移四位计算高四位与1111的与和，然后与原序列相加，结果为若干八位二进制序列分组。行6将序列右移八位后，高八位和低八位可做加法操作，得到16位二进制序列。行7计算序列高十六位和低十六位的和得到一个三十二位序列。因为一个int数值的二进制长度是32($ 2^6 $)位，所以高于六位的二进制位都是无效的，所以通过0x3F将高于六位的二进制位清零计算最后结果。</p>
<h3 id="IntegerCache"><a href="#IntegerCache" class="headerlink" title="IntegerCache"></a>IntegerCache</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">            i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">            <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">            h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;原作者之所以设计这段代码，可能是出于性能的考虑。这段代码缓存了从-128到127共256个int型数值。如果在需要创建Integer实例的时候，如果值在-128到127之间，那么会直接从缓存里取值而不是重新创建对象。</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li>原码、反码、补码概念及相互转换；</li>
<li>左移、有符号右移和无符号右移。</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://segmentfault.com/a/1190000015763941" target="_blank" rel="noopener">java源码Integer.bitCount算法解析，分析原理（统计二进制bit位）</a></li>
<li><a href="https://blog.csdn.net/cor_twi/article/details/53720640" target="_blank" rel="noopener">Java源码 Integer.bitCount实现过程</a></li>
<li><a href="https://hk.saowen.com/a/0c5dd532a4a10d79ad70ba2c4f765036db1dcc02e6d4e8d23b500ceda367f661" target="_blank" rel="noopener">JDK源碼 Integer.bitCount(i)</a></li>
<li>白中英 (2013)。《计算机组成原理》。北京：科学出版社   </li>
</ol>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
      </tags>
  </entry>
  <entry>
    <title>Java源码阅读笔记03 - 字符串三剑客</title>
    <url>/2018/Java-source-String-StringBuilder-StringBuffer.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;在Java语言规范中，处理一个字符串可以通过三个类 — <strong>String、StringBuilder、StringBuffer</strong>来实现，三者之间在增删改字符串内容时采用的方法和原理有很多不一致的地方，这里将简单论述上述三个类型的异同。本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;在String、StringBuilder、StringBuffer中，String被定义为不可变类型，也就是说String对象value字段一经赋值就不会被改变，直至生命周期结束被垃圾回收机制回收。而后两者是可变的，并且都提供了对应的API以便开发人员可以根据需要修改其所包含的内容。但是后两者也有一些区别，StringBuilder不适用于多线程环境，StringBuffer可以在多线程环境中保证数据一致。鉴于此，StringBuilder的处理效率相对于StringBuffer来说会更乐观一些。</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//StringBuilder/StringBuffer</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">    --java.lang.AbstractStringBuilder</span><br><span class="line">        --java.lang.StringBuilder/StringBuffer</span><br><span class="line"></span><br><span class="line"><span class="comment">//String     </span></span><br><span class="line">--java.lang.Object</span><br><span class="line">    --java.lang.String</span><br></pre></td></tr></table></figure>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类名</th>
<th style="text-align:center">实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">String</td>
<td style="text-align:center">Serializable, CharSequence, Comparable&lt;String&gt;</td>
</tr>
<tr>
<td style="text-align:center">StringBuilder/StringBuffer</td>
<td style="text-align:center">Serializable, Appendable, CharSequence</td>
</tr>
</tbody>
</table>
</div>
<h2 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h2><h3 id="Constructor-Summary"><a href="#Constructor-Summary" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(str.length() + <span class="number">16</span>);</span><br><span class="line">    append(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">(CharSequence seq)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(seq.length() + <span class="number">16</span>);</span><br><span class="line">    append(seq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;StringBuilder中有四个构造方法，代码中第一个构造方法是个无参构造方法，这个方法内部会调用super()方法然后执行 <strong>AbstractStringBuilder</strong>的构造方法<strong>AbstractStringBuilder(int capacity)</strong>，这个方法里会初始化一个类型为char数组的value字段，并指定value的长度为16位。行5 - 7的构造方法通过传入一个容量值来指定value字段的长度。行9 - 17的两个有参构造方法在入参长度的基础上延长十六位来初始化value字段的长度，然后通过调用append()方法向value字段赋值。所以，StringBuilder会在实例化对象时预留十六个长度来实现内容的增删改操作。</p>
<p>&emsp;&emsp;StringBuffer同样有四个构造方法，方法声明和内部执行过程和StringBuilder相同，这里不予赘述。</p>
<h3 id="public-StringBuilder-append-String-str"><a href="#public-StringBuilder-append-String-str" class="headerlink" title="public StringBuilder append(String str)"></a>public StringBuilder append(String str)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 行2中调用的是继承的父类AbstractStringBuilder的append方法，代码执行如下：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>) str = <span class="string">"null"</span>;</span><br><span class="line">    <span class="keyword">int</span> len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>)</span><br><span class="line">        expandCapacity(minimumCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">expandCapacity</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = value.length * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minimumCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minimumCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (minimumCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        newCapacity = Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    value = Arrays.copyOf(value, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如代码，在AbstractStringBuilder类中实现了一个append()方法用来将入参字符串追加到现有字符串尾部。如果入参字符串为空，那么会把null追加到当前字符串尾部。通过方法ensureCapacityInternal()判断当前字符串是否有足够的空间来容纳入参字符串，如果发现空间不足，那么就调用expandCapacity()方法进行扩容操作。之后将入参字符串加入到当前字符串尾部，更新当前字符串长度值，并返回最终字符串内容。由于StringBuilder继承了AbstractStringBuilder类，于是对append()方法进行了重写同时调用父类AbstractStringBuilder的append()方法计算拼接后的StringBuilder对象value值。</p>
<p>&emsp;&emsp;StringBuffer中append(String str)方法的执行和StringBuilder相同，唯一不同的是StringBuffer在append(String str)的方法声明中加入了关键字<strong>synchronized</strong>来表示该方法在执行时需要进行锁定，待执行完毕后释放锁供其他线程调用。StringBuffer中的方法声明如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="public-StringBuilder-append-Object-obj"><a href="#public-StringBuilder-append-Object-obj" class="headerlink" title="public StringBuilder append(Object obj)"></a>public StringBuilder append(Object obj)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> append(String.valueOf(obj));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;该方法将obj转成String对象，然后调用append(String str)获取最后结果。</p>
<h3 id="public-StringBuilder-append-CharSequence-s"><a href="#public-StringBuilder-append-CharSequence-s" class="headerlink" title="public StringBuilder append(CharSequence s)"></a>public StringBuilder append(CharSequence s)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(CharSequence s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">        s = <span class="string">"null"</span>;</span><br><span class="line">    <span class="keyword">if</span> (s <span class="keyword">instanceof</span> String)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.append((String)s);</span><br><span class="line">    <span class="keyword">if</span> (s <span class="keyword">instanceof</span> StringBuffer)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.append((StringBuffer)s);</span><br><span class="line">    <span class="keyword">if</span> (s <span class="keyword">instanceof</span> StringBuilder)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.append((StringBuilder)s);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.append(s, <span class="number">0</span>, s.length());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>     IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(CharSequence s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.append(s, start, end);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(CharSequence s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">        s = <span class="string">"null"</span>;</span><br><span class="line">    <span class="keyword">if</span> ((start &lt; <span class="number">0</span>) || (start &gt; end) || (end &gt; s.length()))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(</span><br><span class="line">        <span class="string">"start "</span> + start + <span class="string">", end "</span> + end + <span class="string">", s.length() "</span></span><br><span class="line">        + s.length());</span><br><span class="line">    <span class="keyword">int</span> len = end - start;</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start, j = count; i &lt; end; i++, j++)</span><br><span class="line">        value[j] = s.charAt(i);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;由于String、StringBuffer、StringBuilder都有继承CharSequence类，所以需要分类判断根据入参类型执行对应的append()方法。如果发现入参不属于String、StringBuffer、StringBuilder三者中的任意一个，那么AbstractStringBuilder也有对应的方法供使用。在append(CharSequence s, int start, int end)方法中，首先做各种边界判断条件并减产当前字符串对象的空余容量是否能包含入参的所有内容。最后循环遍历入参内容指定范围内的内容并加入到value字段中返回。</p>
<p>&emsp;&emsp;同理，StringBuffer也是通过在方法声明中加入关键字synchronized来实现多线程之间的数据访问控制，方法声明如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(CharSequence s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.append(s, start, end);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="public-StringBuilder-reverse"><a href="#public-StringBuilder-reverse" class="headerlink" title="public StringBuilder reverse()"></a>public StringBuilder reverse()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">reverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.reverse();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">reverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> hasSurrogate = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> n = count - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = (n-<span class="number">1</span>) &gt;&gt; <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="keyword">char</span> temp = value[j];</span><br><span class="line">        <span class="keyword">char</span> temp2 = value[n - j];</span><br><span class="line">        <span class="keyword">if</span> (!hasSurrogate) &#123;</span><br><span class="line">            hasSurrogate = (temp &gt;= Character.MIN_SURROGATE &amp;&amp; temp &lt;= Character.MAX_SURROGATE)</span><br><span class="line">                || (temp2 &gt;= Character.MIN_SURROGATE &amp;&amp; temp2 &lt;= Character.MAX_SURROGATE);</span><br><span class="line">        &#125;</span><br><span class="line">        value[j] = temp2;</span><br><span class="line">        value[n - j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasSurrogate) &#123;</span><br><span class="line">        <span class="comment">// Reverse back all valid surrogate pairs</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c2 = value[i];</span><br><span class="line">            <span class="keyword">if</span> (Character.isLowSurrogate(c2)) &#123;</span><br><span class="line">                <span class="keyword">char</span> c1 = value[i + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (Character.isHighSurrogate(c1)) &#123;</span><br><span class="line">                    value[i++] = c1;</span><br><span class="line">                    value[i] = c2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个方法是StringBuilder和StringBuffer类中独有的方法，用来逆序反转一个字符串序列。例如，对字符串”abcde”调用方法reverse()后的结果似”edcba”。方法执行的核心逻辑在类AbstractStringBuilder的同名方法reverse()中，在代码行9 - 18中，作者循环遍历原始字符串的一半内容（左一半），完成该位置和原始字符串右一半中对应位置的字符值交换。因为原始字符串中可能包含由代理对构成的字符，所以在循环遍历的过程记录是否需要做代理对的转换，即hasSurrogate。在Unicode中表示中，一个代理对由两个字节构成，高位代理(Surrogate High)和低位代理(Surrogate Low)，且高位代理在高位字节，低位代理在低位字节，所以在行9 - 18循环遍历完之后就变成了低位代理在左，高位代理在右。因此如果hasSurrogate为true，那么在行19 - 31中再次循环交换后的字符串，调整高位代理和低位代理的左右顺序以保证字符串内容的一致。</p>
<p>&emsp;&emsp;StringBuffer中该方法的执行逻辑和StringBuilder一致，唯一的区别是在方法声明中加入了关键字synchronized以保证多线程环境中数据的访问控制。具体方法声明如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">reverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.reverse();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="public-StringBuilder-delete-int-start-int-end"><a href="#public-StringBuilder-delete-int-start-int-end" class="headerlink" title="public StringBuilder delete(int start, int end)"></a>public StringBuilder delete(int start, int end)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.delete(start, end);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(start);</span><br><span class="line">    <span class="keyword">if</span> (end &gt; count)</span><br><span class="line">        end = count;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException();</span><br><span class="line">    <span class="keyword">int</span> len = end - start;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.arraycopy(value, start+len, value, start, count-end);</span><br><span class="line">        count -= len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;删除原始字符串中从start位置开始，end位置（不包含第end位置）结束的子字符串内容，并维护最终的字符串长度值。StringBuffer中操作逻辑同StringBuilder相同，不予赘述。方法声明如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.delete(start, end);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="public-StringBuilder-insert-int-offset-String-str"><a href="#public-StringBuilder-insert-int-offset-String-str" class="headerlink" title="public StringBuilder insert(int offset, String str)"></a>public StringBuilder insert(int offset, String str)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.insert(offset, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((offset &lt; <span class="number">0</span>) || (offset &gt; length()))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset);</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line">        str = <span class="string">"null"</span>;</span><br><span class="line">    <span class="keyword">int</span> len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    System.arraycopy(value, offset, value, offset + len, count - offset);</span><br><span class="line">    str.getChars(value, offset);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在原始字符串的指定位置中插入入参字符串。首先做容量判断，如果当前空余容量不足以容纳全部的入参字符串的话就需要进行扩容操作。然后将入参字符串加入到原始字符串中，并维护更新原始字符串的长度值。StringBuffer中操作逻辑同StringBuilder相同，不予赘述。方法声明如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.insert(offset, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="public-synchronized-void-trimToSize"><a href="#public-synchronized-void-trimToSize" class="headerlink" title="public synchronized void trimToSize()"></a>public synchronized void trimToSize()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.trimToSize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; value.length) &#123;</span><br><span class="line">        value = Arrays.copyOf(value, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在StringBuffer类的设计中，有的时候存在StringBuffer的初始化的value长度会大于实际存储的字符数，也就是说value字段中会有空余空间。这种情况下为了节约存储空间会考虑将value字段的空余空间移除。</p>
<h3 id="public-synchronized-String-substring-int-start"><a href="#public-synchronized-String-substring-int-start" class="headerlink" title="public synchronized String substring(int start)"></a>public synchronized String substring(int start)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> substring(start, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.substring(start, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最终调用：AbstractStringBuilder.substring(int start, int end)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(start);</span><br><span class="line">    <span class="keyword">if</span> (end &gt; count)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(end);</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(end - start);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(value, start, end - start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;StringBuffer中提供了一个substring()方法供开发人员调用，旨在提供一种途径获取当前字符串中的一部分字符串内容并返回。两个方法都加入了关键字synchronized，表明上述方法是多线程安全的。</p>
<h2 id="StringBuffer序列化-反序列化"><a href="#StringBuffer序列化-反序列化" class="headerlink" title="StringBuffer序列化/反序列化"></a>StringBuffer序列化/反序列化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Serializable fields for StringBuffer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serialField</span> value  char[]</span></span><br><span class="line"><span class="comment"> *              The backing character array of this StringBuffer.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serialField</span> count int</span></span><br><span class="line"><span class="comment"> *              The number of characters in this StringBuffer.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serialField</span> shared  boolean</span></span><br><span class="line"><span class="comment"> *              A flag indicating whether the backing array is shared.</span></span><br><span class="line"><span class="comment"> *              The value is ignored upon deserialization.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.io.ObjectStreamField[] serialPersistentFields =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">new</span> java.io.ObjectStreamField(<span class="string">"value"</span>, <span class="keyword">char</span>[].class),</span><br><span class="line">    <span class="keyword">new</span> java.io.ObjectStreamField(<span class="string">"count"</span>, Integer.TYPE),</span><br><span class="line">    <span class="keyword">new</span> java.io.ObjectStreamField(<span class="string">"shared"</span>, Boolean.TYPE),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">    java.io.ObjectOutputStream.PutField fields = s.putFields();</span><br><span class="line">    fields.put(<span class="string">"value"</span>, value);</span><br><span class="line">    fields.put(<span class="string">"count"</span>, count);</span><br><span class="line">    fields.put(<span class="string">"shared"</span>, <span class="keyword">false</span>);</span><br><span class="line">    s.writeFields();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    java.io.ObjectInputStream.GetField fields = s.readFields();</span><br><span class="line">    value = (<span class="keyword">char</span>[])fields.get(<span class="string">"value"</span>, <span class="keyword">null</span>);</span><br><span class="line">    count = fields.get(<span class="string">"count"</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="StringBuilder序列化-反序列化"><a href="#StringBuilder序列化-反序列化" class="headerlink" title="StringBuilder序列化/反序列化"></a>StringBuilder序列化/反序列化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line">    s.writeInt(count);</span><br><span class="line">    s.writeObject(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    count = s.readInt();</span><br><span class="line">    value = (<span class="keyword">char</span>[]) s.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关于String-StringBuilder-Buffer的区别"><a href="#关于String-StringBuilder-Buffer的区别" class="headerlink" title="关于String/StringBuilder/Buffer的区别"></a>关于String/StringBuilder/Buffer的区别</h2><p>&emsp;&emsp;首先，String是不可变的，String对象一旦创建，其内容便不会被二次修改。尽管String类提供了多种API来修改字符串内容，但是最终的执行结果是保留了当前字符串内容的同时又创建了一个对象，该对象包含的是修改后的内容值。而StringBuilder和StringBuffer可以对当前字符串自身做增删改操作，最终返回的也是当前字符串自身。</p>
<p>&emsp;&emsp;其次，就执行效率来说，StringBuilder &gt; StringBuffer &gt; String，所以如果在不需要考虑线程安全的情况下，StringBuilder是最快速的字符串处理方案。如果是在多线程的场景下，则可以通过使用StringBuffer来保证线程安全。而由于String具有不可变性，所以在用String对象参与hash表计算时，String的不可变性可以保证hash的key值唯一不变。</p>
<p>&emsp;&emsp;关于三者的使用，还是要分情况具体场景具体分析，不能一味地采用StringBuilder以追求高效率，也可以在一些不需要考虑多线程的场景中用StringBuilder来取代StringBuffer来提高效率。如果字符串处理较少而且比较稳定的话，可以考虑用String来实现。</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li>synchronized关键字的相关知识背景</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>NIL<br>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s network之五：Kubernetes集群Pod和Service之间通信的实现原理</title>
    <url>/2021/K8s-Network-Architecture-section-five.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;Kubernetes集群内Pod之间默认可以无障碍的进行通信，但是通常情况下Pod是不稳定的，无法确定Pod会在何时因为何种原因被重启。当Pod重启后，其会得到一个新的IP地址。而且，如无特别指明，Pod有可能会在不同的节点之间被调度。当提供相同服务的Pod有多个时，就需要一个统一的对外地址来接收服务请求，并将请求以负载均衡的方式分发到Pod上。Kubernetes Service就是在这种背景下被引入的，Service是一种为一组提供相同服务的Pod提供单一不变的、简单透明的接入访问点的资源对象。Service的IP地址和端口在其整个生命周期不会改变，客户端可以通过服务IP:服务Port的方式发起服务请求，也可以直接访问服务名，由Kubernetes集群提供的DNS解析服务将请求分发到Service背后的Pod上。出于篇幅考虑，相关的yaml配置不会在文章中出现，特殊情况除外，相关的yaml配置可以参考<a href="https://kubernetes.io/" target="_blank" rel="noopener">Kubernetes</a>官方文档。</p>
<a id="more"></a>
<p>&emsp;&emsp;<a href>1. K8s network之一：K8s网络模型与网络策略</a></p>
<p>&emsp;&emsp;<a href>2. K8s network之二：Kubernetes的域名解析、服务发现和外部访问</a> </p>
<p>&emsp;&emsp;<a href="/404.html">3.Linux网络在Kubernetes集群中的应用</a> </p>
<p>&emsp;&emsp;<a href>4.K8s network之四：Kubernetes集群通信的实现原理</a> </p>
<h2 id="Pod和Service之间的通信过程"><a href="#Pod和Service之间的通信过程" class="headerlink" title="Pod和Service之间的通信过程"></a>Pod和Service之间的通信过程</h2><p>&emsp;&emsp;前面我们大概了解了Kubernetes集群中同一Pod内各个容器之间以及Pod之间相互通信的过程，Pod之间可以直接通过IP地址在无需NAT的前提下完成通信过程，至于如何得知对方IP，可以采用某种方式将IP固定下来，或者写入配置项等等手段。但是Pod的生存周期通常来说是短暂的，有可能会因为各种原因被重启，而Pod的设计原理又使得当Pod在重启前后会得到不一致的IP地址，而且，在Pod启动前会通过CNI插件完成Pod的IP地址分配和配置工作，所以调用方也不可能在Pod启动前提前知道Pod的IP地址信息。就调用方而言，它其实并不关心提供服务的Pod有多少个，分布在哪里，IP地址信息是什么等，它只关心自己能通过何种方式访问Pod提供的服务。Service就是在这种背景下产生的，它把一系列提供相同服务的Pod聚合在一起，形成一个抽象的网络服务。Service一方面会根据一定的规则汇总提供服务的Pod信息集合，另一方面又向调用方提供了一个简单且统一的方式供其访问Pod提供的服务。</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1624950799/BlogImages/CloudSerials/K8sNetArchP4/K8s-Service-Demo.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 1 Kubernetes Service示例<sup id="fnref:1" style="font-size:80%;line-height:80%;"><a href="#fn:1" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[1]</span></a></sup></div>
&emsp;
</div>

<p>&emsp;&emsp;前面提到，Service是一种抽象的逻辑资源，实际上并没有对应的物理实体存在。每个Service都有一个全局唯一的IP地址，称为<strong>Cluster IP</strong>。同样，这个IP地址也是一个逻辑地址，实际上并不存在，尝试通过Ping程序向Cluster IP发送ICMP报文也会一直失败。每个Service都关联了数量不定的endpoints集合，每个endpoint代表了提供Service所声明的服务的一个Pod实例。在实际的Kubernetes集群中，每个节点上都有一个kube-proxy进程，kube-proxy会监听发送到Service上的请求，并根据endpoints列表集合采用指定的负载均衡算法对请求执行了DNAT（Destination Network Address Translation，请求到达Service之前目的地址是Service的Cluster IP和端口，DNAT之后目的地址是Pod的IP和端口）操作之后将请求转发到某个选中的Pod上，由Pod完成对请求的处理和响应。由于请求在转发过程中参与了DNAT的过程，DNAT前后地址信息的变化会被保存在Linux的连接追踪表（connection tracking table，即conntrack）中，当监听到请求的响应报文时，会根据conntrack中的记录执行DNAT的逆操作，也就是响应报文的源地址会从Pod的IP和端口号恢复为Service的Cluster IP和端口，这样请求发起的客户端就会认为自己是和Service直接通信的，实际转发过程对客户端而言是透明的。</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1624958971/BlogImages/CloudSerials/K8sNetArchP4/K8s-Service-Arch.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 2 Kubernetes Service实现构成(非用户空间模式下）</div>
&emsp;
</div>

<p>&emsp;&emsp;江湖上有一种说法：“Service会来监听Pod的变化，然后来更新Pod的IP地址“。这种说法严格来说并不是特别准确，实际上Service只是承担了服务声明的一个角色，对外发出公告：如果诸位想使用服务A，那么只需要找我就好了，我的Cluster IP是X.X.X.X。Service和实际提供Service声明的服务的Pod之间的映射关系是由endpoints对象来维护的。Endpoints控制器会从master节点上的kube-apiserver进程监控Pod的变更情况，之后会同步更新对应Service的endpoints列表。我们知道，Service和其对应的endpoints对象是同名的，所以控制器不仅仅关注于Pod的变更，还会关注Service的变更情况并同步更新endpoint：</p>
<ol>
<li>如果发现对应的Service被删，那么被删Service对应的endpoints对象同样会被删除</li>
<li>如果Service被创建或者修改，那么基于该Service对应的Pod集合创建或更新Service对应的endpoints对象</li>
</ol>
<p>&emsp;&emsp;当Service和Pod之间的映射关系建立后，kube-proxy就开始在集群中发挥其作用：kube-proxy会从kube-apiserver监控Service和endpoints资源的变化情况，并将Service和Endpoints的变化同步到节点的iptables表中，当一个到达节点的请求的目的地址命中了iptables表中某个Service对应的Cluster IP和端口时，内核会通过一系列iptables规则以指定的负载均衡算法从后端Pod中选择一个，通过DNAT技术修改请求的目的地址为命中Pod的IP地址和端口后将请求发送到选中的Pod上。kube-proxy提供了三种模型供用户进行选择来完成Service到后端Pod的转发工作—用户代理、iptables代理和ipvs代理。</p>
<h3 id="用户代理模型-User-space-proxy-mode"><a href="#用户代理模型-User-space-proxy-mode" class="headerlink" title="用户代理模型(User space proxy mode)"></a>用户代理模型(User space proxy mode)</h3><p>&emsp;&emsp;用户代理模型的历史非常短，在Kubernetes的v1.2版本中就被iptables模型取代成为新的默认选项。在用户代理模型中，kube-proxy真正意义上承担了代理的角色，由kube-proxy负责将请求流量转发给Service后端的Pod上。当kube-proxy在工作节点上启动后，就会监听kube-apiserver上Service和endpoints资源的变化情况，之后会针对每个service（每个协议、Service IP、Service端口）在节点上随机创建一个监听端口（这个端口实质上是一个Socket套接字），并在iptables中配置规则，这些规则会将目的地址是Service的IP:端口的请求转发给运行在用户空间的kube-proxy进程，kube-proxy接着会决定将请求转发给哪个Pod。当响应到达时，依旧是先通过kube-proxy，然后再转发给请求方。</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1625386322/BlogImages/CloudSerials/K8sNetArchP4/K8s-Services-Userspace-overview.svg" style="margin: 0 auto;">
</div>
<div align="center">
  <div align="center"><br>图 - 3 Kubernetes 用户代理模式下Service实现架构<sup id="fnref:3" style="font-size:80%;line-height:80%;"><a href="#fn:3" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[3]</span></a></sup></div>
&emsp;
</div>

<p>&emsp;&emsp;由于一次请求需要在用户空间和内核空间来回转移，造成用户空间模型的整体效率并不高。于是Kubernetes在v1.2版本中用性能更好的iptables来实现Service的功能。</p>
<h3 id="iptables代理模型"><a href="#iptables代理模型" class="headerlink" title="iptables代理模型"></a>iptables代理模型</h3><p>&emsp;&emsp;iptables从Kubernetes v1.2版本开始称为kube-proxy的默认模式，直到在v1.12版本中被IPVS取代而成为新的kube-proxy默认工作模式。在该模式中，kube-proxy修改了iptables中的filter和nat表，同时又对iptables的链进行了扩充，自定义了KUBE-SERVICES，KUBE-SVC-&lt;HASH&gt;，KUBE-SEP-&lt;HASH&gt;，KUBE-NODEPORTS，KUBE-FW-&lt;HASH&gt;，KUBE-XLB-&lt;HASH&gt;，KUBE-POSTROUTING，KUBE-MARK-MASQ和KUBE-MARK-DROP九个链条，通过在KUBE-SERVICES链中加入每个Service的ClusterIP和端口的匹配规则来完成流量的匹配和重定向工作。Kubernetes自定义的链条与iptables原生链条的调用关系如图4所示：</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1625123522/BlogImages/CloudSerials/K8sNetArchP4/Relationship-between-Kube-customed-chains-and-iptables-demo.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 4 Kubernetes 自定义链与与iptables调用链的关系</div>
&emsp;
</div>

<p>&emsp;&emsp;与用户空间代理模型不同的是，iptables代理模型中kube-proxy仅负责监听Service、endpoints等资源的变化，并将这种变化同步到iptables中的规则表中，不再参与请求的转发和负载均衡工作。这些工作均由iptables来完成，所以请求会一直在内核空间中传递，不必再被转入用户空间的kube-proxy进程中。</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1625388343/BlogImages/CloudSerials/K8sNetArchP4/K8s-Services-iptables-overview.svg" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center"><br>图 - 5 Kubernetes iptables代理模型下Service实现架构<sup id="fnref:4" style="font-size:80%;line-height:80%;"><a href="#fn:4" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[4]</span></a></sup></div>
&emsp;
</div>

<p>&emsp;&emsp;我们知道，Kubernetes的Service最普遍的应用是以Cluster IP的形式实现在Kubernetes集群内的服务调用，除此之外，Service还可以以NodePort、LoadBalancer、external IP形式将服务暴露到集群外部供外部实体访问和调用服务。这几种方式在iptables中的实现过程会稍有不同，接下来会对其进行简要分析。Kubernetes会按照Cluster IP、externalIP、 LoadBalancer和NodePort的顺序对外暴露服务，所以我们也会按照这个顺序进行学习。</p>
<h4 id="Cluster-IP"><a href="#Cluster-IP" class="headerlink" title="Cluster IP"></a>Cluster IP</h4><p>&emsp;&emsp;当集群内Pod访问Service的Cluster IP时，报文会通过iptables的OUTPUT链进入Kubernetes的自定义链。假设当前集群中有一个Service A，同时有三个后端Pod用来提供服务Service A，kube-proxy采用随机负载均衡算法来选择Pod，针对Cluster IP的处理流程如下图所示：</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1625119969/BlogImages/CloudSerials/K8sNetArchP4/K8-svc-iptables-clusterIP-mode-flow.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center"><br>图 - 6 Service在Cluster IP模式下报文处理过程
 </div>
&emsp;
</div>

<p><strong>【Note】：</strong>某些链条的名字中含有&lt;HASH&gt;字样，这是运用SHA256算法对“namespace + name + portname+协议名”生成哈希值，然后通过base32对该哈希值编码，最后取编码值的前16位的值<sup id="fnref:2" style="font-size:80%;line-height:80%;"><a href="#fn:2" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[2]</span></a></sup>。</p>
<ol>
<li><p>报文会首先进入<strong>KUBE-SERVICES</strong>链条。KUBE-SERVICE针对每个Service会产生两条匹配规则，规则（1）表示如果报文的源地址不是集群内IP地址，同时，报文匹配了请求Service的协议和端口，那么就跳转到（-j）<strong>KUBE-MARK-MASQ</strong>链条，在报文中加入一个特殊的防火墙标识，打上这个标识的报文会在POSTROUTING阶段执行SNAT(Source Network Address Translation)。如果确实命中了规则（1），那么在打完标记后会继续检查规则（2），规则（2）会将报文带入下一个链条—KUBE-SVC-&lt;HASH&gt;。</p>
</li>
<li><p><strong>KUBE-SVC-&lt;HASH&gt;</strong>包含了当前提供Service的后端Pod、负载均衡模式等消息。kube-proxy默认采用的随机负载算法，因此在这种算法下会为每个Pod分配一个命中概率。在图-6中，三个Pod被命中的概率都是三分之一。当选中一个Pod后，就会跳转到和Pod相对应的KUBE-SEP-&lt;HASH&gt;上。</p>
</li>
<li><p>每个<strong>KUBE-SEP-&lt;HASH&gt;</strong>和一个Pod相对应，且每个KUBE-SEP-&lt;HASH&gt;均有两条规则。规则（2）表示对请求做DNAT，将请求的目的地址由原来的ClusterIP：Port转换成Pod_IP：Port。这样就将Pod访问Service变成了Pod和Pod之间的访问。规则（1）的目的是为了应对<strong>Hairpinning 发夹问题</strong>而设计的：Service A的后端Pod中有可能会有某个Pod访问Service A，然后经过iptables时又恰好选中了自己作为服务的提供方。换句话说，Pod要为自己发出去的服务请求做出响应。在Kubernetes中这样会造成访问失败，如果当出现这种场景时就跳转到KUBE-MARK-MASQ链条执行SNAT，将请求的源地址由Pod自身变成节点的node IP，这样就又变成了正常的服务请求和响应模式。如图7所示，左边是没有做SNAT的场景，Pod A收到了一个自己发出的服务请求，请求的源和目的地址都是自己，当发送响应给自己时会导致失败。右边是借助SNAT解决Hairpinning问题的场景，Pod A访问自己所属服务的请求到达Linux内核时会通过SNAT将源地址由Pod A的IP变成节点的Node IP。当Pod A发送响应报文时，报文先发送给Node IP，然后在Linux内核中再次进行NAT，将源IP由Pod A的IP改成Service的IP，目的IP由Node节点的IP改为Pod A的IP，这样就可以正常工作了。</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1626874546/BlogImages/CloudSerials/K8sNetArchP4/K8s-iptables-Hairpinning-demo.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center"><br>图 - 7 Hairpinning问题及其解决方法
 </div>
&emsp;
</div>
</li>
<li><p>执行完DNAT后，会跳转到<strong>POSTROUTING</strong>链条。POSTROUTING会无条件跳转到<strong>KUBE-POSTROUTING</strong>链条，这个链条会检查报文是否有跳转到KUBE-MARK-MASQ链条被打上防火墙标识，如果有的话就会执行SNAT，将报文的源地址变为节点的node IP。</p>
</li>
<li><p>最后由POSTROUTING将报文发出协议栈。</p>
</li>
</ol>
<h4 id="external-IP"><a href="#external-IP" class="headerlink" title="external IP"></a>external IP</h4><p>&emsp;&emsp;当Service可以通过external IP暴露在集群外部供外部实体调用时，报文会通过PREROUTING进入Kubernetes的自定义链条。假设当前集群中有一个Service A，同时有三个后端Pod用来提供服务Service A，kube-proxy采用随机负载均衡算法来选择Pod，针对external IP的处理流程如下图所示：</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1625129239/BlogImages/CloudSerials/K8sNetArchP4/K8-svc-iptables-externalIP-mode-flow.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center"><br>图 - 8 Service在external IP模式下报文处理过程
 </div>
&emsp;
</div>


<ol>
<li><p>报文依旧会首先进入KUBE-SERVICE，每个external IP记录会在KUBE-SERVICE中产生三条记录。报文首先会命中规则（3），也就是说如果报文的目的地址是external IP，协议和端口也都命中了，那么就跳转到KUBE-MARK-MASQ打标签，最后会做SNAT。紧接着会检查匹配规则（4），如果当前报文的目的地址是Service的external IP，端口和协议都匹配了，且报文不是bridge接口进来的，且源地址不在本机上，那么就跳转到KUBE-SVC-&lt;HASH&gt;上。最后检查匹配规则规则（5），如果当前报文的目的地址是Service的external IP，端口和协议也匹配了，且目的地址是在本机上，那么就跳转到KUBE-SVC-&lt;HASH&gt;上。</p>
<p>规则（4）需要报文不是从bridge接口进来的，说明报文肯定不是来自本机上的Pod，源地址不在本机地址范围，说明报文来自集群外。因为Kubernetes集群内的每个节点上都会有由集群中所有Service的信息构建的iptables规则，所以如果是Pod发出的流量的源地址一定是LOCAL类型的。（5）中，因为external IP关联了本机网卡上的一个接口，因此也算作本机的LOCAL地址，所以匹配了external IP也就匹配了—dst-type LOCAL。这两条规则相互补充，就限制了流量只能来自外部，且只能从external IP接口流入Kubernetes集群。所以这两条规则都会跳转到KUBE-SVC-&lt;HASH&gt;规则中。</p>
</li>
<li><p>后面的过程就和Cluster IP模式下的工作流程类似了，故这里不再予以赘述。</p>
</li>
</ol>
<h4 id="LoadBalancer"><a href="#LoadBalancer" class="headerlink" title="LoadBalancer"></a>LoadBalancer</h4><p>&emsp;&emsp;Service可以接入外部的负载均衡器来实现节点级别的负载均衡功能。在Service的配置中有一个<strong>externalTrafficPolicy</strong>参数，这个参数有两个值可供选择：Local和Cluster。如果参数设置为Local，那么当流量被外部负载均衡器命中到某个节点上时，流量将只会在该命中节点上被处理，不会通过该节点转发到集群内的其他节点上。如果该节点上没有提供服务的Pod，那么当前请求会被丢弃。如果参数设置为Cluster，那么当流量被外部负载均衡器命中到某个节点上时，该请求可能只是路过该节点，最终会被转发到其他节点上处理。这个参数默认为Cluster。iptables规则处理这两个参数选项的处理过程会稍有不同。</p>
<p>&emsp;&emsp;针对LoadBalancer类型的Service，KUBE-SERVICE中会生成一条用于命中这种类型的规则，这条规则会将流量转发给规则KUBE-FW-&lt;HASH&gt;。KUBE-FW-&lt;HASH&gt;会根据<strong>externalTrafficPolicy</strong>将流量传递给KUBE-SVC-&lt;HASH&gt;或者KUBE-XLB-&lt;HASH&gt;或者KUBE-MARK-DROP。</p>
<p>&emsp;&emsp;当externalTrafficPolicy=cluster时，流量匹配过程如图9所示：</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1625378109/BlogImages/CloudSerials/K8sNetArchP4/K8s-Service-LB-Cluster-Chain-Flow.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center"><br>图 - 9 Service在LoadBalancer模式下(Cluster)报文处理过程
 </div>
&emsp;
</div>

<ol>
<li>如果流量的目的地址为负载均衡的IP地址，协议、端口也都命中，那么就跳转到KUBE-FW-&lt;HASH&gt;。</li>
<li>当流量进入KUBE-FW-&lt;HASH&gt;后，会首先跳到KUBE-MARK-MASQ打上特殊标记用来做SNAT。之后会跳转到KUBE-SVC-&lt;HASH&gt;按照Cluster IP类型的服务进行处理。如果当前无对应的KUBE-SVC-&lt;HASH&gt;，那么就跳转到KUBE-MARK-DROP废弃该报文。</li>
<li>当流量进入到KUBE-SVC-&lt;HASH&gt;后，按照Cluster IP的过程完成流量转发过程。</li>
</ol>
<p>&emsp;&emsp;当externalTrafficPolicy=Local时，会通过KUBE-XLB-&lt;HASH&gt;将流量转发到Pod上。此时KUBE-XLB-&lt;HASH&gt;中只会有当前节点上部署的提供特定Service的Pod规则信息，如果当前节点没有满足条件的Pod，会生成KUBE-MARK-DROP规则将流量丢弃。流量匹配过程如图所示：</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1625378109/BlogImages/CloudSerials/K8sNetArchP4/K8s-Service-LB-Local-Chain-Flow.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center"><br>图 - 10 Service在LoadBalancer模式下(Local)报文处理过程
 </div>
&emsp;
</div>

<ol>
<li>第一步同样是由KUBE-SERVICE中匹配LoadBalancer的规则将流量转入到KUBE-FW-&lt;HASH&gt;。这里的KUBE-FW-&lt;HASH&gt;和externalTrafficPolicy=Cluster下的KUBE-FW-&lt;HASH&gt;有一些不同之处：这里的KUBE-FW-&lt;HASH&gt;只有两条规则，第一条规则会将流量转到KUBE-XLB-&lt;HASH&gt;，当找不到KUBE-XLB-&lt;HASH&gt;时就将流量转入KUBE-MARK-DROP丢弃。</li>
<li>当流量被转入到KUBE-XLB-&lt;HASH&gt;后，首先尝试匹配规则（1）。如果流量的源地址是集群内地址，那么按照Cluster IP模式进行处理，会将流量直接转入到KUBE-SVC-&lt;HASH&gt;处理。如果流量当前所在节点没有部署任何和该负载均衡服务相关的Pod，那么就通过规则（2-1）丢弃该流量。否则，根据规则（2-2）选中一个Pod，将流量转发到Pod完成服务请求和响应。需要注意的是，规则（2-1）和（2-2）在同一个服务中是互斥的，二者不会同时存在。</li>
</ol>
<h4 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a>NodePort</h4><p>&emsp;&emsp;Service的NodePort是KUBE-SERVICE中最后尝试被匹配的规则。换句话说，匹配NodePort的规则被放在了KUBE-SERVICE规则表中的最后位置。同样，针对<strong>externalTrafficPolicy</strong>参数的不同设置，NodePort模式下iptables的处理过程也稍有差异。</p>
<p>&emsp;&emsp;当externalTrafficPolicy=Cluster时，流量匹配过程如图11所示：</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1625378109/BlogImages/CloudSerials/K8sNetArchP4/K8s-Service-NodePort-Cluster-Chain-Flow.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center"><br>图 - 11 Service在NodePort模式下(Cluster)报文处理过程
 </div>
&emsp;
</div>

<ol>
<li>如果流量是通过NodePort流入集群，且目的地址是当前节点上地址范围内的地址，那么就命中了KUBE-SERVICE的规则（7），流量被转入到KUBE-NODEPORTS。</li>
<li>当流量进入KUBE-NODEPORTS中后，首先跳转到KUBE-MARK-MASQ，为该报文打上执行SNAT的标记。之后会将流量转入到KUBE-SVC-&lt;HASH&gt;。</li>
<li>之后就按照Cluster IP模式进行流量转发、处理和响应。</li>
</ol>
<p>&emsp;&emsp;当externalTrafficPolicy=Local时，，会通过KUBE-XLB-&lt;HASH&gt;将流量转发到Pod上。此时KUBE-XLB-&lt;HASH&gt;中只会有当前节点上部署的提供特定Service的Pod规则信息，如果当前节点没有满足条件的Pod，会生成KUBE-MARK-DROP规则将流量丢弃。流量匹配过程如图12所示：</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1625378109/BlogImages/CloudSerials/K8sNetArchP4/K8s-Service-NodePort-Local-Chain-Flow.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center"><br>图 - 12 Service在NodePort模式下(Local)报文处理过程
 </div>
&emsp;
</div>

<ol>
<li><p>流量同样由KUBE-SERVICE中规则（7）被转入到KUBE-NODEPORTS。</p>
</li>
<li><p>KUBE-NODEPORTS中规则（2）会将流量转入KUBE-XLB-&lt;HASH&gt;，最终会被转发到本节点上的某个Pod。规则（1）用来解决localhost martian source(martian packet)问题。</p>
<p>martian packet指的是那些因为源或目的IP地址归属于由IANA(<a href="https://en.wikipedia.org/wiki/Internet_Assigned_Numbers_Authority" target="_blank" rel="noopener">Internet Assigned Numbers Authority</a>)所规定的保留用作特殊用途的IP地址集合而无法被路由器转发处理，或者被发送到了和源/目的IP地址不属于同一个网段的报文。在Linux内核环境下，martian packet指的是那些在某个特定网络接口上被内核接收但实际上应该被另一个网络接口所接收的报文。martian packet意为来自火星的报文，也就是不属于“地球”的报文。martian packet产生的原因很多，常见的可能原因如下：</p>
<ul>
<li>用于拒绝服务攻击（DoS）的IP地址欺骗</li>
<li>网络设备故障或者域名的错误配置</li>
</ul>
<p>规则（1）对martian packet尝试做一次SNAT，使得martian packet可以再次可以被Linux内核路由到正确的目的地址上。</p>
</li>
</ol>
<p>&emsp;&emsp;在iptables模型中，Service的服务发现和负载均衡全都在内核中的iptables完成，因此消除了流量在用户空间和内核空间来回复制切换所带来的的性能损耗，相较于用户代理模式会更加高效。但是iptables依然存在不足：</p>
<ul>
<li><p>iptables规则错综复杂，对于问题排障而言会有较大成本</p>
</li>
<li><p>iptables随着规则的扩增会导致性能迅速下降。iptables的实现是一种链表实现，其时间复杂度是O(n)，当Service和Service背后的Pod数量上涨时，iptables的处理耗时也会一同增加。这使得iptables成为集群大规模扩展的一个瓶颈，尽管在Kubernetes的v1.6版后集群已经可以支持5000节点的网络了。假设在一个5000节点的集群中有2000个Service，每个Service平均由10Pod提供对应的服务，那么每个节点上的iptables会有20000条规则，这就已经使得内核的压力非常大了<sup id="fnref:5" style="font-size:80%;line-height:80%;"><a href="#fn:5" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[5]</span></a></sup>。</p>
</li>
<li><p>iptables的设计初衷是用来为主机防火墙服务的。尽管其可以实现负载均衡的功能，但这并不是iptables的长处。事实上，iptables能提供的负载均衡策略十分有限。</p>
</li>
<li><p>iptables模式中，如果选中了Service背后的某个特定Pod，而这个Pod恰好无法正常的处理请求。那么当前整个请求会处于失败状态，iptables不会尝试重新将该请求转发到其他正常Pod上。所以这是和用户空间代理模式相比之下的一个弱势。为了解决这个问题，需要用<strong>readiness</strong>探针对Pod进行监测，保证iptables中的规则中映射的都是正常工作的Pod。</p>
</li>
</ul>
<p>&emsp;&emsp;鉴于上述的一些原因，Kubernetes在v1.12开始用更优秀的ipvs来取代iptables实现Kubernetes的Service。</p>
<h3 id="IPVS-IP-virtual-server-代理模型"><a href="#IPVS-IP-virtual-server-代理模型" class="headerlink" title="IPVS(IP virtual server)代理模型"></a>IPVS(IP virtual server)代理模型</h3><p>&emsp;&emsp;IPVS自v1.8版本开始被引入Kubernetes，在v1.11版本中升级为GA版本，从Kubernetes v1.12开始取代iptables成为kube-proxy的默认工作模式。</p>
<p>&emsp;&emsp;IPVS在Linux内核实现了传输层的负载均衡功能，因此也被称为L4交换机。运行在宿主机上的IPVS就像一个运行在集群入口处的负载均衡器，它负责将通过TCP/UDP协议发出的服务请求定向到真实的服务器上，同时将真实服务器上的服务以虚拟服务的形式暴露在单个IP地址上（即负载均衡器的IP地址）。IPVS和iptables虽然都是基于netfilter实现的，但是二者的目的和专长并不一致：iptables致力于为防火墙提供服务而IPVS则专注于高性能的负载均衡实现。IPVS由于使用了更高效的数据结构—Hash表，为更大规模集群扩展提供了更好的支持，此外，IPVS还实现了比iptables更丰富、复杂的的负载均衡算法。IPVS提供了三种负载均衡模式—DR、IPIP和NAT。</p>
<h4 id="DR-Direct-Routing"><a href="#DR-Direct-Routing" class="headerlink" title="DR(Direct Routing)"></a>DR(Direct Routing)</h4><p>&emsp;&emsp;DR模式是IPVS应用最广泛的模式，它直接工作在L2层，在MAC地址上执行负载均衡决策。当服务端发送响应流量给请求方时，流量会直接由服务端发送给请求方而不再经过IPVS。</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1625465595/BlogImages/CloudSerials/K8sNetArchP4/IPVS-DR-Mode.svg" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 13 IPVS DR模式工作结构<sup id="fnref:6" style="font-size:80%;line-height:80%;"><a href="#fn:6" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[6]</span></a></sup></div>
&emsp;
</div>

<p>&emsp;&emsp;当流量到达IPVS时，IPVS只修改流量的MAC地址，将源MAC由IPVS前一跳设备的MAC修改为IPVS负载均衡设备的MAC，将目的MAC由负载均衡设备的MAC修改为后端Server的MAC。到达后端的流量的IP地址在从请求方到服务端的过程中不会发生变化（在不考虑NAT的场景下）。当后端server发送响应流量时，流量将直接从后端server发送请求方，而不再经过IPVS负载均衡器。由于DR模式下IP地址不会变化，因此IPVS负载均衡设备和后端server都需要配置Service的IP（也就是VIP, Virtual IP），但是只有负载均衡设备会向整个网络通告VIP，后端server不会对外声明自己拥有VIP，这样就避免了IP地址冲突的发生，所有请求VIP对应的服务的流量也都只会通过负载均衡设备转发给后端server。</p>
<p>&emsp;&emsp;这种模式下，负载均衡设备只负责入流量的转发和管控，而不管出流量。因此负担更轻，能更高效的专注于负载均衡功能。但是这种模式不支持端口映射功能，此外，这个模式需要负载均衡设备和后端server都在一个网段中。因此，这种模式并不适合Kubernetes中Service的应用要求。</p>
<h4 id="IPIP"><a href="#IPIP" class="headerlink" title="IPIP"></a>IPIP</h4><p>&emsp;&emsp;IPIP（也称tunnel或者tun）和DR模式有点类似，负载均衡设备都只负责入站流量的转发和管控，出站流量由后端server直接发送给请求方。但是进入负载均衡设备的流量并不是通过修改MAC地址的方式被转发到后端server的，而是通过IP隧道的方式来实现的。换句话说，用一个源IP和目的IP分别为负载均衡设备的IP和后端server的IP报文将请求方发出的IP报文转发给后端server，由后端server完成请求处理和响应。</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1625465594/BlogImages/CloudSerials/K8sNetArchP4/IPVS-IPIP-Mode.svg" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 14 IPVS IPIP模式工作结构<sup id="fnref:6" style="font-size:80%;line-height:80%;"><a href="#fn:6" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[6]</span></a></sup></div>
&emsp;
</div>

<p>&emsp;&emsp;这种模式支持良好的可扩展性，而且负载均衡设备和后端server也无需一定要处在一个网段中。但是这种模式同样有缺点，和DR模式一样，IPIP模式同样不支持端口映射。而且，IP报文的MTU是有限制的，也就是说实际的请求方发出的IP报文的MTU不能太大，否则会导致负载均衡设备和后端server之间的报文大小超出MTU限制而产生问题。当然，你可以调节MTU的大小，但是这需要你拥有负载均衡设备和后端server所在网络的控制能力才能完成MUT的调节。所以，这个模式也无法胜任Kubernetes中Service的要求。</p>
<h4 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h4><p>&emsp;&emsp;NAT模式是IPVS中最简单的模式。负载均衡设备会监听到达设备上的请求，当有流量到达负载均衡设备时，会将目的IP由负载均衡设备的IP改为后端server的IP，并将流量转发给后端server上。当请求响应由后端server发出后，响应报文同样需要被发送到负载均衡设备上，再由负载均衡设备执行源IP地址转换，将源IP地址由后端server的IP替换为负载均衡设备的IP，最后由负载均衡设备将流量转发给请求方。Kubernetes的Service正是使用NAT模式来实现其功能。</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1625465594/BlogImages/CloudSerials/K8sNetArchP4/IPVS-NAT-Mode.svg" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 15 IPVS NAT模式工作结构<sup id="fnref:6" style="font-size:80%;line-height:80%;"><a href="#fn:6" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[6]</span></a></sup></div>
&emsp;
</div>


<p>&emsp;&emsp;通过使用IPVS，kube-proxy对iptables的使用进行了进一步的优化：kube-proxy不再直接使用iptables生成规则链条，而是使用ipset来完成该功能。ipset引入了带索引的数据结构，当规则激增时，ipset可以以O(1)时间复杂度很高效地完成查找和匹配。换言之，可以将ipset简单理解为一个IP地址的集合，集合的内容可以是IP地址、IP网段、端口等，iptables可以对ipset进行操作，这样做可以大大减少iptables规则的数量以提高负载均衡的性能。IPVS维护的ipset集合如表1所示：</p>
<div style="text-align: left; width: 100%;">
    &emsp;&emsp;表 - 1：ipset种类
    <div style="text-align: left; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1625494176/BlogImages/CloudSerials/K8sNetArchP4/ipset-category-table.png" style="margin: 0 auto;">
</div></div>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1625388343/BlogImages/CloudSerials/K8sNetArchP4/K8s-Services-ipvs-overview.svg" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 16 Kubernetes ipvs代理模型下Service实现架构<sup id="fnref:7" style="font-size:80%;line-height:80%;"><a href="#fn:7" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[7]</span></a></sup></div>
&emsp;
</div>


<p>&emsp;&emsp;以Cluster IP类型的Service为例，我们会简单了解下IPVS是如何完成报文的负载均衡和转发工作的。当Cluster IP类型的Service被创建后，IPVS会做如下的三件事：</p>
<ol>
<li>确保节点上会存在一个dummy的网络接口，默认为kube-ipvs0</li>
<li>将Service的Cluster IP绑定到kube-ipvs0接口上</li>
<li>为每个Cluster IP地址分别创建一个IPVS虚拟服务器</li>
</ol>
<p>&emsp;&emsp;IPVS模式之所以要创建一个dummy的kube-ipvs0网络接口，是因为IPVS的hook是挂在INPUT链条上来处理DNAT的，因此需要通过PREROUTING而不是OUTPUT将流量导入到INPUT链条上，这样才能被IPVS接收并进行相应处理。假设当前集群中有服务nginx-service，且其Cluster IP和后端Pod地址信息如下所示：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># kubectl describe svc nginx-service</span><br><span class="line">Name:			nginx-service</span><br><span class="line">...</span><br><span class="line">Type:			ClusterIP</span><br><span class="line">IP:			    10.102.128.4</span><br><span class="line">Port:			http	3080/TCP</span><br><span class="line">Endpoints:		10.244.0.235:8080,10.244.1.237:8080</span><br><span class="line">Session Affinity:	None</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;当上述三件事都完成后，就会看到kube-ipvs0接口的信息如下所示：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># ip addr</span><br><span class="line">...</span><br><span class="line">73: kube-ipvs0: &lt;BROADCAST,NOARP&gt; mtu 1500 qdisc noop state DOWN qlen 1000</span><br><span class="line">    link/ether 1a:ce:f5:5f:c1:4d brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.102.128.4/32 scope global kube-ipvs0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line"># ipvsadm -ln</span><br><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn     </span><br><span class="line">TCP  10.102.128.4:3080 rr</span><br><span class="line">  -&gt; 10.244.0.235:8080            Masq    1      0          0         </span><br><span class="line">  -&gt; 10.244.1.237:8080            Masq    1      0          0</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;第3 ~ 6行表明有一个kube-ipvs0网络接口，这个接口的地址是10.102.128.4，也就是服务nginx-service的Cluster IP。第12 ~ 14行表明发送到10.102.128.4：3080的报文会以轮询方式（rr）被转发到nginx-service的两个地址为10.244.0.235：8080和10.244.1.237：8080的Pod上。</p>
<p>&emsp;&emsp;如果有多个服务，那么kube-ipvs0会响应的展示已有服务的所有Cluster IP信息。同样，端口转发部分也会显示Cluster IP和后端Pod之间的端口映射关系：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">$ ip addr show kube-ipvs0</span><br><span class="line">11: kube-ipvs0: &lt;BROADCAST,NOARP&gt; mtu 1500 qdisc noop state DOWN qlen 1000</span><br><span class="line">    link/ether 1a:ce:f5:5f:c1:4d brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.102.128.4/32 scope global kube-ipvs0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet Cluster_IP_2/32 scope global kube-ipvs0</span><br><span class="line">           valid_lft forever preferred_lft forever</span><br><span class="line">    inet Cluster_IP_N/32 scope global kube-ipvs0</span><br><span class="line">           valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line"># ipvsadm -ln</span><br><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn     </span><br><span class="line">TCP  10.102.128.4:3080 rr</span><br><span class="line">  -&gt; 10.244.0.235:8080            Masq    1      0          0         </span><br><span class="line">  -&gt; 10.244.1.237:8080            Masq    1      0          0  </span><br><span class="line">TCP  Cluster_IP_2:port rr</span><br><span class="line">  -&gt; Pod_21_IP:Pod_21_Port        Masq    1      0          0         </span><br><span class="line">  -&gt; Pod_22_IP:Pod_22_Port       	Masq    1      0          0  </span><br><span class="line">TCP  Cluster_IP_N:Port rr</span><br><span class="line">  -&gt; Pod_N1_IP:Pod_N1_Port        Masq    1      0          0         </span><br><span class="line">  -&gt; Pod_N2_IP:Pod_N1_Port        Masq    1      0          0</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;当所有的组件都就绪后，就可以接收报文了。报文到达集群进入节点后，会经过如下的流程：</p>
<ol>
<li><p>由于报文通过kube-ipvs0接口进入内核，所以报文会通过PREROUTING链条。PREROUTING中的规则格式如下所示：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">-A PREROUTING -m comment --comment "kubernetes service portals" -j KUBE-SERVICES</span><br></pre></td></tr></table></figure>
</li>
<li><p>紧接着，报文会进入到KUBE-SERVICE，在KUBE-SERVICE中会尝试匹配KUBE-CLUSTER-IP。KUBE-SERVICE中的规则格式如下所示：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">-A KUBE-SERVICES ! -s Cluster_CIDR -m comment --comment "Kubernetes service cluster ip + port for masquerade purpose" -m set --match-set KUBE-CLUSTER-IP dst,dst -j KUBE-MARK-MASQ</span><br><span class="line"></span><br><span class="line">-A KUBE-SERVICES -m set --match-set KUBE-CLUSTER-IP dst,dst -j ACCEPT</span><br></pre></td></tr></table></figure>
<p>如果流量的源地址不在集群内，且匹配了KUBE-CLUSTER-IP，那么就跳到KUBE-MARK-MASQ打上标签做SNAT。紧接着第二条规则会尝试匹配<strong>-m set —match-set KUBE-CLUSTER-IP dst,dst</strong>规则：尝试匹配ipset集合KUBE-CLUSTER-IP，第一个dst表示请求的目的地址是否能匹配上Cluster IP，第二个dst表示请求的目的Port作为是否能匹配上Kubernetes中Service的端口。如果匹配成功，那么流量会继续向后传递并处理。</p>
</li>
<li><p><strong>KUBE-CLUSTER-IP</strong>是个ipset，内容如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># ipset list | grep -A 20 KUBE-CLUSTER-IP</span><br><span class="line">Name: KUBE-CLUSTER-IP</span><br><span class="line">Type: hash:ip,port</span><br><span class="line">Revision: 5</span><br><span class="line">Header: family inet hashsize 1024 maxelem 65536</span><br><span class="line">Size in memory: 352</span><br><span class="line">References: 2</span><br><span class="line">Members:</span><br><span class="line">Service_1_Cluster_IP,Service_1_Protocol:Service_1_Port</span><br><span class="line">Service_2_Cluster_IP,Service_2_Protocol:Service_2_Port</span><br><span class="line">Service_3_Cluster_IP,Service_3_Protocol:Service_3_Port</span><br><span class="line">Service_N_Cluster_IP,Service_N_Protocol:Service_N_Port</span><br><span class="line">Service_X_Cluster_IP,Service_X_Protocol:Service_X_Port</span><br></pre></td></tr></table></figure>
<p>集合中最重要的部分就是Members了，这里列出了当前集群中Service的Cluster IP、访问协议和端口信息。</p>
</li>
<li><p>当流量进入INPUT后，流量的DNAT处理在INPUT链条中完成。执行DNAT所依赖的IPVS规则如下所示：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># ipvsadm -ln</span><br><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn     </span><br><span class="line">TCP  10.102.128.4:3080 rr</span><br><span class="line">  -&gt; 10.244.0.235:8080            Masq    1      0          0         </span><br><span class="line">  -&gt; 10.244.1.237:8080            Masq    1      0          0  </span><br><span class="line">TCP  Cluster_IP_2:port rr</span><br><span class="line">  -&gt; Pod_21_IP:Pod_21_Port        Masq    1      0          0         </span><br><span class="line">  -&gt; Pod_22_IP:Pod_22_Port       	Masq    1      0          0  </span><br><span class="line">TCP  Cluster_IP_N:Port rr</span><br><span class="line">  -&gt; Pod_N1_IP:Pod_N1_Port        Masq    1      0          0         </span><br><span class="line">  -&gt; Pod_N2_IP:Pod_N1_Port        Masq    1      0          0</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>   当DNAT完成后，流量会流入POSTROUTING。</p>
<ol>
<li><p>当流量进入POSTROUTING后，和iptables模式类似，流量无条件被传入到KUBE-POSTROUTING中。在KUBE-POSTROUTING中会根据流量是否带有特殊的0x4000/0x4000标记来决定是否需要对流量做SNAT。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">-A POSTROUTING -m comment --comment "kubernetes postrouting rules" -j KUBE-POSTROUTING</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">-A KUBE-POSTROUTING -m comment --comment "kubernetes service traffic requiring SNAT" -m mark --mark 0x4000/0x4000 -j MASQUERADE</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后将报文发出协议栈，完成后续的流量转发过程。整个的过程如图17所示：</p>
</li>
</ol>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1625582214/BlogImages/CloudSerials/K8sNetArchP4/IPVS_Mode_Service_Packet_Path.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center"><br>图 - 17 Kubernetes IPVS代理模型报文处理过程<sup id="fnref:8" style="font-size:80%;line-height:80%;"><a href="#fn:8" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[8]</span></a></sup></div>
&emsp;
</div>


<p>&emsp;&emsp;IPVS凭借更优秀的数据结构和整体设计，获得了比iptables更好的性能，使得集群可以更好的进行大规模扩展。在Calico的文章《<a href="https://www.tigera.io/blog/comparing-kube-proxy-modes-iptables-or-ipvs/" target="_blank" rel="noopener">Comparing kube-proxy modes: iptables or IPVS?</a>》中，作者从服务响应耗时和CPU消耗两个方面对iptables和IPVS两个模型进行了比较。从服务响应耗时角度看，当Service的数量不多时，两个模型的响应耗时差距并不大，这个差异只有当Service数量规模以数千计或万计时，IPVS的性能会远优于iptables。如果将keepalive纳入考虑范围，那么由keepalive支持的服务请求和响应由于节省了每次请求需要执行的TCP连接过程，所以性能也会优于没有keepalive支持的场景。由于测试中服务提供的是静态内容，而实际上服务的响应数据都是动态生成的，响应时间会随着数据规模、算法复杂度等因素有可能会比本测试中耗时更高，这样kube-proxy发挥作用的耗时在整体耗时中的占比会相应的下降。</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1625622293/BlogImages/CloudSerials/K8sNetArchP4/Round-Trip-Response-Time-vs-Number-of-Services.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 18 IPVS和iptables在不同规模Service下的响应耗时比较<sup id="fnref:9" style="font-size:80%;line-height:80%;"><a href="#fn:9" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[9]</span></a></sup></div>
&emsp;
</div>

<p>&emsp;&emsp;另一方面，作者在禁用keepalive的前提下测试了IPVS和iptables在不同规模Service场景下对CPU的需求情况。和响应耗时类似，只有当Service的规模以万计时，IPVS的性能优势才会更好的展现出来。而且，iptables使用CPU的增速远高于IPVS。这里有两个地方需要注意一下，首先，kube-proxy默认会以30秒的间隔刷新内核规则，所以你会看到IPVS的CPU占用也会有所增长即使IPVS的时间复杂度为O(1)。如果内核的版本比较老旧的话，对iptables的刷新速度会更慢。其次，测试是在禁用keepalive的前提下进行的，当Service的规模非常大时，内核需要遍历整个iptables来建立到后端Pod的连接，而iptables的时间复杂度为O(n)，所以iptables的CPU占用比IPVS更高。如果开启keepalive，那么iptables的CPU占用的下降速度会比IPVS更显著。</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1625622293/BlogImages/CloudSerials/K8sNetArchP4/CPU-vs-Number-of-Services.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 19 IPVS和iptables在不同规模Service下的CPU占用比较<sup id="fnref:9" style="font-size:80%;line-height:80%;"><a href="#fn:9" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[9]</span></a></sup></div>
&emsp;
</div>

<p>&emsp;&emsp;作者最后给出了一些提高性能的建议：如果集群规模非常大，那么IPVS会是更好的选择。此外，尽可能在新版本的Linux内核上运行Kubernetes集群和kube-proxy，如无特殊限制，保证keepalive处于开启状态。还有，相较于iptables只提供了轮询和会话亲和（SessionAffinity）两种负载均衡实现，IPVS则提供了非常丰富的选择：</p>
<ul>
<li>静态调度<ul>
<li><strong>轮询</strong>（RR, Round Robin）：按顺序轮流分配到实际服务器。</li>
<li><strong>加权轮询</strong>（WRR, Weighted Round Robin）：根据实际服务器的不同处理能力调度访问请求，使性能更好的服务器处理更多流量。</li>
<li><strong>目标地址散列</strong>（DH, Destination Hashing）：用请求的目标地址计算hash值，从散列表中查找服务器。</li>
<li><strong>源地址散列</strong>（SH, Source Hashing）：用请求的源地址计算hash值，从散列表中查找服务器。</li>
</ul>
</li>
<li><p>动态反馈调度</p>
<ul>
<li><p><strong>最少连接</strong>（LC, Least Connections）：动态将网络请求调度到已建立的连接数最少的服务器上。</p>
</li>
<li><p><strong>加权最少连接</strong>（WLC, Weighted Least Connections）：当集群中服务器性能差异较大的情况下使用，具有较高权值的服务器将承受较大比例的活动连接负载。</p>
</li>
<li><p><strong>基于局部性最少连接</strong>（LBLC, Locality-Based Least Connections）：针对 IP 地址的负载均衡，用于缓存集群系统。根据请求的 IP 地址找出该目标 IP 地址最近的服务器，若该服务器不可用，则用最少连接原则选出一个可用的服务器。</p>
</li>
<li><p><strong>带复制的基于局部性最少连接</strong>（LBLCR, Locality-Based Least Connections with Replication）：针对 IP 地址的负载均衡，根据请求的目标 IP 地址找出与之对应的服务器组，按最小连接原则选出一台服务器。若该服务器超载，就在集群中按最小连接原则选出一台服务器，添加到服务器组中。</p>
</li>
<li><p><strong>最短延迟调度</strong>（SED, Shortest Expected Delay ）：基于WLC进行了优化，只在当前处于活动状态的服务器集合中进行调度。根据公式</p>
<p>$ result = (c_i + 1)/u_i $</p>
<p>计算每个服务器的最终权重结果，其中$c_i$表示当前服务器 <strong>i</strong> 的连接数，$u_i$表示当前服务器 <strong>i</strong> 的权重。取结果最小的服务器来接收请求。</p>
</li>
<li><p><strong>永不排队/最少队列调度</strong>（NQ, Never Queue）</p>
</li>
</ul>
</li>
</ul>
<p>&emsp;&emsp;IPVS尽管非常优秀，但是IPVS仍然有一些不足之处。Linux内核原生的IPVS不具备执行SNAT的能力，也就是说Kubernetes中Service如果有需要做SNAT的场景，那么单靠IPVS是无法实现其功能的。这种情况下，IPVS会退化成iptables模式完成Service的工作。IPVS退化成iptables的场景如下：</p>
<ol>
<li>kube-proxy启动时指定参数 <strong>––masquerade-all=true</strong>，即集群中所有经过 kube-proxy 的包都做一次SNAT</li>
<li>kube-proxy启动时指定参数 <strong>––cluster-cidr</strong></li>
<li>如果需要运行LoadBalancer类型的service</li>
<li>如果需要运行NodePort类型的service</li>
<li>如果Service配置了externalIP对外暴露服务</li>
</ol>
<p>&emsp;&emsp;近年来新出现的<a href="https://lwn.net/Articles/747551/" target="_blank" rel="noopener">BPF(Berkeley Packet Filter)</a> 拥有比IPVS更好的能力和性能，在社区中已经出现了一些考虑用BPF取代IPVS的讨论。</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li><p><strong>SNAT和MASQUERAD的区别</strong></p>
<p>SNAT是指在数据包从网卡发送出去的时候，把数据包中的源地址部分替换为<strong>指定的IP</strong>，这样，接收方就认为数据包的来源是被替换的那个指定IP的主机。</p>
<p>MASQUERADE是SNAT的一个特例。MASQUERADE是用<strong>发送数据的网卡上的IP</strong>来替换源IP，因此，对于那些IP不固定的场合，比如通过DHCP分配IP的情况下，就得用MASQUERADE。</p>
</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top;">Dawelbeit, Omer. &quot;<a href="https://omerio.com/2016/01/02/getting-started-with-kubernetes-on-google-container-engine/" target="_blank" rel="noopener">Getting Started with Kubernetes on Google Container Engine.</a>&quot; <em>IT with Passion</em>. N.p., 2 Jan. 2016. Web. 1 May 2021.</span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top;">Zhiguo, Li. &quot;<a href="https://rootdeep.github.io/posts/kube-proxy-code-analysis/" target="_blank" rel="noopener">Kube-Proxy源码分析.</a>&quot; <em>rootdeep</em>. N.p., 25 Dec. 2018. Web. 14 May 2021.</span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top;">Kubernetes contributors. &quot;<a href="https://kubernetes.io/docs/concepts/services-networking/service/#proxy-mode-userspace" target="_blank" rel="noopener">User space proxy mode.</a>&quot; <em>Kubernetes</em>. N.p., 15 Sept. 2020. Web. 14 May 2021.</span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top;">Kubernetes contributors. &quot;<a href="https://kubernetes.io/docs/concepts/services-networking/service/#proxy-mode-iptables" target="_blank" rel="noopener">iptables proxy mode.</a>&quot; <em>Kubernetes</em>. N.p., 15 Sept. 2020. Web. 14 May 2021.</span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top;">Jun Du,Haibin Xie, and Wei Liang. &quot;<a href="https://kubernetes.io/blog/2018/07/09/ipvs-based-in-cluster-load-balancing-deep-dive/" target="_blank" rel="noopener">IPVS-Based In-Cluster Load Balancing Deep Dive.</a>&quot; <em>Kubernetes</em>. N.p., 9 July 2018. Web. 8 May 2021.</span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top;">Janos . &quot;<a href="https://debugged.it/blog/ipvs-the-linux-load-balancer/" target="_blank" rel="noopener">IPVS: The Linux Load Balancer (Deep Dive).</a>&quot; <em>Have you Debugged.IT?</em>. N.p., 8 Oct. 2020. Web. 8 May 2021.</span></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline-block; vertical-align: top;">Kubernetes contributors. &quot;<a href="https://kubernetes.io/docs/concepts/services-networking/service/#proxy-mode-ipvs" target="_blank" rel="noopener">IPVS proxy mode.</a>&quot; <em>Kubernetes</em>. N.p., 15 Sept. 2020. Web. 14 May 2021.</span></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">8.</span><span style="display: inline-block; vertical-align: top;">Ssup2 . &quot;<a href="https://ssup2.github.io/theory_analysis/Kubernetes_Service_Proxy/" target="_blank" rel="noopener">Kubernetes Service Proxy.</a>&quot; <em>Ssup2 Blog</em>. N.p., 6 May 2019. Web. 9 May 2021.</span></li><li id="fn:9"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">9.</span><span style="display: inline-block; vertical-align: top;">Pollitt, Alex. &quot;<a href="https://www.tigera.io/blog/comparing-kube-proxy-modes-iptables-or-ipvs/" target="_blank" rel="noopener">Comparing Kube-Proxy Modes: Iptables or IPVS?</a>&quot; <em>Tigera</em>. N.p., 18 Apr. 2019. Web. 9 May 2021.</span></li><li id="fn:10"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">10.</span><span style="display: inline-block; vertical-align: top;">setevoy. &quot;<a href="https://rtfm.co.ua/en/kubernetes-service-load-balancing-kube-proxy-and-iptables/#iptables_proxy_mode" target="_blank" rel="noopener">Kubernetes: Service, Load Balancing, Kube-Proxy, and Iptables.</a>&quot; <em>rtfm.co.ua</em>. N.p., 11 Jan. 2020. Web. 8 May 2021.</span></li><li id="fn:11"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">11.</span><span style="display: inline-block; vertical-align: top;">田飞雨. &quot;<a href="https://www.bookstack.cn/read/source-code-reading-notes/kubernetes-kube_proxy_iptables.md" target="_blank" rel="noopener">Kube-Proxy Iptables 模式源码分析.</a>&quot; 书栈网. N.p., 8 Mar. 2020. Web. 8 May 2021.</span></li><li id="fn:12"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">12.</span><span style="display: inline-block; vertical-align: top;">Calico contributors. &quot;<a href="https://docs.projectcalico.org/about/about-kubernetes-services" target="_blank" rel="noopener">About Kubernetes Services.</a>&quot; <em>docs.projectcalico.org</em>. N.p., n.d. Web. 8 May 2021.</span></li><li id="fn:13"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">13.</span><span style="display: inline-block; vertical-align: top;">Graf, Thomas. &quot;<a href="https://github.com/cilium/k8s-iptables-diagram#readme" target="_blank" rel="noopener">Diagram of Kubernetes / Kube-Proxy Iptables Rules Architecture.</a>&quot; <em>GitHub</em>. N.p., 8 Feb. 2018. Web. 8 May 2021.</span></li><li id="fn:14"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">14.</span><span style="display: inline-block; vertical-align: top;">Kubernetes contributors. &quot;<a href="https://kubernetes.io/docs/concepts/services-networking/service/" target="_blank" rel="noopener">Service.</a>&quot; <em>Kubernetes</em>. N.p., 5 May 2018. Web. 8 May 2021.</span></li><li id="fn:15"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">15.</span><span style="display: inline-block; vertical-align: top;">cloudvtech. &quot;<a href="https://blog.csdn.net/cloudvtech/article/details/79728920" target="_blank" rel="noopener">Kubernetes系列之一：Kubernetes如何利用iptables对外暴露service.</a>&quot; <em>CSDN</em>. N.p., 31 Mar. 2018. Web. 8 May 2021.</span></li><li id="fn:16"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">16.</span><span style="display: inline-block; vertical-align: top;">Yingting, Huang. &quot;<a href="https://msazure.club/kubernetes-services-and-iptables/" target="_blank" rel="noopener">Kubernetes Services and Iptables.</a>&quot; <em>msazure.club</em>. N.p., 5 Feb. 2019. Web. 8 May 2021.</span></li><li id="fn:17"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">17.</span><span style="display: inline-block; vertical-align: top;">Serena . &quot;<a href="https://serenafeng.github.io/2020/03/26/kube-proxy-in-iptables-mode/" target="_blank" rel="noopener">Deep Dive Kube-Proxy with Iptables Mode.</a>&quot; <em>Serena Blog</em>. N.p., 26 Mar. 2020. Web. 8 May 2021.</span></li><li id="fn:18"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">18.</span><span style="display: inline-block; vertical-align: top;">Tianyi, Gu. &quot;<a href="https://coconutmilktaro.top/2018/LVS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">LVS负载均衡学习笔记.</a>&quot; <em>TianyiGu’s Blog</em>. N.p., 27 May 2018. Web. 9 May 2021.</span></li><li id="fn:19"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">19.</span><span style="display: inline-block; vertical-align: top;">MornigSpace. “<a href="https://morningspace.github.io/tech/k8s-net-externalip-nodeport/" target="_blank" rel="noopener">Kubernetes Network-ExternalIP and NodePort.</a>&quot; Qinggen Xiaozhu. Np, 9 May 2021. Web. 23 May 2021.</span></li><li id="fn:20"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">20.</span><span style="display: inline-block; vertical-align: top;">Wikipedia contributors. &quot;<a href="https://en.wikipedia.org/wiki/Martian_packet" target="_blank" rel="noopener">Martian packet.</a>&quot; <em>Wikipedia, The Free Encyclopedia</em>. Wikipedia, The Free Encyclopedia, 24 Jan. 2021. Web. 23 May 2021.</span></li><li id="fn:21"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">21.</span><span style="display: inline-block; vertical-align: top;">Baker, Fred, ed. &quot;Requirements for IP version 4 routers.&quot; <a href="https://www.rfc-editor.org/rfc/pdfrfc/rfc1812.txt.pdf" target="_blank" rel="noopener">RFC 1812</a>(1995): 1-175. RFC Editor. Web. 23 May 2021.</span></li><li id="fn:22"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">22.</span><span style="display: inline-block; vertical-align: top;">Kubernetes contributors. &quot;<a href="https://github.com/kubernetes/kubernetes/commit/60bde9fbe2707b013fc03bd41c09fb04d0c6815e" target="_blank" rel="noopener">Fix Nodeport Localhost Martian Source Error.</a>&quot; <em>GitHub</em>. N.p., 15 Jan. 2018. Web. 26 May 2021.</span></li><li id="fn:23"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">23.</span><span style="display: inline-block; vertical-align: top;">admin. &quot;<a href="https://www.thegeekdiary.com/how-to-interpret-linux-martian-source-messages/" target="_blank" rel="noopener">How to Interpret Linux Martian Source Messages.</a>&quot; <em>The Geek Diary</em>. N.p., n.d. Web. 26 May 2021.</span></li></ol></div><p><br><br><br><br></p></div></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Cloud Computing</category>
      </categories>
      <tags>
        <tag>Service</tag>
        <tag>Kubernetes</tag>
        <tag>iptables</tag>
        <tag>IPVS</tag>
        <tag>kube-proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>Java源码阅读笔记02 - String</title>
    <url>/2018/Java-source-String.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;关于<em> <strong>java.lang.String </strong> </em> 的部分笔记，基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;Java语言中关于基础数据类型<strong>char</strong>的封装类型，包含了一些类型之间的字符串查找比较、相互转换封装方法，除此之外还有一些非String类型数据转换String的封装方法API供开发人员使用。</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">--java.lang.Object</span><br><span class="line">    --java.lang.String</span><br></pre></td></tr></table></figure>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><p>&emsp;&emsp;<strong>Serializable, CharSequence, Comparable&lt;String&gt;</strong></p>
<h2 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h2><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;该方法计算每个string字符串的hash值。计算过程中，代码行6-8遵循公式 <strong>s[0]*31^(n-1) + s[1]*31^(n-2) + … + s[n-1]</strong>进行计算，最终算出整个string字符串的hash值。关于计算公式中底数的选择，原作者采用<strong>31</strong>作为指数计算的底数参与计算，对于这一选择，做如下分析和讨论：</p>
<p>&emsp;&emsp;首先，在散列表的设计中有一个概念是冲突率，也就是采用相同的散列函数对不同的数据值进行计算会获取到相同的散列值，于是这些拥有相同散列值的数据会存储在同一个散列表队列中，这样会降低散列查找时的性能。于是在设计散列函数时会尽可能的降低冲突率，使得全域数据值可以尽可能平均的散列在每个散列表中以保证查找效率。鉴于此，在设计散列函数时会考虑选择一些质数来参与计算，诸如2，31，33，37，41，43，101等，这样可以一定程度上保证数据值能均匀分布以降低冲突率（经过数学证明）。</p>
<p>&emsp;&emsp;那么为什么会选择31参与计算而不是2或者其他质数呢？在上述公式中，我们假设n=6，那么 $ 2^{6-1} = 32 $ 得出的散列值集中在一个小的区间里，当数据量逐渐增大时，冲突率也会逐渐上升。所以不会采用2参与散列计算。同理，31，33，37，41，43，101等值与n做幂运算会得到一个相对大的散列区间。但是需要注意的是，101求出的散列区间可能会产生溢出（如果用int表示散列值的话），这样会导致数据丢失，所以101也不是一个好的选择。至于31，33，37，41，43这几个质数应该是比较合理的选择，在这里我们引用《Effective Java》中的一段话：</p>
<blockquote>
<p>The value 31 was chosen because it is an odd prime. If it were even and the multiplication overflowed, information would be lost, as multiplication by 2 is equivalent to shifting. The advantage of using a prime is less clear, but it is traditional. A nice property of 31 is that the multiplication can be replaced by a shift and a subtraction for better performance: <code>31 * i == (i &lt;&lt; 5) - i</code>. Modern VMs do this sort of optimization automatically. </p>
</blockquote>
<p>其中提及到了现代虚拟机对于 31 * i 的一个优化，因为31相对于其他质数来说可以更简单的通过移位和减法操作来实现，所以源码作者最终采用31这个质数参与散列函数的计算。</p>
<h3 id="public-native-String-intern"><a href="#public-native-String-intern" class="headerlink" title="public native String intern()"></a>public native String intern()</h3><blockquote>
<p>Returns a canonical representation for the string object.<br>A pool of strings, initially empty, is maintained privately by the class <code>String</code>.<br> When the intern method is invoked, if the pool already contains a string equal to this <code>String</code> object as determined by the <code>equals(Object)</code> method, then the string from the pool is returned. Otherwise, this <code>String</code> object is added to the pool and a reference to this <code>String</code> object is returned.<br> It follows that for any two strings <code>s</code> and <code>t</code>,  <code>s.intern() == t.intern()</code> is <code>true</code> if and only if <code>s.equals(t)</code> is <code>true</code>.<br> All literal strings and string-valued constant expressions are interned. String literals are defined in section 3.10.5 of the  The Java™ Language Specification.<br>Returns:<br>a string that has the same contents as this string, but is guaranteed to be from a pool of unique strings.  </p>
</blockquote>
<p>&emsp;&emsp;这个方法在java语言中没有对应实现，具体实现是通过其他语言在底层实现具体逻辑的。这个方法的作用是当调用intern()方法时，如果常量池中已经存在该字符串，则返回池中的字符串引用；否则将此字符串添加到常量池中，并返回字符串的引用。关于在常量池中维护字符串的具体细节，JDK1.6 和JDK1.7之间有一点差别，在1.6中，如果常量池中不存在指定的字符串，那么就实例化一个字符串，并维护到常量池中。但是在1.7中，如果常量池中不存在指定的字符串，那么就把堆内存中该字符串的引用（地址）维护到常量池中，不再单独创建新的字符串对象了。这里通过一段网络上比较流行的示例来了解和学习 intern() 这个方法在JDK1.6和1.7之间的区别（更详细的论述可参考文章《<a href="https://tech.meituan.com/in_depth_understanding_string_intern.html" target="_blank" rel="noopener">深入解析String#intern</a>》)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">s.intern();</span><br><span class="line">String s2 = <span class="string">"1"</span>;</span><br><span class="line">System.out.println(s == s2);</span><br><span class="line"><span class="comment">//JDK1.6下打印false，JDK1.7下打印false</span></span><br><span class="line"></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"1"</span>) + <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">s3.intern();</span><br><span class="line">String s4 = <span class="string">"11"</span>;</span><br><span class="line">System.out.println(s3 == s4);</span><br><span class="line"><span class="comment">//JDK1.6下打印false，JDK1.7下打印true</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;图 -1 到图 - 3展示的是JDK1.6环境下代码的执行过程和数据变化。在该环境下，字符串常量池被维护在了持久区，该区域和Java堆内存是相互独立的。(在代码执行的过程中，不可避免的会生成一些辅助对象实例，这里为了简化解释，故这些辅助对象都不予展示和讨论。)</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1534926029/BlogImages/14568162018/note_string_intern_jdk_6_model_part_1.png" alt></p>
<div align="center">
<div align="center">图 - 1</div>
&emsp;
</div>

<p>&emsp;&emsp;图 - 1展示了代码行1-4的执行过程。在代码编译阶段，常量池中便维护了字符串”1”这个值，所以常量池中会有一份”1”的引用。行1代码执行完之后，堆内存中创建了一个String对象实例，其值为1。行2代码执行后，判断常量池中是否有值为”1”的字符串，发现有，那么直接返回常量池中的引用给堆内存中实例。行3代码直接将常量池中的字符串对象赋给引用s2。</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1534926029/BlogImages/14568162018/note_string_intern_jdk_6_model_part_2.png" alt></p>
<div align="center">
<div align="center">图 - 2</div>
&emsp;
</div>

<p>&emsp;&emsp;在代码行7执行后，则会在堆内存中创建一个String对象实例，其值为”11”。</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1534926028/BlogImages/14568162018/note_string_intern_jdk_6_model_part_3.png" alt></p>
<div align="center">
<div align="center">图 - 3</div>
&emsp;
</div>

<p>&emsp;&emsp;在代码行8执行后，发现字符串常量池中并没有值为”11”的字符串，所以在持久区创建了一个同值的字符串。并将该字符串的地址返回给了堆内存中的obj2。代码行9执行完后，直接将s4的引用指向了字符串常量池中的字符串”11”。</p>
<p>&emsp;&emsp;图 - 4到图 - 6展示的是JDK1.7环境下代码的执行过程和数据变化。在该环境下，字符串常量池从持久区中迁移到了堆内存中。</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1534926030/BlogImages/14568162018/note_string_intern_jdk_7_model_part_1.png" alt></p>
<div align="center">
<div align="center">图 - 4</div>
&emsp;
</div>

<p>&emsp;&emsp;图 - 4的执行过程和图 - 1相似，在代码编译阶段维护了字符串”1”在常量池中，创建实例在堆内存中并通过intern()方法指向常量池中的同值字符串。如果是通过<strong>String str = “”</strong>的形式则直接指向字符串常量池中的同值字符串。</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1534926029/BlogImages/14568162018/note_string_intern_jdk_7_model_part_2.png" alt></p>
<div align="center">
<div align="center">图 - 5</div>
&emsp;
</div>

<p>&emsp;&emsp;在代码行7执行后，则会在堆内存中创建一个String对象实例，其值为”11”。</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1534926030/BlogImages/14568162018/note_string_intern_jdk_7_model_part_3.png" alt></p>
<div align="center">
<div align="center">图 - 6</div>
&emsp;
</div>

<p>&emsp;&emsp;<strong>这里期末考试会考！这里期末考试会考！这里期末考试会考！</strong>在行8代码执行完以后，不再单独创建值为”11”的字符串对象并维护到常量池中，而是直接将堆中实例obj2的地址维护到了常量池中。于是在行9代码执行完之后，最终实际指向的也是obj2。</p>
<p>&emsp;&emsp;将上述代码中调用intern()方法做一下顺序调整，最终得到如下代码段，判定结果又会不一样，就问你意不意外，惊不惊喜！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">String s2 = <span class="string">"1"</span>;</span><br><span class="line">s.intern();</span><br><span class="line">System.out.println(s == s2);</span><br><span class="line"><span class="comment">//JDK1.6下打印false，JDK1.7下打印false</span></span><br><span class="line"></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"1"</span>) + <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">String s4 = <span class="string">"11"</span>;</span><br><span class="line">s3.intern();</span><br><span class="line">System.out.println(s3 == s4);</span><br><span class="line"><span class="comment">//JDK1.6下打印false，JDK1.7下打印false</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;图 - 7到图 - 8还是先从JDK1.6环境开始说起。图 - 9到图 - 10则基于环境JDK1.7。</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1534927162/BlogImages/14568162018/note_string_intern_jdk_6_model_part_11.png" alt></p>
<div align="center">
<div align="center">图 - 7</div>
&emsp;
</div>

<p>&emsp;&emsp;图 - 7的过程和图 -1 相似，只是行2和行3的执行顺序不一致，但是最终结果相同。</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1534927159/BlogImages/14568162018/note_string_intern_jdk_6_model_part_12.png" alt></p>
<div align="center">
<div align="center">图 - 8</div>
&emsp;
</div>

<p>&emsp;&emsp;由于字符串”11”在编译阶段就被维护到了常量池中，所以行8直接指向了常量池中的同值字符串”11”。在行9代码执行时，由于常量池中存在同值字符串，所以直接获取其引用。</p>
<p>&emsp;&emsp;图 - 9到图 - 10展示的是JDK1.7环境下代码的执行过程和数据变化。在该环境下，字符串常量池从持久区中迁移到了堆内存中。</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1534927161/BlogImages/14568162018/note_string_intern_jdk_7_model_part_11.png" alt></p>
<div align="center">
<div align="center">图 - 9</div>
&emsp;
</div>

<p>&emsp;&emsp;图 - 9执行过程和图 - 7相同，这里不予赘述。</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1534927160/BlogImages/14568162018/note_string_intern_jdk_7_model_part_12.png" alt></p>
<div align="center">
<div align="center">图 - 10</div>
&emsp;
</div>

<p>&emsp;&emsp;由于常量池中已经维护了字符串”11”，所以在行9调用intern()方法时直接获取了字符串”11”的引用。</p>
<p>&emsp;&emsp;这里需要注意的是，只有在调用了intern()后，才会在常量池中判断并维护字符串，如果通过<strong>new</strong>的方式创建的字符串对象一直未曾调用过intern()方法，那么该对象包含的值也就不会被维护到常量池中。</p>
<h2 id="String-不可变性"><a href="#String-不可变性" class="headerlink" title="String 不可变性"></a>String 不可变性</h2><p>&emsp;&emsp;String类型的对象一旦创建了就无法修改，这个特性称为不可变性。如下述代码声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br></pre></td></tr></table></figure>
<p>作者采用关键字<strong>final</strong>来修饰String类型和value数组。对于String类型来说，final意味着String不可被继承，因此也就不会有子类会重写父类的相关方法，对内容赋值做到了有效控制。对于类中私有变量value来说，这意味着String对象一旦创建并对value数组赋值之后，不会有API去修改value数组的值。关于String的不可变性，《Java核心技术 卷I》 有一个论述：</p>
<blockquote>
<p>将方法或类声明为final主要目的是：确保它们不会再子类中改变语义。String类是final类，这意味着不允许任何人定义String的子类。换言之，如果有一个String的引用，它引用的一定是一个String对象，而不可能是其他类的对象。 </p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; ——《Java核心技术 卷 I》 </p>
</blockquote>
<p>&emsp;&emsp;关于String字符串，JVM为了提高性能和降低内存消耗设计了一个字符串常量池。每当创建一个字符串对象时，JVM首先会在常量池中寻找是否有已存在的具有相同内容值的字符串，如果有，就返回常量池中的引用给到对象，反之则创建一个新的字符串实例并维护到常量池中。</p>
<p>&emsp;&emsp;关于字符串常量池，JDK1.6和JDK1.7有一些不一致的地方。如上文陈述，在1.6中，常量池被分配在了永久代中，所以在1.6环境中常量池的数量会有一个上限。这也是为什么在1.6环境中不建议使用String.intern()方法，因为这会导致OOM（Out of memory）。除此之外，在永久代中的常量池也不会参与垃圾回收过程，一旦创建便会一直存在。而在1.7中，常量池被分配在了堆内存中，鉴于此，常量池的容量通过配置<strong>-XX:StringTableSize</strong>参数得到了大幅提升。所以在1.7环境中，因为常量池被分配到了堆内存的缘故，常量池中的失效内容所占据的内存资源会被垃圾回收过程释放。</p>
<h2 id="连接符号”-”"><a href="#连接符号”-”" class="headerlink" title="连接符号”+”"></a>连接符号”+”</h2><p>&emsp;&emsp;Java中String对象可以通过”+”来拼接两个字符串，底层原理是通过创建一个Stringbuilder实例对象来完成字符串的拼接，也就是说，通过”+”完成一次字符串拼接会产生一个Stringbuilder对象实例，该实例的值等于拼接操作执行后的预期结果，并通过Stringbuilder对象的toString方法返回执行结果。在JDK1.5之前，底层创建的是Stringbuffer对象，之所以在1.5之后采用Stringbuilder是因为Stringbuilder相对于Stringbuffer来说更有效率。相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 源代码如下：</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        String s = <span class="string">"abc"</span>;</span><br><span class="line">        System.out.println(s + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//经过反编译操作后获取的底层代码段</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;    <span class="comment">//删除了默认构造函数和字节码</span></span><br><span class="line">        <span class="keyword">byte</span> byte0 = <span class="number">10</span>;      </span><br><span class="line">        String s = <span class="string">"abc"</span>;      </span><br><span class="line">        System.out.println((<span class="keyword">new</span> StringBuilder()).append(s).append(byte0).toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li>String的初始化方式及区别：<ol>
<li>String string = “helloworld”；<br>直接在字符串常量池中创建字符串常量并将地址赋给对象。</li>
<li>String STR = new String(“RT”):<br>先在堆中创建对象，然后把对象引用赋给变量。</li>
</ol>
</li>
<li>字符串相加：<ol>
<li>字符串如果是变量相加，先开空间，在拼接。除非变量是用final修饰的，那么可以把用final修饰的变量视为常量处理；</li>
<li>字符串如果是常量相加，是先加，然后在常量池找，如果有就直接返回，否则，就创建。</li>
</ol>
</li>
<li><p>Java语言规范(The Java Language Specification Java SE 7 Edition)关于字符串常量的一些论述如下:</p>
<blockquote>
<p>Literal strings within the same class in the same package represent references to the same String object.<br>Literal strings within different classes in the same package represent references to the same String object.<br>Literal strings within different classes in different packages likewise represent references to the same String object.<br>Strings computed by constant expressions are computed at compile time and then treated as if they were literals.<br>Strings computed by concatenation at run time are newly created and therefore distinct.<br>The result of explicitly interning a computed string is the same string as any pre-existing literal string with the same contents.</p>
</blockquote>
<p>同一个包下同一个类中的字符串常量的引用指向同一个字符串对象；<br>同一个包下不同的类中的字符串常量的引用指向同一个字符串对象；<br>不同的包下不同的类中的字符串常量的引用仍然指向同一个字符串对象；</p>
</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>[美] Joshua Bloch. Effective Java 2nd Edition[M]. Boston:Addison-Wesley Professional, 2008.</li>
<li>[美] James Gosling, etc. The Java Language Specification Java SE 7 Edition[M]. Boston:Addison-Wesley Professional, 2013.</li>
<li>coolblog. <a href="https://segmentfault.com/a/1190000010799123" target="_blank" rel="noopener">科普：为什么 String hashCode 方法选择数字31作为乘子</a>[E]</li>
<li>ScienJus. <a href="https://blog.csdn.net/sinat_19425927/article/details/38663461" target="_blank" rel="noopener">[Java]String中“+”的实现原理及效率</a>[E]</li>
<li>SEU_Calvin. <a href="https://blog.csdn.net/SEU_Calvin/article/details/52291082" target="_blank" rel="noopener">Java技术——你真的了解String类的intern()方法吗</a>[E]</li>
<li>Mikhail Vorontsov. <a href="http://java-performance.info/string-intern-in-java-6-7-8/" target="_blank" rel="noopener">String.intern in Java 6, 7 and 8 – string pooling</a>[E]</li>
<li>lumeng689. <a href="http://www.importnew.com/10756.html" target="_blank" rel="noopener">什么是字符串常量池？</a> [E]</li>
<li>美团技术团队. <a href="https://tech.meituan.com/in_depth_understanding_string_intern.html" target="_blank" rel="noopener">深入解析String#intern</a> [E]<br>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s network之四：Kubernetes集群通信的实现原理</title>
    <url>/2021/K8s-Network-Architecture-section-four.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;Kubernetes网络架构要求集群内的任意两个Pod之间可以在无需NAT的前提下进行通信。在集群中一共有四种Pod间通信的场景：Pod内容器之间相互通信、同一个节点内多个Pod之间相互通信、不同节点上的多个Pod之间相互通信以及Pod和Service之间的通信。其中，Pod和Service之间的通信过程分析请移步到《<a href>K8s network之五：Kubernetes集群Pod和Service之间通信的实现原理</a>》，本文会着重分析多容器Pod内、同一节点上的Pod之间以及不同节点上的Pod之间的通信过程。出于篇幅考虑，相关的yaml配置不会在文章中出现，特殊情况除外，相关的yaml配置可以参考<a href="https://kubernetes.io/" target="_blank" rel="noopener">Kubernetes</a>官方文档。</p>
<a id="more"></a>
<p>&emsp;&emsp;<a href>1. K8s network之一：K8s网络模型与网络策略</a></p>
<p>&emsp;&emsp;<a href>2. K8s network之二：Kubernetes的域名解析、服务发现和外部访问</a> </p>
<p>&emsp;&emsp;<a href="/404.html">3.Linux网络在Kubernetes集群中的应用</a> </p>
<p>&emsp;&emsp;<a href>5.K8s network之五：Kubernetes集群Pod和Service之间通信的实现原理</a> </p>
<h2 id="Pod内容器之间通信过程"><a href="#Pod内容器之间通信过程" class="headerlink" title="Pod内容器之间通信过程"></a>Pod内容器之间通信过程</h2><p>&emsp;&emsp;在kubernetes集群中，每个Pod会被分配一个IP地址。同一个Pod内的多个业务容器会共享这个IP地址对外通信，同时，这些容器之间也可以直接通过localhost<strong>:</strong>端口号的方式进行通信。为了实现Pod内容器之间的通信，Kubernetes利用pause容器和Docker的container模式网络这两个工具来达成目的。</p>
<p>&emsp;&emsp;Docker在创建业务容器的时候可以通过命令参数<strong>—network=container:NAME_or_ID</strong>来创建一个container模式的网络结构。在这种场景下，新创建的业务容器会加入NAME_or_ID指定的容器的网络命名空间中，与指定的容器共享同一个网络栈、对外使用同一个IP地址或者MAC地址进行通信、相互之间也可以直接使用localhost<strong>:</strong>端口的形式完成通信。如果业务容器执行了重启动作并再次以<strong>—network=container:NAME_or_ID</strong>完成创建操作，就可以实现重启前后拥有相同的IP地址信息。除非NAME_or_ID指定的容器被重启，否则当前Pod会始终拥有一个固定的IP地址，Pod内的业务容器亦是如此。Kubernetes的Pod内网络实现就是借鉴了Docker的这种模式来实现Pod内多个容器之间的相互通信的。</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1624527339/BlogImages/CloudSerials/K8sNetArchP4/Pod-Inner-Structure-demo.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 1 Pod内网络结构 </div>
&emsp;
</div>

<p>&emsp;&emsp;接下来我们回顾下在Kubernetes集群中一个Pod是如何产生的，大致流程可参考图2所示：</p>
<div style="text-align: center; width: 100%;">

<img src="https://res.cloudinary.com/jknight/image/upload/v1624433161/BlogImages/CloudSerials/K8sNetArchP4/How-To-Create-a-Pod.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center"><br>图 - 2 Pod创建流程<sup id="fnref:1" style="font-size:80%;line-height:80%;"><a href="#fn:1" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[1]</span></a></sup></div>
&emsp;
</div>

<p>&emsp;&emsp;现在我们把目光放在CRI这里，在Pod创建的校验、准备工作都做好之后会通知CRI来执行Pod的创建逻辑。由图2可知，<strong>pause容器</strong>将会是Pod中第一个被创建的容器，pause容器是一个非业务相关的、功能十分简单的特殊容器。我们知道，Pod是一个或一组容器的集合，基于Linux的namespace和cgroups，为容器提供了隔离的环境。每个Pod中都会有一个pause容器，Ian Lewis在他的文章《<a href="https://www.ianlewis.org/en/almighty-pause-container" target="_blank" rel="noopener">The Almighty Pause Container</a>》<sup id="fnref:2" style="font-size:80%;line-height:80%;"><a href="#fn:2" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[2]</span></a></sup>中指出pause容器在多容器Pod中起到了一个类似于”父容器“的作用，在某些文章中，它也被称为<strong>infra container</strong>，它承担了两个重要的职责：</p>
<ul>
<li><p><strong>pause容器是Pod中Linux命名空间共享的基石</strong></p>
<p>&emsp;&emsp;在Linux中，子进程会继承其父进程的命名空间。当然，你也可以通过unshare工具来创建一个拥有新的、独立的命名空间的进程。如果一个进程A处于运行状态，那么就可以将别的进程加入到A的命名空间中，这样就形成了一个Pod。Linux中通过系统调用<strong>setns</strong>就可以实现将一个进程加入到一个已经存在的命名空间的功能。Pod中的多个容器之间会共享命名空间，Docker的出现够使得Pod中的多个容器之间共享命名空间更容易一些：</p>
<p>&emsp;&emsp;首先，通过docker启动一个pause容器。我们都知道容器的隔离是通过Linux内核的namespace命名空间机制来实现的，只要一个进程一直存在，它就会一直拥有一个命名空间。所以当pause容器就绪后，我们就得到了一个网络命名空间。我们可以在这个网络命名空间中加入新的容器来构建一个关联紧密的容器组。接着，我们可以继续启动新的容器，需要注意的是，在这个过程中我们始终将新启动的容器加入到pause容器的命名空间中。当上述这个过程完成后，一个Pod就形成了，这个Pod内的多个容器之间会共享同一个网络命名空间，而这个命名空间是属于pause容器的。这些容器之间可以直接通过localhost和端口来相互访问。</p>
</li>
<li><p><strong>当Pod内PID命名空间共享开启后，pause容器的地位等同于PID为1的进程，同时还负责Pod中僵死进程的回收工作</strong></p>
<p>&emsp;&emsp;Linux中处于一个PID命名空间下的所有进程会形成一个树形结构，除了PID=1的”init“进程之外，每个进程都会有一个父进程。每个进程可以通过系统调用folk和exec来创建一个新的进程，而调用folk和exec的进程就会成为新创建进程的父进程。每个进程在操作系统的进程表中都会有一个记录，这条记录包含了对应的进程当前的状态和返回码等诸多信息。当一个进程结束其生命周期后，如果它的父进程没有通过系统调用<strong>wait</strong>获取返回码释放子进程的资源，那么这个进程就会变成僵死进程（zombie processes）。僵死进程不再运行，但是进程表中的记录仍然存在，除非父进程完成了子进程的回收工作。一般情况下，僵死进程的存在时间会非常短，但是世事无绝对，又或者如果僵死进程的数量太大，还是会浪费相当可观的系统资源的。僵尸进程一般由其父进程完成回收工作，但是如果父进程在子进程结束之前就已经结束运行的话，那么操作系统就会指派PID=1的”init“进程成为子进程新的父进程，由”init“进程调用wait获取子进程的返回码并完成子进程的资源回收和善后工作。</p>
<p>&emsp;&emsp;在Docker中，每个容器都有其自己的PID命名空间，同时又可以将一个容器A加入到另一个容器B的命名空间中。此时，B就承担了”init“进程的职责，而诸如A等被加入到B的命名空间的容器就是”init“进程的“子进程”。假设一个Pod中没有pause容器只有业务容器，那么第一个创建的容器就需要承担起”init“进程的责任—维护命名空间、回收僵死进程等。但是业务容器可能并没有这样的能力来完成这些任务。所以kubernetes在Pod创建过程中会第一个将pause容器创建出来，整个Pod的网络命名空间就是pause容器的命名空间，pause容器会肩负起”init“进程（PID=1）的职责，同时完成僵死进程的回收工作。这就是为什么Pod中会有一个pause容器的原因。</p>
<p>&emsp;&emsp;”init“进程和僵死进程的概念只有在Pod内PID命名空间共享开启后才有意义，如果PID命名空间未共享，鉴于Pod中的每个容器都以PID=1的”init“进程来启动，所以它需要自己处理僵死进程。尽管应用通常不会大量产生子进程，所以一般情况下不会有什么问题，但是僵死进程耗尽内存资源确实是一个容易忽视的问题。此外，开启PID命名空间共享也能够保证在同一个Pod的多个容器之间相互发送信号来进行通信，所以Kubernetes集群默认开启PID命名空间共享真的是非常有益的。</p>
</li>
</ul>
<p>&emsp;&emsp;继续关注图2，前面提到，业务容器的创建用的是docker的container模式网络，而pause容器的创建用的是docker的<strong>none</strong>模式网络。CRI只负责给pause容器生成一个network namespace，CNI会完成pause容器的网络配置，包括但不限于网络接口、IP地址、MAC地址等。CNI插件会先调用IPAM插件完成IP地址的申请和分配工作，之后由CNI插件完成pause容器的网络接口eth0的创建和配置工作，由IPAM得到的IP地址也会配置这个eth0接口上。最后，会通过<strong>veth-pair</strong>将这个Pod接入所在节点的网络，此时，这个Pod就成功地创建并可以和其他Pod相互通信了。<strong>veth-pair</strong>都是成对出现的，一端在pause容器的网络namespace中，另一端在所在节点的cbr0网桥上。在图2中我们看到Pod端并没有对应的veth***，而是一个eth0接口。它其实就是veth对的另一端，Kubernetes把Pod的eth0通过veth-pair连接到所在节点的网桥上，成为该节点网桥上的一个”从属设备“，实质上就是该网桥的一个端口，此时这个”从属设备“或者说端口（也就是这个Pod）只剩下了收发数据包的能力，其他诸如数据包转发、丢弃等功能均由网桥来负责实现。</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1624528203/BlogImages/CloudSerials/K8sNetArchP4/Pod-Inner-Communication-demo.webp" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 3 Pod内通信过程</div>
&emsp;
</div>

<p>&emsp;&emsp;因为同一个Pod内的多个容器之间共享pause容器的网络命名空间进而可以通过localhost:端口的形式相互访问，所以它们之间相互通信的流量并不会经过eth0接口。</p>
<h2 id="同一个Node内多个Pod之间通信过程"><a href="#同一个Node内多个Pod之间通信过程" class="headerlink" title="同一个Node内多个Pod之间通信过程"></a>同一个Node内多个Pod之间通信过程</h2><p>&emsp;&emsp;Docker组建单主机容器网络时默认采用的是桥接网络结构，当Docker进程开启后，Docker会在宿主机上创建一个docker0的linux虚拟网桥，这是一个二层设备，它会学习每个端口连接的网络设备的MAC地址信息并通过MAC地址将数据包转发到正确的目的设备上。宿主机上的容器通过veth-pair连接到这个网桥上，并且以网桥作为容器的默认网关来实现与宿主机外实例的通信。</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1624525285/BlogImages/CloudSerials/K8sNetArchP4/docker-bridge-network-demo.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 4 Docker 桥接网络模型</div>
&emsp;
</div>

<p>&emsp;&emsp;Kubernetes在组建节点内网络时同样采用了docker的桥接网络结构。每个节点有一个根网络命名空间（root network namespace），负责该节点的对外通信，Linux内核提供的路由功能记录了节点eth0接口和网桥cbr0的IP地址信息。因为节点的eth0和网桥cbr0通常不在一个网段，所以这两个节点的通信就通过Linux内核提供的路由功能来实现。除了Docker里采用的是docker0网桥而Kubernetes改成了cbr0网桥之外，这两者的网络结构基本相似。</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1624526974/BlogImages/CloudSerials/K8sNetArchP4/Communication-between-Pods-In-A-Node.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 5 同节点上Pod间网络通信结构基础</div>
&emsp;
</div>

<p>&emsp;&emsp;cbr0网桥是一个由Linux内核构建出来的虚拟的二层网络设备，它将两个及以上的网段连接在一起，扩大了网络的规模。网桥维护了一张转发表，这张表包含了每个端口的信息、该端口映射的MAC地址、IP地址和MAC地址映射关系等信息。借助于这张转发表，网桥就可以根据收到的报文中包含的源/目的地址信息将其转发到对应的端口上。节点内的每个Pod在创建时会从所在节点的IP地址集合中得到一个IP地址，并通过veth-pair将自己和cbr0网桥连接起来。同时，cbr0网桥也是每个Pod的默认网关。这样，节点内的诸多Pod和cbr0网桥就构成了一个网段相同的局域网，cbr0通过ARP报文学习连接在其上面的每个设备（Pod）的MAC地址信息，并将接收到的报文依据其指明的目的MAC地址转发到对应的设备上，实现Pod间的相互通信。换句话说，同一个节点里的Pod之间的通信不会经过vRouter，更不会经过节点的eth0接口。如果Pod要和节点外的实体通信，那么就会将报文通过通过vRouter和eth0转发到集群外完成通信过程。</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1624545598/BlogImages/CloudSerials/K8sNetArchP4/Pod-Communication-in-a-node-demo.webp" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 6 同节点上Pod间网络通信</div>
&emsp;
</div>

<p>&emsp;&emsp;当目的Pod和源Pod不在同一个网段中时，cbr0网桥就以网关的身份将数据包转发到Linux内核，并根据iptables的路由规则将其转发合适的路径上。具体过程可浏览<a href="#PCCN">不同节点之间多个Pod的通信过程</a>。</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1624545598/BlogImages/CloudSerials/K8sNetArchP4/Pod-Communication-out-of-a-node-demo.webp" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 7 Pod与节点外实体通信</div>
&emsp;
</div>

<h2 id="不同Node节点之间多个Pod的通信过程"><a href="#不同Node节点之间多个Pod的通信过程" class="headerlink" title="不同Node节点之间多个Pod的通信过程"></a>不<span id="PCCN">同Node节点之间多个Pod的通信过程</span></h2><h3 id="直接路由方案"><a href="#直接路由方案" class="headerlink" title="直接路由方案"></a>直接路由方案</h3><p>&emsp;&emsp;实际的生产系统集群通常是由多个节点构成的，那么如何将这多个节点连接起来形成一个完整的相互联通的网络就成为首要问题。最简单的解决方案就是直接采用直接路由的方案，也就是在每个节点上配置集群中其他节点的地址信息，通过IP转发的方式实现跨节点Pod的通信，基本的网络架构模式如图8所示：</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1624599374/BlogImages/CloudSerials/K8sNetArchP4/Pod-Communication-Cross-Node-Route-Mode.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 8 三层路由模式实现Pod跨节点通信</div>
&emsp;
</div>

<p>&emsp;&emsp;节点N中的某个Pod 1想与节点Y中的Pod b通信，那么Pod 1就会发起一个请求并传给节点N的cbr0网桥，网桥发现目的地址不在其所辖的网段，于是就将请求转发给了vRouter，vRouter通过查询路由表知道目的地址所在的网段，就将请求的目的MAC地址修改为节点Y的eth0端口的MAC地址。节点Y收到请求后发现目的MAC地址指向自身，继续将请求通过节点Y上的vRouter转发给cbr0网桥，网桥根据目的IP地址查找对应的MAC地址，之后将请求转发到对应的端口上，这样节点Y上的Pod b就收到了来自Pod 1的请求，并且Pod b看到的源IP和目的IP分别为Pod 1的IP地址和自己的IP地址。</p>
<p><strong>【Note】：</strong>在图-8及之前的配图中有一个vRouter图例，它代表的是Linux内核提供的路由功能，借助于iptables/netfilter等工具，Linux就具备了路由器的路由转发能力。同时，节点的eth0接口可以看成是Linux这个“路由器”的一个端口。</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1624772988/BlogImages/CloudSerials/K8sNetArchP4/Pod-Communication-Cross-Node-In-Router-Mode.webp" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 9 三层路由模式下Pod跨节点通信的报文传递过程</div>
&emsp;
</div>

<p>&emsp;&emsp;直接路由方案虽然相对来说简单一些，但同时也有一些问题。在集群中的每个节点都需要配置非自身节点的路由信息来与其他节点通信，如果集群中节点的数量非常大，那么这个配置过程将会非常繁琐。如果向集群中加入新的节点，或者剔除因故无法继续工作的节点，同样需要更新集群中所有其他节点的路由信息，大大增加了集群网络管理的复杂性、成本和出错概率。还有，如果集群中节点规模非常大的话，有可能会造成路由表规模的膨胀，尽管有一些机制来应对路由表规模膨胀所带来的性能下降问题，但这依旧是一个不容忽视的问题。当然，你也可以借助BGP、RIP、OSPF等动态路由协议来完成集群节点之间的路由发现，一定程度上可以降低集群节点路由配置的成本。</p>
<h3 id="Overlay网络方案"><a href="#Overlay网络方案" class="headerlink" title="Overlay网络方案"></a>Overlay网络方案</h3><p>&emsp;&emsp;除了上述提到的路由方案，其实还有一种更主流的跨主机网络构建方案—Overlay网络架构。在《<a href>K8s network之一：K8s网络模型与网络策略</a>》中，我们已经对Overlay网络进行了一个简单的介绍。一些流行的CNI插件诸如Flannel、Weave等都提供了基于Overlay网络的跨主机组网实现方案。Overlay可以在无需变更现有底层物理网络配置的前提下，通过网络协议和报文封装等方式来构建一个可以运行在物理网络上的逻辑网络。鉴于此，Overlay可以更灵活地针对业务需求的变化和迭代来构建满足要求的网络环境。</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1624779098/BlogImages/CloudSerials/K8sNetArchP4/Pod-Communication-Cross-Node-In-Overlay-Mode-demo.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center"><br>图 - 10 Pod跨节点通信Overlay网络架构</div>
&emsp;
</div>

<p>&emsp;&emsp;在Overlay网络架构下，CNI插件会在各个节点Node之间建立可通信的虚拟隧道，报文在发出节点之前会在VTEP设备上被封装成规定的格式并在隧道中传递，在目的节点收到报文后同样会在VTEP设备上对报文进行解封装并发送给目的Pod。接下来会以最常见的Flannel插件为例来了解Overlay网络下Pod之间是如何完成跨节点通信的。Flannel是由CoreOS公司为Kubernetes设计的一个开源的虚拟网络方案实现产品。<strong>flanneld</strong>代理是Flannel运行在<strong>每个节点上</strong>的一个守护进程，它负责为每个节点分配一个互不重叠的IP子网范围，节点上创建Pod所需的IP地址均来自于此。在flannel的运行环境中，etcd会负责维护网段和节点的映射关系，flanneld在运行过程中会与etcd通信，从中获取IP子网范围，也正是因为所有的flanneld都是从etcd中获取IP子网，所以保证了每个节点的IP子网可以互不重叠。在拿到IP地址范围后，通过配置Docker的启动参数—bip（bridge network IP）的值为获得IP地址范围来配置所在节点的IP地址池。同时，flanneld还兼有更新节点的路由信息以及和其他节点交换、同步路由信息的功能。Flannel为了实现集群网络的互联互通，实现了如下的两个基础目标：</p>
<ol>
<li>集群中的每个节点都有一个IP地址子网，且任意两个节点间的子网范围互不重叠</li>
<li>集群中的节点之间建立一个逻辑的Overlay网络，数据包在这个网络上传递</li>
</ol>
<p>&emsp;&emsp;Flannel在较早些版本中是使用的UDP模式来构建Overlay网络的，出于性能等因素的考虑，在后来的版本中采用了更高效的VXLAN来实现Overlay网络。Flannel通过配置文件来决定采用何种backend模式来完成网络构建，如果<strong>—kube-subnet-mgr</strong>的值为true，那么Flannel就会从<strong>/etc/kube-flannel/net-conf.json</strong>读取配置，否则就会从etcd读取（默认从配置文件/coreos.com/network/config读取，可以借助参数<strong>—etcd-prefix</strong>覆盖之）。配置文件的构成如下所示：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"Network"</span>: <span class="string">"10.0.0.0/8"</span>,</span><br><span class="line">	<span class="attr">"SubnetLen"</span>: <span class="number">20</span>,</span><br><span class="line">	<span class="attr">"SubnetMin"</span>: <span class="string">"10.10.0.0"</span>,</span><br><span class="line">	<span class="attr">"SubnetMax"</span>: <span class="string">"10.99.0.0"</span>,</span><br><span class="line">	<span class="attr">"Backend"</span>: &#123;</span><br><span class="line">		<span class="attr">"Type"</span>: <span class="string">"udp"</span>,</span><br><span class="line">		<span class="attr">"Port"</span>: <span class="number">7890</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Network：以CIDR格式规定了整个Flannel网络的IPv4网络范围。这个参数也是唯一一个必填的参数</li>
<li>SubnetLen：分配给每个节点的子网大小，默认是24（也就是“A.B.C.D/24”）。如果<strong>Network</strong>字段IP网络的网络号位数大于24，那么SubnetLen会比<strong>Network</strong>字段IP网络的网络号位数大一。比如，如果<strong>Network</strong>字段配置的是“10.0.0.0/26”，那么subnetLen就是27</li>
<li>SubnetMin：子网划分和分配可用的起始子网范围，默认为<strong>Network</strong>字段IP网络的第一个子网（也就是网络号最小的子网）</li>
<li>SubnetMax：子网划分和分配可用的最后一个子网范围，默认为<strong>Network</strong>字段IP网络的最后一个子网（也就是网络号最大的子网）</li>
<li>Backend：指定采用VXLAN、UDP、host-gw哪种模式完成网络构建。默认是UDP。Flannel除了这三种模式外，还有一些处于开发和试验中的模型，各个模式的介绍及其需要填充的参数可参考Flannel的官方文档<sup id="fnref:3" style="font-size:80%;line-height:80%;"><a href="#fn:3" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[3]</span></a></sup></li>
</ul>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1624802691/BlogImages/CloudSerials/K8sNetArchP4/Pod-Communication-Cross-Node-In-Overlay-Mode-Flannel-UDP-Arch.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 11 Flannel UDP模式基本架构</div>
&emsp;
</div>

<p><strong>【Note】</strong>在早期的Flannel版本中网桥标识是docker0，在后来的版本迭代中才变成了cni0。但无论如何，两者指代的都是同一个组件—Linux虚拟网桥</p>
<p>&emsp;&emsp;在图11中有一个flannel0图例，flannel0是由flanneld进程生成的一个tun设备，tun是Linux内核实现的一种虚拟的三层网络设备，因此能够提供和硬件设备类似的IP数据包的处理能力。利用tun设备，可以实现用户空间和内核空间之间的数据传输。根据流量的流向，flannel0提供了不同的对数据的操作能力：</p>
<ol>
<li>当IP数据包被写入到flannel0接口时，数据包会被直接发送给内核最后传递到cni0网桥上，cni0会根据数据包的目的地址信息将该数据包转发到对应Pod上</li>
<li>当IP数据包进入内核且根据路由表的匹配结果表明该数据包需要被转发给flannel0时，内核会将该数据包直接发送给创建flannel0的flanneld进程处理</li>
</ol>
<p>&emsp;&emsp;为了避免引起歧义，写入到flannel0接口指的是数据包由flanneld进程解封并发送给flannel0设备，相应地，数据包进入内核指的是数据包由cni0网桥被转发给flannel0设备。</p>
<p>&emsp;&emsp;在UDP模式下，Pod 1如果想与跨节点的Pod c通信，那么首先会向Pod 1的默认网关cni0网桥发送数据包。cni0在确定目的地址不在cni0所辖网段后就会将数据包转发给flannel0设备。flannel0在收到数据包后就会由flanneld进程根据当前节点上维护的路由表条目信息对数据包进行UDP封装。除了原始的IP数据包外，封装后的数据包还包括目的地址用来监听Flannel请求的端口号，以及封装包的源和目的地址。其中，Pod 1所在节点的节点IP和节点MAC地址是封装包的源IP和MAC地址，Pod c所在节点的节点IP和MAC地址是封装包的目的IP和MAC地址。flanneld将数据包封装后就会通过节点的eth0接口将数据包发送到网络上。当目的节点在监听Flannel请求的端口上收到了封装数据包后会验证目的IP和目的MAC与自身节点的匹配情况。如果确定自身是数据包的目的地后，会将数据包解封装后发送给节点的flannel0设备，flannel0继续将数据包转发给cni0网桥，由网桥将数据包发送给目的Pod。</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1624860068/BlogImages/CloudSerials/K8sNetArchP4/Pod-Communication-Cross-Node-In-Overlay-Mode-Flannel-UDP-Demo.webp" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 12 Flannel UDP模式工作流程</div>
&emsp;
</div>

<p>&emsp;&emsp;UDP模式下数据包需要通过源节点上的用户空间 <strong>-&gt;</strong> 内核空间以及目的节点上的内核空间 <strong>-&gt;</strong>用户空间两次转换，所以实际过程中通信效率会稍微有点差强人意。鉴于UDP模式的性能并不理想，后续的Flannel版本开始尝试用VXLAN来实现Overlay网络的构建，将flanneld封装/解封装的过程交由Linux内核处理，以此通过避免UDP模式里的两次转换来提高性能。</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1624802691/BlogImages/CloudSerials/K8sNetArchP4/Pod-Communication-Cross-Node-In-Overlay-Mode-Flannel-VXLAN-Arch.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 13 Flannel VXLAN模式基本架构</div>
&emsp;
</div>

<p>&emsp;&emsp;上图中”<strong>flannel.1</strong>“代表了VXLAN中的一个VTEP设备，命名格式是”<strong>flannel.&lt;vni&gt;</strong>“,vni默认从1开始编号。数据包的封装/解封装均由VTEP设备flannel.1完成，flanneld不再参与这个过程，而是负责VTEP设备的维护工作。在flanneld启动过程中会先保证VTEP设备flannel.1存在，如果flannel.1存在的话就跳过这个过程。之后flanneld会持续的和etcd保持联系，获取其他节点VTEP设备地址信息的变动情况并更新所在节点的ARP表、FDB(Forwarding database）表、iptables等，以及将自己所在节点的IP地址变化情况发送给etcd。经过flanneld的同步和更新操作，每个节点上的flannel.1都能知道其他节点的IP/MAC信息并发起通信。</p>
<p>&emsp;&emsp;在实际工作过程中，Pod1首先将IP数据包发送给cni0网桥，cni0网桥在确定目的Pod不在当前所处子网后会将IP数据包转发给VTEP设备flannel.1，flannel.1会向flanneld请求目的Pod所在节点的地址信息，然后封装VXLAN数据包。VXLAN默认工作在VTEP设备的4789端口上。flannel.1在完成数据包封装后通过节点的eth0接口把数据包发送到网络上，当目的节点接收到数据包后会发给flannel.1设备，由flannel.1完成数据包的解封装，之后检查目的MAC是不是flannel.1设备自身的MAC地址，确认后继续将数据包转发给cni0网桥，由cni0网桥将数据包发送给目的Pod。</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1624928288/BlogImages/CloudSerials/K8sNetArchP4/Pod-Communication-Cross-Node-In-Overlay-Mode-Flannel-VXLAN-Demo.webp" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 14 Flannel VXLAN模式工作流程</div>
&emsp;
</div>

<p>&emsp;&emsp;VXLAN的数据包格式如图-15所示，最外层的IP和MAC地址代表物理网络上联通通信的两端，在图-14中代表的是节点N和Y的eth0接口的IP和MAC地址。接着是UDP封装及VTEP设备上监听VXLAN请求的端口，目的端口默认是4789，源端口是由内层以太网帧头部计算出来的一个散列值，端口范围为49152-65535<sup id="fnref:4" style="font-size:80%;line-height:80%;"><a href="#fn:4" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[4]</span></a></sup>。VNI表明了各个节点上的VTEP设备都在VNI为1的网络段中建立隧道构建逻辑网络。内层MAC地址指的是VXLAN隧道两端的VTEP的MAC地址，也就是节点N和Y上的flannel.1的MAC地址，最后的报文部分是Pod实际发出的报文内容。</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1624887689/BlogImages/CloudSerials/K8sNetArchP4/Flannel-VXLAN-Package-Structure-Demo.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 15 Flannel VXLAN模式数据包结构</div>
&emsp;
</div>

<p>&emsp;&emsp;在Flannel的VXLAN模式中，节点之间的VTEP设备MAC地址学习并不像标准的VXLAN网络那样是通过ARP协议来进行的，每个节点上的flanneld会将本地的flannel.1的IP和MAC信息同步给etcd，由各个节点的flanneld进程协作完成VTEP设备IP/MAC地址的更新和同步工作。</p>
<p>&emsp;&emsp;Flannel还提供了host-gw模式的backend来支持前面提到的直接路由模式，这么做可以一定程度上提升性能。通过在各个节点上添加到其他节点的路由信息，使得跨主机之间的Pod的IP数据包可以借助于节点的二层网络进行传递和转发。优点是省去隧道建立和封包/解封包造成的性能损耗，缺点是host-gw要求集群各个节点之间要做到二层互通，因为host-gw不具备跨网通信能力。也就是说，在数据包转发过程中的下一跳MAC地址无法指向另一个网络中的某个节点的地址。所以当遇到这个问题时，可以考虑采用Flannel的VXLAN的backend提供的DirectRouting模式。当Pod之间通信处在同一个网络时，那么就直接在二层网络完成通信操作，只有当通信的Pod不在同一个网段时，才会建立隧道实现跨网通信。</p>
<h2 id="Pod和集群外实体通信"><a href="#Pod和集群外实体通信" class="headerlink" title="Pod和集群外实体通信"></a>Pod和集群外实体通信</h2><p>&emsp;&emsp;Pod除了可以和集群内的其他Pod进行通信，和Service通信外，还可以直接被集群外部的实体访问到。Kubernetes提供了两种方式将单独的Pod暴露在集群外：<strong>hostPort</strong>和<strong>hostNetwork</strong>。</p>
<h3 id="hostPort"><a href="#hostPort" class="headerlink" title="hostPort"></a>hostPort</h3><p>&emsp;&emsp;hostPort需要指定在Pod上，这样就会开启hostPort模式。当Pod进入hostPort模式后，集群外就可以通过<strong>hostIP：hostPort</strong>的方式访问到这个Pod上。这里的hostIP指的是Pod所在节点的节点IP。hostPort的配置如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: hostPortDemo</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: hostPortDemo</span><br><span class="line">      ports:</span><br><span class="line">        - containerPort: 81</span><br><span class="line">          hostPort: 81</span><br></pre></td></tr></table></figure>
<h3 id="hostNetwork"><a href="#hostNetwork" class="headerlink" title="hostNetwork"></a>hostNetwork</h3><p>&emsp;&emsp;和hostPort一样，hostNetwork也需要配置在Pod上。当一个Pod配置了<strong>hostNetwork: true</strong>后，它可以看到自己所在节点上所有网卡的信息，可以监听流经所在节点的所有网络流量，就和其他运行在所在节点上的程序和进程一样。hostNetwork的配置如下所示：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: hostNetworkDemo</span><br><span class="line">spec:</span><br><span class="line">  hostNetwork: true</span><br><span class="line">  containers:</span><br><span class="line">    - name: hostNetworkDemo</span><br><span class="line">      image: hostNetworkDemo</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如前所说，hostNetwork使得Pod有机会监听所在节点的所有网络通信。Flannel就是通过这种方式在集群节点上建立Overlay网络来实现跨节点通信的。</p>
<p>&emsp;&emsp;不论是hostPort还是hostNetwork，这两种暴露Pod的方式都有一个问题，那就是每次Pod被重启后其IP地址都会是一个新的IP地址，而且如果没有特殊配置，那么Pod每次重启后有可能会被调度到不同的节点上，因此需要通过其他方式来获取新的IP地址以及Pod所在节点（如有必要的话）来完成访问。如果是hostNetwork，由于两个应用无法占用同一个端口，所以同一个节点上无法部署两个使用同一个端口的Pod。</p>
<h2 id="集群网络的构建过程"><a href="#集群网络的构建过程" class="headerlink" title="集群网络的构建过程"></a>集群网络的构建过程</h2><p>最后，我们会以Flannel为例、通过kubeadm的方式启动Kubernetes集群，简要总结下一个完整的Kubernetes集群网络是如何构建的：</p>
<ol>
<li>通过kubeadm初始化集群，指定CNI插件为Flannel，并在Flannel的配置文件中通过<strong>Network</strong>等参数配置集群的CIDR信息</li>
<li>Flannel配置的集群CIDR信息会保存在etcd中</li>
<li>当新的节点上线并尝试加入集群网络时，节点上的flanneld进程会向etcd申请本节点的Pod CIDR和其他完成通信所必须的地址信息，这些信息会被写在节点的subnet.env中。节点加入集群成功，准备好接受Master节点上scheduler的Pod调度。关于节点的规模大小，<strong>标准情况下每个节点最大仅容许同时运行110个Pod</strong>。因此每个节点的CIDR块大小约等于节点最大Pod数量的两倍，即每个节点拥有256个IP地址（“/24”）。这么做是为了减少在节点上创建、删除Pod时IP重复使用的概率，同时避免由于IP地址耗尽带来的Pod创建失败的问题</li>
<li>当节点接收到新的Pod创建请求时，节点上的CRI为Pod创建一个网络命名空间，之后CRI调用CNI完成网络的创建工作</li>
<li>CNI首先会调用bridge插件检查本节点上是否存在cbr0网桥，如果没有就创建。然后bridge插件会创建一个veth-pair，veth-pair的一端插入为Pod创建的网络命名空间中，另一端接入到cbr0网桥。换言之，<strong>节点上的cni0网桥是在创建节点上的第一个应用Pod时创建的</strong>。</li>
<li>CNI然后调用IPAM插件完成IP地址的申请和分配工作。IPAM会向CNI返回Pod的IP地址信息和网关IP（cbr0网桥为默认的Pod网关）</li>
<li>CNI会将申请到的IP地址配置到Pod的网络命名空间中，此时Pod就拥有了集群中唯一的IP地址。如果cbr0是当前请求中新创建的，那么bridge插件会将网关地址配置到cbr0网桥上</li>
<li>所有已经申请过的IP地址信息会存储到本地的/cni/network/cni0文件中</li>
</ol>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li><p><strong>fork和exec的定义和区别</strong></p>
<p>我们知道，进程是处于运行状态的程序的一个实例，程序运行在进程的上下文中。fork和exec都可以用来执行程序。fork会在新的子进程中运行运行相同的程序，新的子进程是父进程的一个复制品。fork函数调用一次返回两次，一次返回是在父进程中，返回的是子进程的PID，一次返回是在子进程中，返回0。</p>
<p>exec在当前进程的上下文中加载并运行一个新的程序，新的程序具有相同的PID，同时也继承了调用exec时当前进程已经打开的文件描述符列表。</p>
</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top;">云原生实验室. <a href="https://mp.weixin.qq.com/s/ctdvbasKE-vpLRxDJjwVMw" target="_blank" rel="noopener">Kubectl 创建 Pod 背后到底发生了什么？.</a>&quot; N.p., 21 June 2019. Web. 23 Apr. 2021.</span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top;">Lewis, Ian. &quot;<a href="https://www.ianlewis.org/en/almighty-pause-container" target="_blank" rel="noopener">The Almighty Pause Container.</a>&quot; <em>Ian Lewis</em>. N.p., 10 Oct. 2017. Web. 23 Apr. 2021.</span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top;">Denham, Tom, et al. &quot;<a href="https://github.com/flannel-io/flannel/blob/master/Documentation/backends.md#backends" target="_blank" rel="noopener">Backends.</a>&quot; <em>GitHub</em>. N.p., 29 Mar. 2017. Web. 1 May 2021.</span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top;">Cotton, Michelle, et al. &quot;Internet Assigned Numbers Authority (IANA) Procedures for the Management of the Service Name and Transport Protocol Port Number Registry.&quot; <em><a href="https://www.rfc-editor.org/rfc/pdfrfc/rfc6335.txt.pdf" target="_blank" rel="noopener">RFC 6335</a></em>(2011):1-33. RFC Editor. Web. 14 May 2021.</span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top;">Kubernetes contributors. &quot;<a href="https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/" target="_blank" rel="noopener">Create an External Load Balancer.</a>&quot; <em>Kubernetes</em>. N.p., 15 Sept. 2020. Web. 14 May 2021.</span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top;">Calico contributors. &quot;<a href="https://docs.projectcalico.org/about/about-kubernetes-services" target="_blank" rel="noopener">About Kubernetes Services.</a>&quot; <em>docs.projectcalico.org</em>. N.p., n.d. Web. 8 May 2021.</span></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline-block; vertical-align: top;">Kubernetes contributors. &quot;<a href="https://kubernetes.io/docs/concepts/services-networking/service/" target="_blank" rel="noopener">Service.</a>&quot; <em>Kubernetes</em>. N.p., 5 May 2018. Web. 8 May 2021.</span></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">8.</span><span style="display: inline-block; vertical-align: top;">Hannaford, Jamie. &quot;<a href="https://github.com/jamiehannaford/what-happens-when-k8s#what-happens-when--kubernetes-edition" target="_blank" rel="noopener">What Happens When ... Kubernetes Edition!</a>&quot; <em>GitHub</em>. N.p., 25 Sept. 2017. Web. 23 Apr. 2021.</span></li><li id="fn:9"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">9.</span><span style="display: inline-block; vertical-align: top;">Bryant, Randal E., and David O’Hallaron. 深入理解计算机系统. Trans. 贺莲. 3rd ed. 北京: 机械工业出版社, 2016. Print.</span></li><li id="fn:10"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">10.</span><span style="display: inline-block; vertical-align: top;">Lewis, Ian. &quot;<a href="https://www.ianlewis.org/en/what-are-kubernetes-pods-anyway" target="_blank" rel="noopener">What Are Kubernetes Pods Anyway?</a>&quot; <em>Ian Lewis</em>. N.p., 25 Aug. 2017. Web. 23 Apr. 2021.</span></li><li id="fn:11"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">11.</span><span style="display: inline-block; vertical-align: top;">Lewis, Ian. &quot;<a href="https://www.ianlewis.org/en/container-runtimes-part-4-kubernetes-container-run" target="_blank" rel="noopener">Container Runtimes Part 4: Kubernetes Container Runtimes &amp; CRI.</a>&quot; <em>Ian Lewis</em>. N.p., 26 Jan. 2019. Web. 23 Apr. 2021.</span></li><li id="fn:12"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">12.</span><span style="display: inline-block; vertical-align: top;">Lewis, Ian. &quot;<a href="https://www.ianlewis.org/en/container-runtimes-part-1-introduction-container-r" target="_blank" rel="noopener">Container Runtimes Part 1: An Introduction to Container Runtimes.</a>&quot; <em>Ian Lewis</em>. N.p., 6 Dec. 2017. Web. 23 Apr. 2021.</span></li><li id="fn:13"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">13.</span><span style="display: inline-block; vertical-align: top;">Betz, Mark. &quot;<a href="https://medium.com/google-cloud/understanding-kubernetes-networking-pods-7117dd28727" target="_blank" rel="noopener">Understanding Kubernetes Networking: Pods.</a>&quot; <em>medium.com</em>. N.p., 27 Oct. 2017. Web. 23 Apr. 2021.</span></li><li id="fn:14"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">14.</span><span style="display: inline-block; vertical-align: top;">意琦行. &quot;<a href="https://www.lixueduan.com/post/docker/04-container-network/" target="_blank" rel="noopener">Docker系列(四)---容器网络.</a>&quot; 指月小筑. N.p., 27 Feb. 2021. Web. 29 Apr. 2021.</span></li><li id="fn:15"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">15.</span><span style="display: inline-block; vertical-align: top;">Denham, Tom, et al. &quot;<a href="https://github.com/flannel-io/flannel/blob/master/Documentation/configuration.md#configuration" target="_blank" rel="noopener">Configuration.</a>&quot; <em>GitHub</em>. N.p., 29 Mar. 2017. Web. 1 May 2021.</span></li><li id="fn:16"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">16.</span><span style="display: inline-block; vertical-align: top;">Sookocheff, Kevin. &quot;<a href="https://sookocheff.com/post/kubernetes/understanding-kubernetes-networking-model/" target="_blank" rel="noopener">A Guide to the Kubernetes Networking Model.</a>&quot; <em>Kevin Sookocheff</em>. N.p., 11 July 2018. Web. 1 May 2021.</span></li><li id="fn:17"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">17.</span><span style="display: inline-block; vertical-align: top;">Larsen, Michael Vittrup. &quot;<a href="https://www.eficode.com/blog/debugging-kubernetes-networking" target="_blank" rel="noopener">Debugging Kubernetes Networking.</a>&quot; <em>eficode.com</em>. N.p., 7 Jan. 2019. Web. 1 May 2021.</span></li><li id="fn:18"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">18.</span><span style="display: inline-block; vertical-align: top;">Yingting, Huang. &quot;<a href="https://msazure.club/flannel-networking-demystify/" target="_blank" rel="noopener">Flannel Networking Demystify.</a>&quot; <em>msazure.club</em>. N.p., 1 June 2018. Web. 8 May 2021.</span></li><li id="fn:19"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">19.</span><span style="display: inline-block; vertical-align: top;">Xiao, Han. &quot;<a href="https://blog.laputa.io/kubernetes-flannel-networking-6a1cb1f8ec7c" target="_blank" rel="noopener">Kubernetes: Flannel Networking.</a>&quot; <em>Han’s blog</em>. N.p., 17 Oct. 2017. Web. 8 May 2021.</span></li><li id="fn:20"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">20.</span><span style="display: inline-block; vertical-align: top;">RancherLabs. &quot;<a href="https://www.infoq.cn/article/cn311s8qg6tuwsrxilq6" target="_blank" rel="noopener">在 Kubernetes 环境中，容器间如何进行网络通信.</a>&quot; <em>InfoQ</em>. N.p., 23 June 2020. Web. 8 May 2021.</span></li><li id="fn:21"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">21.</span><span style="display: inline-block; vertical-align: top;">shida_csdn. &quot;<a href="https://blog.csdn.net/shida_csdn/article/details/104334372" target="_blank" rel="noopener">Kubeadm 集群初始化参数 Pod-Network-Cidr 有什么作用？.</a>&quot; <em>CSDN</em>. N.p., 16 Feb. 2020. Web. 8 May 2021.</span></li><li id="fn:22"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">22.</span><span style="display: inline-block; vertical-align: top;">Nathani, Ronak. &quot;<a href="https://ronaknathani.com/blog/2020/08/how-a-kubernetes-pod-gets-an-ip-address/" target="_blank" rel="noopener">How a Kubernetes Pod Gets an IP Address.</a>&quot; <em>Ronak Nathani</em>. N.p., 21 Aug. 2020. Web. 9 May 2021.</span></li></ol></div><p><br><br><br><br></p></div></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Cloud Computing</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>network</tag>
        <tag>Pod Network</tag>
        <tag>Container Network</tag>
        <tag>pause</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s network之一：K8s网络模型与网络策略</title>
    <url>/2021/K8s-Network-Architecture-section-one.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;Kubernetes网络是Kubernetes得以正常工作的重要基础之一，这其中涉及到了包括但不限于IP地址划分、MAC地址学习、路由转发、服务发现、网络通信等诸多领域。借助于CNI接口及其实现产品，Kubernetes可以提供丰富的网络配置架构方案。关于Kubernetes网络，将会有一系列笔记，本篇是第一篇—关于Kubernetes网络模型和策略的初步学习，知其然，稍微知其所以然。出于篇幅考虑，相关的yaml配置不会在文章中出现，特殊情况除外，相关的yaml配置可以参考<a href="https://kubernetes.io/" target="_blank" rel="noopener">Kubernetes</a>官方文档。</p>
<a id="more"></a>
<p>&emsp;&emsp;<a href>2. K8s network之二：Kubernetes的域名解析、服务发现和外部访问</a> </p>
<p>&emsp;&emsp;<a href="/404.html">3.Linux网络在Kubernetes集群中的应用</a> </p>
<p>&emsp;&emsp;<a href>4.K8s network之四：Kubernetes集群通信的实现原理</a> </p>
<p>&emsp;&emsp;<a href>5.K8s network之五：Kubernetes集群Pod和Service之间通信的实现原理</a> </p>
<h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><p>&emsp;&emsp;Kubernetes网络模型遵循的一个核心原则是每个Pod都拥有一个唯一且独立的IP地址，只要彼此通信的Pod在同一个集群里，那么就可以通过IP地址的方式实现Pod间的直接访问而无需借助其他工具和手段，即使它们不在同一个node节点上。也就是说，同一个集群里的所有Pod形成了一个扁平的、可相互通信的网络组织。于是乎，每个Pod可以像虚拟机或者物理机实体那样执行诸如端口分配、命名、服务发现、负载均衡、应用配置和迁移等动作。因此，基于这个核心原则建立的模型就是“<strong>IP-Per-Pod</strong>”模型。</p>
<p>&emsp;&emsp;<strong>IP-Per-Pod</strong>模型认为，Pod之间会通过目标方的IP地址来完成通信和交互行为，无论是在Pod的内部还是外部，这个Pod的IP地址、端口等信息都是一致的，因此，Pod内部和外部之间、Pod和Pod之间、Node和Pod之间也就不再需要NAT操作来确保通信成功。没有了NAT之后，整个集群的通信性能会更好，源地址伪装的情况也就不复存在，因此具备了源地址可溯源的能力，对于集群维护和排障都有非常重要的帮助。而且这个模型可以很好的兼容现有的应用架构，如果我们的应用是运行在虚拟机上，每个虚拟机有自己的IP地址而且彼此之间可以相互通信，那么这个应用就可以很容易的迁移到Kubernetes集群上，降低成本和风险。这个模型还有另外一个好处，那就是同一个Pod内的容器之间共享了同一个网络命名空间，这些容器之间通过同一个IP地址对外发送消息，通过同一个IP地址接收来自Pod之外的消息。它们相互之间的访问可以通过localhost加端口的形式直接访问。在整个集群范围内，每个Node都有一个与其他Node节点无交集的IP地址段，这个IP地址段内的IP地址会拿来分配给该节点上的Pod使用。</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1623247049/BlogImages/CloudSerials/K8s-cluster-IP-allocation-demo.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 1 Kubernetes 集群网络IP分布 </div>
&emsp;
</div>

<p>为了保证集群的正常运行和工作，Kubernetes对集群网络提出了如下的要求：</p>
<ol>
<li>任意节点上的Pod可以在不借助NAT的情况下与任意节点上的任意Pod进行通信；</li>
<li>节点上的代理（诸如系统守护进程、kubelet等）可以在不借助NAT的情况下与该节点上的任意Pod进行通信；</li>
<li>处于一个节点的主机网络中的Pod可以在不借助NAT的情况下与任意节点上的任意Pod进行通信（当且仅当支持Pod运行在主机网络的平台上，比如Linux等）；</li>
<li>不论在Pod内部还是外部，该Pod的IP地址和端口信息都是一致的。</li>
</ol>
<p>在上述要求得到保证后，Kubernetes网络主要聚焦于两个任务—<strong>IP地址管理和路由</strong>，并致力于解决如下问题：</p>
<ol>
<li>同一个Pod内多个容器之间如何通信</li>
<li>同一个Node节点中多个Pod之间如何通信</li>
<li>不同Node节点上的多个Pod之间如何通信</li>
<li>Pod和Service之间如何通信</li>
<li>Pod和集群外的实体如何通信</li>
<li>Service和集群外的实体如何通信</li>
</ol>
<h2 id="Container-Network-Interface（CNI）"><a href="#Container-Network-Interface（CNI）" class="headerlink" title="Container Network Interface（CNI）"></a>Container Network Interface（CNI）</h2><p>&emsp;&emsp;众所周知，Kubernetes是由Google开源并维护的一个容器编排工具，是Google十多年容器技术应用经验的集大成之作。于是乎，支撑Kubernetes正常工作的公有云GCE（Google Compute Engine Network）自然满足上述提及的各种要求。但并非所有的Kubernetes集群都部署在GCE、AWS、Azure等公有云环境上，私有云的部署方案也日渐增多。在这种情况下，如何保证集群网络可以满足Kubernetes的要求就成为了一个首要问题。换句话说，Kubernetes仅关注和负责容器编排领域的相关事宜，而网络管理并不是它最核心的分内之事。起初，Kubernetes通过开发Kubenet来实现网络管理功能以提供满足要求的集群网络。Kubenet是一个非常简单、基础的网络插件实现。但它本身并不支持任何跨节点之间的网络通信和网络策略等高级功能，且仅适用于Linux系统，所以Kubernetes试图找到一个更优秀的方案来替代Kubenet。为了解决这个问题，CoreOs公司和Docker各自推出了<strong>CNI</strong>（Container Network Interface）和<strong>CNM</strong> (Container Network Model）规范，CNI以其完善的规范和优雅的设计击败了CNM，并成为了Kubernetes首选的网络插件接口规范。</p>
<p>&emsp;&emsp;CNI的基本思想是在容器运行时环境中创建容器时，先创建好网络命名空间（netns），然后调用CNI插件为这个网络命名空间配置网络，之后再启动容器内的进程。CNI通过Json Schema定义了容器运行环境和网络插件之间的接口声明，描述当前容器网络的配置和规范，尝试通过一种普适的方式来实现容器网络的标准化 。它仅专注于在创建容器时分配网络资源（IP、网卡、网段等）和在容器被回收时如何删除网络资源两个方面的能力。CNI作为Kubernetes和底层网络之间的一个抽象存在，屏蔽了底层网络实现的细节、实现了Kubernetes和具体网络实现方案的解耦，继而为Kubernetes建立一个满足其运行要求的网络组织结构，同时也克服了Kubenet不能实现跨主机容器间的相互通信等不足和短板。CNI凭借其轻便、实现成本小等优点，成功地被Kubernetes、rkt、Apache Mesos等项目所认可和采纳，各个公司和社区也发布了包括但不限于Flannel、Calico、Weave等CNI规范实现方案，进一步增强了CNI规范的影响力。</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1623247220/BlogImages/CloudSerials/K8s-CNI-Structure.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 2 CNI <sup id="fnref:1" style="font-size:80%;line-height:80%;"><a href="#fn:1" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[1]</span></a></sup> </div>
&emsp;
</div>

<p>&emsp;&emsp;如前所述，CNI规范只是一个规范，规定了如何连接容器编排系统（比如K8s）和网络插件以完成Pod网络管理。实际执行Pod网络管理的是遵循CNI规范的各个CNI网络插件，目前官方提供的CNI网络插件包括如下三类<sup id="fnref:2" style="font-size:80%;line-height:80%;"><a href="#fn:2" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[2]</span></a></sup>：</p>
<p><strong>Main: interface-creating</strong></p>
<ul>
<li>bridge: 创建一个桥接网络，并将宿主机和容器加入到这个桥接网络中</li>
<li>ipvlan: 在容器中加入一个<a href="https://www.kernel.org/doc/Documentation/networking/ipvlan.txt" target="_blank" rel="noopener">ipvlan</a>接口</li>
<li>loopback: 设置环回接口的状态为up状态</li>
<li>macvlan: 创建一个新的mac地址，并将所有到该地址的流量转发到容器</li>
<li>ptp: 创建一个新的veth对</li>
<li>vlan: 分配一个vlan设备</li>
<li>host-device: 将宿主机现有的网络接口移到容器内。</li>
</ul>
<p><strong>IPAM: IP address allocation</strong></p>
<ul>
<li>dhcp: 在宿主机上运行一个daemon进程并代表容器发起DHCP请求。</li>
<li>host-local: 维护一个已分配IP的本地数据库</li>
<li>static: 向容器分配一个静态的IPv4/IPv6地址，这个地址仅用于调试目的。</li>
</ul>
<p><strong>Meta: other plugins</strong></p>
<ul>
<li>flannel: 根据flannel配置文件生成一个网络接口</li>
<li>tuning: 调整一个已有网络接口的sysctl参数</li>
<li>portmap: 一个基于iptables的端口映射插件，将宿主机地址空间的端口映射到容器中</li>
<li>bandwidth: 通过流量控制工具tbf来实现带宽限制</li>
<li>sbr: 为接口配置基于源IP地址的路由</li>
<li>firewall: 一个借助iptables或者firewalld来添加规则来限制出入容器流量的防火墙插件。</li>
</ul>
<p>&emsp;&emsp;针对这三种类型的插件，官方都提供了一些内置的实现方案可供用户直接使用。Main插件也称为“网络插件（NetPlugin）”，它是一个由容器编排系统调用的可执行文件，实现某种特定的网络功能，负责创建/删除网络、向容器的网络空间插入一个网络接口以及向网络添加/删除容器，专注于连通容器与容器之间以及容器和宿主机之间的通信。</p>
<p>&emsp;&emsp;为网络接口分配和维护IP地址以及配置与该接口相关的路由信息是CNI插件的一个重要职责，这使得CNI插件变得更加灵活的同时也带来了很大的负担。诸多CNI插件为了向用户提供期望的IP管理功能（诸如DHCP、HOST-LOCAL等）可能会使用相同的代码实现。为了减轻CNI插件的负担，也为了让IP管理策略和前述的NetPlugin插件的职责和功能相互独立，于是便定义了一种新的插件类型—<strong>IPAM</strong>（IP Address Management）。IPAM不提供网络功能，仅负责创建/删除IP地址池以及分配/回收容器的IP地址。IPAM由Main插件调用，并向Main插件提供接口的IP、子网、网关、路由等信息，与Main插件协同完成工作。IPAM的独立使得各个网络插件可以基于自己的实际需要和期望选择最适合自己的IPAM策略。</p>
<p>&emsp;&emsp;和Main插件一样，IPAM也是一个可执行文件，通过变量CNI_PATH指定IPAM的二进制文件位置，和Main插件共享相同的环境变量，并且通过stdin和stdout接收网络配置和返回结果输出。如果执行结果是成功状态，那么会返回一个0标识执行状态，并将成功执行的结果类型输出到stdout。</p>
<p>&emsp;&emsp;Meta插件不实现任何网络功能，不参与IP地址分配和回收，它调用其他网络工具或者插件完成一些管理或者测试功能。</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1623247301/BlogImages/CloudSerials/CNI-Plugins-Dependency.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 3 CNI插件依赖关系</div>
&emsp;
</div>

<p>&emsp;&emsp;在上述的三个插件中，Main插件是最重要的一个，由它来完成创建虚拟网络、为Pod生成网络接口设备、将Pod接入网络等核心任务。除了上面的提到的几种内置实现方案，诸多公司和社区也提供了遵循CNI规范的第三方插件实现，他们中的大多数属于Main插件类型，致力于提供Netplugin功能，用来提供配置容器接口和网络。也有不少方案甚至能够支持Kubernetes的网络策略。这些第三方插件实现常用的网络架构有Overlay网络和Underlay网络两大类：</p>
<ul>
<li><strong>Overlay 网络:</strong> 一个建立在现有物理网络之上的虚拟的、逻辑的网络。Overlay网络是建立在已有物理网络上的虚拟网络，具有独立的控制和转发平面，对于连接到Overlay的终端设备（例如服务器）来说，物理网络是透明的，从而可以实现承载网络（物理网络）和业务网络（逻辑网络）的分离。</li>
<li><strong>Underlay 网络：</strong>就是传统IT基础设施网络架构，由交换机、路由器、网关等设备主组成，借助以太网协议、路由协议和VLAN协议等诸多协议完成网络通信和维护。此外，它还是Overlay网络的底层支撑网络，为Overlay网络提供数据通信服务。在容器技术中，Underlay网络特指借助驱动程序将宿主机的底层网络接口直接暴露给容器使用的一种网络构建技术，常用的实现方案包括MacVLAN、IP VLAN 和直接路由等。</li>
</ul>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1623248224/BlogImages/CloudSerials/Overlay-Network-Demo-W.webp" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 4 Overlay 网络架构</div>
&emsp;
</div>

<p>&emsp;&emsp;Overlay借助VXLAN、UDP、IPIP、GRE等隧道协议建立通信隧道，通过隧道协议报文封装边缘设备之间的通信报文（二层的以太网帧或者三层的IP数据包）来构建虚拟网络。隧道转发数据的实质就是将通信设备的通信报文封装成各自边缘设备之间的报文，通过建立在边缘设备之间的网络隧道完成数据传输。这种方案只需要相互通信的边缘设备之间支持隧道协议即可，对底层网络没有任何特殊要求。Overylay网络通常由两个平面构成：控制平面和数据平面。控制平面专注于如下三个职责：</p>
<ol>
<li>服务发现。边缘设备如何感知其他边缘设备的存在，以便建立Overlay隧道</li>
<li>地址通告和映射。边缘设备如何交换其学习到的可达信息（包括但不限于Mac、IP以及其他相关地址信息）</li>
<li>隧道管理。这里需要SDN控制器的参与，由于SDN控制器了解整个网络的拓扑结构，便可以实现基于控制器的地址学习，提高了可靠性和扩展性</li>
</ol>
<p>而Overlay的数据平面则提供数据封装功能，并通过底层的物理承载网络实现数据传输。</p>
<p>&emsp;&emsp;上述协议中，<strong>VXLAN</strong>（Virtual Extensible LAN，虚拟可扩展局域网）是目前最流行的构建Overlay网络隧道的协议之一，是由ITEF定义的NVO3（Network Virtualization Over Layer 3）标准技术之一，采用<strong>L2 over L4（MAC-in-UDP）</strong>的报文封装格式，将二层报文用三层协议进行封装，依托UDP层构建overlay逻辑网络，使逻辑网络与物理网络解耦，满足快速变化的组网需求。VXLAN这类隧道网络的一个特点是对原有的网络架构影响小，不需要对原网络做任何改动，就可在原网络的基础上构建一层新的网络。VXLAN有点类似于VLAN，但是提供了比VLAN更好的灵活性和能力，相较于VLAN最多只能提供4096个网络ID而言，VXLAN可以提供最多16777216个网络ID（即 $2 ^ {24}$）。VXLAN的基本模型如下图所示：</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1623247382/BlogImages/CloudSerials/VXLAN-Network-Model.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 5 VXLAN网络工作模型</div>
&emsp;
</div>

<p>VXLAN主要有如下几个部分/概念组成：</p>
<ul>
<li>VTEP（VXLAN Tunnel End Point，VXLAN隧道端点）。VTEP是隧道的端点设备，由VTEP负责建立隧道。VXLAN的相关处理都在VTEP上进行，包括但不限于识别数据帧所属的VXLAN，数据帧的封装/解封装等。每个VTEP提供两个接口，一个接口负责本地主机桥接供能，另一个连接物理核心网络提供隧道建立和VXLAN封装/解封装等服务。</li>
<li>VNI（VXLAN Network Identifier，VXLAN网络识别号）。用来标识一个二层网络分段，一个VNI代表一个VXLAN网络段，可以分配一个用户/租户使用。不同的VNI之间不能直接通信。VNI的范围最大可达16777216（即 $2 ^ {24}$）。</li>
<li>VXLAN Tunnel。隧道是一个物理上没有对应实体的逻辑概念，两个VTEP设备之间建立隧道后便可以认为它们在直接通信。VXLAN报文在隧道之间传输。</li>
<li>BD（Broadcast Domain，广播域）。用来在VXLAN中划分广播域，在同一个广播域中的设备可以直接进行二层通信。同时，一个VNI映射一个BD。</li>
</ul>
<p>和其他协议一样，VXLAN在工作过程中也需要遵循一定的规范。在RFC 7348 <sup id="fnref:3" style="font-size:80%;line-height:80%;"><a href="#fn:3" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[3]</span></a></sup>中，给出了VXLAN报文的格式规范：</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1623247433/BlogImages/CloudSerials/VXLAN-Frame-Format-with-IPv4-Outer-Header.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 6 VXLAN帧格式（IPv4格式）</div>
&emsp;
</div>

<p>Inner Ethernet Header和Payload属于原生的二层以太网帧结构。</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1623247519/BlogImages/CloudSerials/VXLAN-Frame-Format-with-IPv4-Outer-Header-Simple.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 7 VXLAN帧格式（IPv4格式）抽象</div>
&emsp;
</div>

<p>&emsp;&emsp;VXLAN在正式通信之间需要先保证VTEP之间相互了解对方的存在及地址等相关信息。特别是当VTEP之间是首次通信时，由于本地的MAC表中并没有维护对方的MAC地址信息，所以需要通过ARP请求来进行MAC地址的学习。如果两个VTEP处于同一个VNI时，MAC学习过程如下：</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1623248080/BlogImages/CloudSerials/MAC-Learning-In-a-VNI.webp" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 8 VXLAN 同一VNI下VTEP的MAC学习过程</div>
&emsp;
</div>

<p>在完成MAC学习后，VTEP设备之间即可根据学习到的MAC地址信息相互通信。</p>
<p>&emsp;&emsp;如果两个VTEP不在同一个VNI时，需要借助三层网关设备完成通信操作，具体流程如下：</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1623933012/BlogImages/CloudSerials/MAC-Learning-In-Different-VNI.webp" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 9 VXLAN 不同一VNI下VTEP的通信过程</div>
&emsp;
</div>

<p>Kubernetes目前支持两种网络插件的实现：</p>
<ul>
<li><p>CNI插件：根据CNI规范实现其接口，以与插件提供者进行对接。</p>
</li>
<li><p>kubenet插件：使用bridge和host-local CNI插件实现一个基本的cbr0。</p>
</li>
</ul>
<p>为了在Kubernetes集群中使用网络插件，需要在kubelet服务的启动参数上设置下面两个参数：</p>
<ul>
<li>—network-plugin-dir：kubelet启动时扫描网络插件的目录。</li>
<li>—network-plugin：网络插件名称，对于CNI插件，设置为cni即可，无须关注—network-plugin-dir的路径。对于kubenet插件，设置为kubenet，目前仅实现了一个简单的cbr0 Linux网桥。</li>
</ul>
<p>在设置—network-plugin=”cni”时，kubelet还需设置下面两个参数。</p>
<ul>
<li>—cni-conf-dir：CNI插件的配置文件目录，默认为/etc/cni/net.d。该目录下配置文件的内容需要符合CNI规范。</li>
<li>—cni-bin-dir：CNI插件的可执行文件目录，默认为/opt/cni/bin。</li>
</ul>
<p>&emsp;&emsp;Kubernetes借助CNI插件体系组合满足需要的网络插件完成网络配置和维护功能。在创建或删除Pod时，Kubelet在默认的<strong>—cni-conf-dir</strong>目录下查找JSON格式的CNI配置文件，基于该配置文件中各插件的type属性（指明要调用的网络插件的名称）到<strong>—cni-bin-dir</strong>中查找相关插件的二进制可执行文件，执行它们以完成创建虚拟设备接口到相关的底层网络、为其设置IP地址、路由信息并将其添加到Pod的网络命名空间等操作。</p>
<p>&emsp;&emsp;在创建Pod的过程中，当Scheduler选定了一个Node节点来运行新创建的Pod时，该节点上的kubelet收到消息后会完成一个Pod的创建工作，当涉及到网络部分时，它首先会读取刚才我们所说的配置目录中的配置文件，获得将要使用的插件的相关信息。然后进入插件的可执行文件的目录来执行指明的 CNI 插件的二进制文件，由 CNI 插件进入 Pod 的网络空间去配置 Pod 的网络。</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1624198377/BlogImages/CloudSerials/kubelet-cri-cni-flowchart.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 10 kubelet调用CRI和CNI流程 <sup id="fnref:4" style="font-size:80%;line-height:80%;"><a href="#fn:4" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[4]</span></a></sup></div>
&emsp;
</div>

<p>&emsp;&emsp;在面对诸多的CNI插件实现时，我们需要结合自身的实际情况和未来期望来选择一个最合适我们自己的产品。在进行评估时可以从如下角度来选择：</p>
<ol>
<li><p>应用场景</p>
<ol>
<li><p>虚拟化环境</p>
<p> 虚拟环境（以OpenStack为例）因实现方案不同可能会对网络产生很多限制，比如不允许L2访问、限制机器可以使用的IP范围等。在这种网络限制比较严格的环境中，Overlay插件是更好的选择。常见的包括但不限于Flannel-vxlan, Calico-ipip, Weave等。</p>
</li>
<li><p>物理机环境</p>
<p> 物理机因为是真实的物理环境，对网络的限制相较于虚拟化环境来说会宽松很多。所以除了Overlay之外也可以选择Underlay或者直接路由模式。这种环境下可以考虑Calico-bgp等。</p>
</li>
<li><p>公有云环境</p>
<p> 公有云通常会考虑适配容器来提高容器性能，因此会提供一些CNI插件来实现兼容和性能最大化。如果有，选择公有云提供的CNI插件会是更优解。</p>
</li>
</ol>
</li>
<li><p>功能需要</p>
<ol>
<li><p>安全相关</p>
<p> 尽管Kubernetes原生支持网络策略（Network Policy），但是不是所有的CNI插件都实现了这个功能。所以如果需要网络策略的相关服务，就可以过滤掉那些不支持网络策略的插件了。常见的支持网络策略的插件包括但不限于Calico、Weave等。</p>
</li>
<li><p>是否需要与集群外通信</p>
<p> 如果Kubernetes上的应用有对应的非容器化版本，或者说Kubernetes上的应用需要和非云环境下的应用通信，那么就需要考虑集群外通信能力。此时就需要考虑Underlay网络架构而非Overlay网络架构。<a href="https://github.com/hustcat/sriov-cni" target="_blank" rel="noopener">sriov-cni</a>保证了Pod和虚拟机或者物理机可以在同一层网络，Calico的BGP模式实现了处于不同网段的集群网络和非集群网络（物理机、虚拟机）可以通过BGP路由机制实现相互通信。</p>
</li>
<li><p>是否需要Kubernetes的服务发现和负载均衡能力</p>
<p> Kubernetes的Service机制实现了高效的服务发现和负载均衡机制，但并非所有的CNI插件都能支持这两种能力。</p>
</li>
</ol>
</li>
<li><p>性能考量</p>
<ol>
<li><p>Pod的创建性能</p>
<p> Pod的创建性能限制了在诸如业务高峰等场景下需要紧急扩容来应对海量流量以及创建大量Pod的能力。Overlya和直接路由模式只需要通过调用内核接口就可以执行虚拟化操作完成创建Pod所需要的网络组件，所以速度会非常快。相反，Underlay需要创建所需的底层物理网络资源，所以相对来说会慢一些。</p>
</li>
<li><p>Pod的网络性能</p>
<p> 由于Overlay网络在相互通信时需要额外的封装/解封装操作，以及由此带来的一些资源开销，所以传输性能会差一些。如果对这些开销敏感，那么就需要考虑Underlay网络或者路由模式。</p>
</li>
</ol>
</li>
</ol>
<h2 id="网络策略"><a href="#网络策略" class="headerlink" title="网络策略"></a>网络策略</h2><p>&emsp;&emsp;在Kubernetes中，所有的Pod之间默认是允许通信的，但是在实际的生产业务中普遍存在允许满足某些条件的Pod访问的同时拒绝满足另一些条件的Pod的访问，这个时候就需要引入Network Policy（网络策略）来提供Pod访问的准入控制。Kubernetes从v1.3开始引入NetworkPolicy资源对象来定义网络策略，使得Kubernetes可以在<strong>IP地址/端口级别（OSI第三/四层）</strong>实现更为精细的流量控制，实现租户隔离机制。与此相对应的，还需要有一个Policy Controller（策略控制器）协作完成实际的网络准入控制。需要注意的是，控制器的实现是由第三方网络组件而非Kubernetes完成的，目前<a href="https://www.projectcalico.org" target="_blank" rel="noopener">Calico</a>、<a href="https://cilium.io" target="_blank" rel="noopener">Cilium</a>、<a href="https://www.kube-router.io" target="_blank" rel="noopener">Kube-router</a>、<a href="https://romana.io" target="_blank" rel="noopener">Romana</a>、<a href="https://www.weave.works/oss/net/" target="_blank" rel="noopener">Weave Net</a>等开源项目均支持网络策略的实现。就Kubernetes暴露的API而言，Kubernetes的网络策略实现了如下特性：</p>
<ul>
<li>策略可以是命名空间级别的</li>
<li>策略通过标签选择器作用于Pod上</li>
<li>策略规则可以基于Pods、命名空间、CIDR进行设置</li>
<li>策略规则可以基于协议（TCP/UDP/SCTP）、端口号进行设置（注：SCTP自Kubernetes v1.12后支持）</li>
</ul>
<p>&emsp;&emsp;网络策略规定Pod的流量分为流入流量（Ingress）和流出流量（Egress）两个类型，每个类型的流量有允许通过和禁止通过两个动作。默认情况下（也就是没有设置任何网络策略）Pod之间可以任意互联互通。但是一旦针对某个特定的Pod设置了网络策略，那么只有满足策略声明的流量允许通过。网络策略的基本工作原理如下图所示：</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1623247691/BlogImages/CloudSerials/K8s-Network-Policy-Basic.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 11 Kubernetes网络策略基本工作原理 <sup id="fnref:5" style="font-size:80%;line-height:80%;"><a href="#fn:5" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[5]</span></a></sup></div>
&emsp;
</div>
&emsp;&emsp;以Calico为例，Calico在每个工作节点都借助Linux 内核实现了一个高效的虚拟路由器vRouter来负责数据通信。每个 vRouter 都通过BGP协议把在本节点上运行的Pod的路由信息向整个Calico网络广播，并自动设置到达其他节点的路由转发规则。Calico保证所有Pod之间的数据流量都是通过IP路由的方式完成通信。Calico节点组网时可以直接利用数据中心的网络结构，不需要额外的NAT、隧道或者Overlay Network，由于不存在额外的封包解包，所以一定程度上能够有效提高网络通信效率。

<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1623247761/BlogImages/CloudSerials/Calico-Network-Policy-Implement.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 12 Calico网络策略实现原理 <sup id="fnref:6" style="font-size:80%;line-height:80%;"><a href="#fn:6" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[6]</span></a></sup></div>
&emsp;
</div>
网络策略的配置文件如下所示：

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: NetworkPolicy</span><br><span class="line">metadata:</span><br><span class="line">  name: NP-NRL</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  podSelector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      role: db-MySQL</span><br><span class="line">  policyTypes:</span><br><span class="line">  - Ingress</span><br><span class="line">  - Egress</span><br><span class="line">  ingress:</span><br><span class="line">  - from:</span><br><span class="line">    - ipBlock:</span><br><span class="line">        cidr: 172.17.0.0/16</span><br><span class="line">        except:</span><br><span class="line">        - 172.17.1.0/24</span><br><span class="line">    - namespaceSelector:</span><br><span class="line">        matchLabels:</span><br><span class="line">          project: backend-service</span><br><span class="line">    - podSelector:</span><br><span class="line">        matchLabels:</span><br><span class="line">          role: bk-service</span><br><span class="line">    ports:</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 80</span><br><span class="line">  egress:</span><br><span class="line">  - to:</span><br><span class="line">    - ipBlock:</span><br><span class="line">        cidr: 10.0.0.0/24</span><br><span class="line">    ports:</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 5978</span><br></pre></td></tr></table></figure>

<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1623330489/BlogImages/CloudSerials/K8s-NetworkPolicy-Demo.webp" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center"><br>图 - 13 Network Policy 配置实例</div>
&emsp;
</div>

<p>&emsp;&emsp;关于<strong>namespaceSelector</strong>和<strong>podSelector</strong>，需要作一些说明：在入站和出站配置中，<strong>namespaceSelector</strong>和<strong>podSelector</strong>可以单独设置，也可以组合配置。如果仅配置<strong>podSelector</strong>，则表示podSelector指定的Pod与spec部分中指定的Pod处在同一个命名空间；如果两者都有配置，则指的是<strong>namespaceSelector</strong>指定的命名空间下的符合podSelector规则的Pod会被选中参与策略控制行为。</p>
<p>&emsp;&emsp;Kubernetes还提供了命名空间级别的网络策略配置，以方便管理员对整个Namespace进行统一的网络策略设置。默认提供了如下5种类型的控制策略：</p>
<ul>
<li><p>默认拒绝所有入站流量</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: NetworkPolicy</span><br><span class="line">metadata:</span><br><span class="line">  name: default-deny-ingress</span><br><span class="line">spec:</span><br><span class="line">  podSelector: &#123;&#125;</span><br><span class="line">  policyTypes:</span><br><span class="line">  - Ingress</span><br></pre></td></tr></table></figure>
<p>  创建选择所有Pod但不允许任何进入这些Pod的入站流量的名为<strong>default-deny-ingress</strong>策略。这样即使Pod没有选择其他策略，也会被隔离。 此策略不会更改默认的出口隔离行为。</p>
</li>
<li><p>默认允许所有入站流量</p>
  <figure class="highlight"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: NetworkPolicy</span><br><span class="line">metadata:</span><br><span class="line">  name: allow-all-ingress</span><br><span class="line">spec:</span><br><span class="line">  podSelector: &#123;&#125;</span><br><span class="line">  ingress:</span><br><span class="line">  - &#123;&#125;</span><br><span class="line">  policyTypes:</span><br><span class="line">  - Ingress</span><br></pre></td></tr></table></figure>
<p>  创建允许所有流量进入某个名字空间中的所有 Pod的名为<strong>allow-all-ingress</strong>的策略。</p>
</li>
<li><p>默认拒绝所有出站流量</p>
  <figure class="highlight"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: NetworkPolicy</span><br><span class="line">metadata:</span><br><span class="line">  name: default-deny-egress</span><br><span class="line">spec:</span><br><span class="line">  podSelector: &#123;&#125;</span><br><span class="line">  policyTypes:</span><br><span class="line">  - Egress</span><br></pre></td></tr></table></figure>
<p>  创建选择所有Pod但不允许来自这些Pod的任何出站流量的名为<strong>default-deny-egress</strong>的策略。此策略可以确保即使没有被其他任何策略选择的 Pod 也不会被允许流出流量。 此策略不会更改默认的入站流量隔离行为。</p>
</li>
<li><p>默认允许所有出站流量</p>
  <figure class="highlight"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: NetworkPolicy</span><br><span class="line">metadata:</span><br><span class="line">  name: allow-all-egress</span><br><span class="line">spec:</span><br><span class="line">  podSelector: &#123;&#125;</span><br><span class="line">  egress:</span><br><span class="line">  - &#123;&#125;</span><br><span class="line">  policyTypes:</span><br><span class="line">  - Egress</span><br></pre></td></tr></table></figure>
<p>  创建允许所有流量流出某个名字空间中的所有 Pod的名为<strong>allow-all-egress</strong>的策略。</p>
</li>
<li><p>默认拒绝所有流量（入站和出站）</p>
  <figure class="highlight"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: NetworkPolicy</span><br><span class="line">metadata:</span><br><span class="line">  name: default-deny-all</span><br><span class="line">spec:</span><br><span class="line">  podSelector: &#123;&#125;</span><br><span class="line">  policyTypes:</span><br><span class="line">  - Ingress</span><br><span class="line">  - Egress</span><br></pre></td></tr></table></figure>
<p>  创建选择所有Pod但不允许来自这些Pod的任何入站和出站流量的名为<strong>default-deny-all</strong>的策略。</p>
</li>
</ul>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li><p><strong>源地址伪装和端口转发</strong></p>
<p>源地址伪装：NAT设备将经过源主机发出的包转发到指定的接收方，同时将通过的数据包的源地址更改为NAT设备的接口地址。当返回的数据包到达时，会将目的地址修改为源主机的地址并将该数据包转发给源主机。地址伪装可以实现局域网多个地址共享一个公网地址与外界通信。</p>
<p>端口转发：也可以称之为目的地址转换或端口映射。通过端口转发，将指定IP地址及端口的流量转发到相同计算机上的不同端口，或不同计算机上的端口上。一般而言，公司/机构内网的服务器会采用私网地址构建网络，然后通过端口转发将外部用户的请求转发到内网的某个特定位置上，以便让外部能够访问到内网的服务器。</p>
</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top;">Lee, Calcote. &quot;<a href="https://thenewstack.io/container-networking-landscape-cni-coreos-cnm-docker/" target="_blank" rel="noopener">THE CONTAINER NETWORKING LANDSCAPE: CNI FROM COREOS AND CNM FROM DOCKER.</a>&quot; <em>The New Stack</em>. N.p., 16 Sept. 2016. Web. 13 Apr. 2021.</span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top;">cni-dev. &quot;<a href="https://github.com/containernetworking/plugins#plugins" target="_blank" rel="noopener">Github - Containernetworking/Plugins: Some Reference and Example Networking Plugins, Maintained by the CNI Team.</a>&quot; <em>Github</em>. N.p., n.d. Web. 11 Apr. 2021.</span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top;">Mahalingam, Mallik, et al. &quot;Virtual eXtensible Local Area Network (VXLAN): A Framework for Overlaying Virtualized Layer 2 Networks over Layer 3 Networks.&quot; ITEF <a href="https://www.rfc-editor.org/rfc/pdfrfc/rfc7348.txt.pdf" target="_blank" rel="noopener">RFC 7348</a>, August 2014.</span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top;">Nathani, Ronak. &quot;<a href="https://ronaknathani.com/blog/2020/08/how-a-kubernetes-pod-gets-an-ip-address/#" target="_blank" rel="noopener">How a Kubernetes Pod Gets an IP Address.</a>&quot; <em>Ronak Nathani</em>. N.p., 21 Aug. 2020. Web. 14 Apr. 2021.</span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top;">龚正, et al. <em>Kubernetes权威指南：从Docker到Kubernetes实践全接触</em>. 4th ed. 北京: 电子工业出版社, 2019. Print.</span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top;">高庆. '<a href="https://www.kubernetes.org.cn/4960.html" target="_blank" rel="noopener">Calico on Kubernetes 从入门到精通.</a>&quot; <em>Kubernetes中文社区</em>. N.p., 22 Dec. 2018. Web. 10 Apr. 2021.</span></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline-block; vertical-align: top;">CE资料. “<a href="https://forum.huawei.com/enterprise/zh/thread-334207.html" target="_blank" rel="noopener">【华为悦读汇】技术发烧友：认识VXLAN.</a>” <em>华为企业互动社区</em>. N.p., 23 Nov. 2015. Web. 15 Apr. 2021.</span></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">8.</span><span style="display: inline-block; vertical-align: top;">HUAWEI contributors. “<a href="https://support.huawei.com/enterprise/en/doc/EDOC1100023542?section=j015" target="_blank" rel="noopener">Overlay Networking - Huawei DCN Design Guide.</a>” <em>HUAWEI Enterprise</em>. N.p., 14 June 2018. Web. 15 Apr. 2021.</span></li><li id="fn:9"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">9.</span><span style="display: inline-block; vertical-align: top;">Luksa, Marko. <em>Kubernetes in Action中文版</em>. Trans. 七牛容器云团队. 1st ed. 北京: 电子工业出版社, 2019. Print.</span></li><li id="fn:10"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">10.</span><span style="display: inline-block; vertical-align: top;">杜军. <em>Kubernetes网络权威指南：基础、原理与实践</em>. 1st ed. 北京: 电子工业出版社, 2019. Print.</span></li><li id="fn:11"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">11.</span><span style="display: inline-block; vertical-align: top;">闫健勇, et al. <em>Kubernetes权威指南：企业级容器云实战</em>. 1st ed. 北京: 电子工业出版社, 2018. Print.</span></li><li id="fn:12"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">12.</span><span style="display: inline-block; vertical-align: top;">马永亮. <em>Kubernetes进阶实战</em>. 2nd ed. 北京: 机械工业出版社, 2019. Print.</span></li><li id="fn:13"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">13.</span><span style="display: inline-block; vertical-align: top;">溪恒. &quot;<a href="https://www.infoq.cn/article/6mdfWWGHzAdihiq9lDST?utm_source=related_read_bottom&amp;utm_medium=article" target="_blank" rel="noopener">从零开始入门 K8s：理解 CNI 和 CNI 插件.</a>&quot; <em>InfoQ</em>. N.p., 26 Mar. 2020. Web. 15 Apr. 2021.</span></li><li id="fn:14"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">14.</span><span style="display: inline-block; vertical-align: top;">Kubernetes contributors. &quot;<a href="https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/" target="_blank" rel="noopener">Network Plugins.</a>&quot; <em>Kubernetes</em>. N.p., 5 May 2018. Web. 15 Apr. 2021.</span></li><li id="fn:15"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">15.</span><span style="display: inline-block; vertical-align: top;">Project Calico contributors. &quot;<a href="https://docs.projectcalico.org/reference/architecture/overview" target="_blank" rel="noopener">Component Architecture.</a>&quot; <em>Project Calico</em>. N.p., n.d. Web. 15 Apr. 2021.</span></li><li id="fn:16"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">16.</span><span style="display: inline-block; vertical-align: top;">Balkan, Ahmet Alp . &quot;<a href="https://github.com/ahmetb/kubernetes-network-policy-recipes#kubernetes-network-policy-recipes" target="_blank" rel="noopener">Kubernetes Network Policy Recipes.</a>&quot; <em>GitHub</em>. N.p., 30 July 2017. Web. 10 Apr. 2021.</span></li><li id="fn:17"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">17.</span><span style="display: inline-block; vertical-align: top;">Kubernetes contributors. &quot;<a href="https://kubernetes.io/blog/2016/09/high-performance-network-policies-kubernetes/" target="_blank" rel="noopener">High Performance Network Policies in Kubernetes Clusters.</a>&quot; <em>Kubernetes</em>. N.p., 26 Sept. 2016. Web. 10 Apr. 2021.</span></li><li id="fn:18"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">18.</span><span style="display: inline-block; vertical-align: top;">Kubernetes contributors. &quot;<a href="https://kubernetes.io/docs/concepts/services-networking/network-policies/" target="_blank" rel="noopener">Network Policies.</a>&quot; <em>Kubernetes</em>. N.p., 15 July 2018. Web. 13 Apr. 2021.</span></li><li id="fn:19"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">19.</span><span style="display: inline-block; vertical-align: top;">Kubernetes contributors. &quot;<a href="https://kubernetes.io/blog/2016/01/why-kubernetes-doesnt-use-libnetwork/" target="_blank" rel="noopener">Why Kubernetes Doesn’t Use Libnetwork.</a>&quot; <em>Kubernetes Blog</em>. N.p., 14 Jan. 2016. Web. 14 Apr. 2021.</span></li><li id="fn:20"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">20.</span><span style="display: inline-block; vertical-align: top;">马旻. &quot;<a href="https://www.cisco.com/web/CN/partners/industry/pdf/culture_finance_01.pdf" target="_blank" rel="noopener">虚拟叠加网络--数据中心私有云建设的基石.</a>&quot; N.p., Apr. 2014. Web. 14 Apr. 2021.</span></li><li id="fn:21"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">21.</span><span style="display: inline-block; vertical-align: top;">马旻. &quot;<a href="https://www.cisco.com/web/CN/partners/industry/pdf/manufacture_solutions_06.pdf" target="_blank" rel="noopener">VxLAN技术 探讨和方案选择.</a>&quot; N.p., Mar. 2014. Web. 14 Apr. 2021.</span></li><li id="fn:22"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">22.</span><span style="display: inline-block; vertical-align: top;">Hedlund, Brad. &quot;<a href="https://bradhedlund.com/2012/10/06/mind-blowing-l2-l4-network-virtualization-by-midokura-midonet/" target="_blank" rel="noopener">Mind Blowing L2-L4 Network Virtualization by Midokura MidoNet.</a>&quot; <em>Brad Hedlund</em>. N.p., 6 Oct. 2012. Web. 14 Apr. 2021.</span></li><li id="fn:23"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">23.</span><span style="display: inline-block; vertical-align: top;">Hedlund, Brad. &quot;<a href="https://bradhedlund.com/2011/10/12/network-virtualization-is-like-a-big-virtual-chassis/" target="_blank" rel="noopener">Network Virtualization is like a big virtual chassis.</a>&quot; <em>Brad Hedlund</em>. N.p., 12 Oct. 2011. Web. 14 Apr. 2021.</span></li><li id="fn:24"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">24.</span><span style="display: inline-block; vertical-align: top;">Wikipedia contributors. &quot;<a href="https://en.wikipedia.org/wiki/Virtual_Extensible_LAN" target="_blank" rel="noopener">Virtual Extensible LAN.</a>&quot; Wikipedia, The Free Encyclopedia. Wikipedia, The Free Encyclopedia, 17 May. 2021. Web. 20 Jun. 2021.</span></li><li id="fn:25"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">25.</span><span style="display: inline-block; vertical-align: top;">Spreitzer, Mike, et al. &quot;<a href="https://github.com/containernetworking/cni/blob/master/SPEC.md#container-network-interface-cni-specification" target="_blank" rel="noopener">Container Network Interface (CNI) Specification.</a>&quot; <em>GitHub</em>. N.p., 30 May 2015. Web. 14 Apr. 2021.</span></li><li id="fn:26"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">26.</span><span style="display: inline-block; vertical-align: top;">乾坤李. &quot;<a href="https://qiankunli.github.io/2018/10/11/cni.html" target="_blank" rel="noopener">CNI——容器网络是如何打通的.</a>&quot; 李乾坤的博客. N.p., 11 Oct. 2018. Web. 14 Apr. 2021.</span></li><li id="fn:27"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">27.</span><span style="display: inline-block; vertical-align: top;">Helios. &quot;<a href="https://github.com/helios741/myblog/blob/new/learn_go/src/2020/0303_k8s_cni/README.md" target="_blank" rel="noopener">深入浅出kubernetes中的CNI.</a>&quot; <em>GitHub</em>. N.p., 3 Mar. 2020. Web. 14 Apr. 2021.</span></li></ol></div><p><br><br><br><br></p></div></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Cloud Computing</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>network</tag>
        <tag>CNI</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s network之二：Kubernetes的域名解析、服务发现和外部访问</title>
    <url>/2021/K8s-Network-Architecture-section-two.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;在《<a href>K8s network之一：K8s网络模型与网络策略</a>》中我们大概了解了Kubernetes的<strong>IP-Per-Pod</strong>模型和CNI接口规范，以及如何配置网络策略来限制出入Pod的流量。本篇会继续了解和学习Kubernetes集群如何向集群外提供服务访问以及服务之间如何相互发现这两个重要问题。出于篇幅考虑，相关的yaml配置不会在文章中出现，特殊情况除外，相关的yaml配置可以参考<a href="https://kubernetes.io/" target="_blank" rel="noopener">Kubernetes</a>官方文档。</p>
<a id="more"></a>
<p>&emsp;&emsp;<a href>1. K8s network之一：K8s网络模型与网络策略</a></p>
<p>&emsp;&emsp;<a href="/404.html">3.Linux网络在Kubernetes集群中的应用</a>  </p>
<p>&emsp;&emsp;<a href>4.K8s network之四：Kubernetes集群通信的实现原理</a> </p>
<p>&emsp;&emsp;<a href>5.K8s network之五：Kubernetes集群Pod和Service之间通信的实现原理</a> </p>
<h2 id="集群边界路由器Ingress"><a href="#集群边界路由器Ingress" class="headerlink" title="集群边界路由器Ingress"></a>集群边界路由器Ingress</h2><p>&emsp;&emsp;Kubernetes集群内部默认通过Service提供服务，通过Kube-proxy实现Service和Pod之间的负载均衡和转发功能。如果需要将服务暴露到集群外部，可以使用类型为<strong>NodePort</strong>和<strong>LoadBalancer</strong>的Service来对外提供服务，此外，你也可以使用Ingress来履行类型为<strong>NodePort</strong>和<strong>LoadBalancer</strong>的Service所承担的职责，相较于Service而言，使用Ingress暴露服务会更便利、更有优势。</p>
<p>&emsp;&emsp;<a href="https://kubernetes.io/docs/concepts/services-networking/ingress/" target="_blank" rel="noopener">Ingress</a>专注于集群服务的对外暴露、负载均衡、L7转发、基于名称的virtual hosting等职责，它暴露了从集群外部到内部服务之间的HTTP/HTTPS路由，通过一个IP地址就可以暴露多个服务到集群外部，流量路由由在Ingress资源文件中定义的规则决定。需要注意的是，Ingress资源对象仅仅是转发规则的集合，并不负责具体功能的执行，要想真正完成对应的功能，需要Ingress控制器的加入。当使用Ingress进行负载分发时，Ingress 控制器基于Ingress规则会跳过Kube-Proxy直接将客户端请求直接转发到Service所属的某个Pod上。如果Ingress 控制器提供的是对外服务，则其实质就是一个边界路由器。</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1623922539/BlogImages/CloudSerials/Ingress-demo.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 1 Ingress 工作示例<sup id="fnref:1" style="font-size:80%;line-height:80%;"><a href="#fn:1" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[1]</span></a></sup></div>
&emsp;
</div>

<p>&emsp;&emsp;目前Kubernetes官方提供了<a href="https://github.com/kubernetes-sigs/aws-load-balancer-controller#readme" target="_blank" rel="noopener">AWS</a>, <a href="https://git.k8s.io/ingress-gce/README.md#readme" target="_blank" rel="noopener">GCE</a>, 和<a href="https://git.k8s.io/ingress-nginx/README.md#readme" target="_blank" rel="noopener">ingress-nginx</a> 控制器三种类型供用户根据自己的的实际情况进行选择，也正是因为这个原因，Ingress控制器不会像其他控制器那样随集群自动开启。换句话说，Ingress控制器不是kube-controller-manager的组成部分，它仅仅是Kubernetes集群的一个附件，需要在集群上单独部署。如果这三种实现方案无法满足需要，还有诸多第三方开源产品提供了对Ingress控制器的个性化实现，常见的产品包括但不限于可以配置<a href="https://docs.microsoft.com/azure/application-gateway/overview" target="_blank" rel="noopener">Azure 应用网关</a>的<a href="https://azure.github.io/application-gateway-kubernetes-ingress/" target="_blank" rel="noopener">AKS Application Gateway Ingress Controller</a>、适用于<a href="https://www.haproxy.org/#desc" target="_blank" rel="noopener">HAProxy</a>的<a href="https://haproxy-ingress.github.io/" target="_blank" rel="noopener">HAProxy Ingress</a>、<a href="https://github.com/haproxytech/kubernetes-ingress#readme" target="_blank" rel="noopener">HAProxy Ingress Controller for Kubernetes</a>、<a href="https://appscode.com/products/voyager" target="_blank" rel="noopener">Voyager</a>、适用于<a href="https://traefik.io/traefik/" target="_blank" rel="noopener">Traefik</a>的<a href="https://doc.traefik.io/traefik/providers/kubernetes-ingress/" target="_blank" rel="noopener">Traefik Kubernetes Ingress provider</a>、适用于<a href="https://istio.io/" target="_blank" rel="noopener">Istio</a>的<a href="https://istio.io/latest/docs/tasks/traffic-management/ingress/kubernetes-ingress/" target="_blank" rel="noopener">Istio Ingress</a>、可以配置F5 BIG-IP 虚拟服务的<a href="https://clouddocs.f5.com/containers/latest/userguide/kubernetes/" target="_blank" rel="noopener">F5 BIG-IP Container Ingress Services for Kubernetes</a>、借助 <a href="https://avinetworks.com/" target="_blank" rel="noopener">VMware NSX Advanced Load Balancer</a>提供L4-L7层负载均衡的<a href="https://github.com/vmware/load-balancer-and-ingress-services-for-kubernetes" target="_blank" rel="noopener">Avi Kubernetes Operator</a>等，实际上可供用户选择的产品还是非常丰富的。</p>
<p>&emsp;&emsp;传统的反向代理（例如Nginx和HAProxy）对服务的动态变化是带有滞后性的，也就是说服务发生变更后，反向代理可能会需要一些时间来改变配置和重新加载。在微服务的开发模式下，这个问题会进一步放大，影响了微服务效能的最大化。Ingress控制器的出现使得这个问题得到了极大改善，它不仅继承了反向代理的职能，还可以通过关注服务注册、编排随时感知后端服务的变更，将服务变更同步到负载均衡器的配置中，如有必要甚至自动重新热加载。这整个过程对用户来说是透明的，整个同步和热加载期间服务也不会停止对外提供服务。以Kubernetes维护的<a href="https://github.com/ kubernetes/ingress-nginx" target="_blank" rel="noopener">ingress-nginx控制器</a>为例，它以Kubernetes集群和负载均衡器之间的适配器的身份发挥职能，不仅要与Kubernetes集群交互，还要根据需要对Nginx配置进行热更新和重载。而<a href="https://traefik.io" target="_blank" rel="noopener">Traefik</a>在设计之初就坚持了云原生的思想，它在提供反向代理职能的同时，原生支持Kubernetes的Ingress，可以感知集群服务的变化并进行更新。</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1623807541/BlogImages/CloudSerials/Ingress-controller-sync-arch.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 2 Ingress控制器同步服务变更架构</div>
&emsp;
</div>

<p>Nginx、HAProxy、Traefik三种方案的特点如表1所示：</p>
<div style="text-align: left; width: 100%;">
    &emsp;&emsp;&emsp;表 - 1：Nginx、HAProxy、Traefik特点和优势
    <div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1623807178/BlogImages/CloudSerials/Nginx-HAProxy-Traefik-compare.png" style="margin: 0 auto;">
</div></div>

<p>&emsp;&emsp;以Kubernetes官方维护的ingress-nginx为例，ingress-nginx借助于三个组件完成Ingress的职责：控制器NginxController、协程Store和队列SyncQueue，其整体工作模式架构图如图所示：</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1623807878/BlogImages/CloudSerials/Nginx-Ingress-sync-workflow-arch.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 3 Nginx-Ingress配置更新工作流程<sup id="fnref:2" style="font-size:80%;line-height:80%;"><a href="#fn:2" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[2]</span></a></sup></div>
&emsp;
</div>

<p>&emsp;&emsp;Store监控Kubernetes APIServer的运行状态，收集服务资源的变化信息，然后会将这些变化写入一个updateChannel。NginxController会将写入的更新事件同步到队列syncQueue中。协程SyncQueue从syncQueue中取出更新任务并生成新的nginx配置数据，并根据更新的性质决定是否重载nginx配置，最后构建POST数据通知本地Lua Server执行配置的动态更新操作。</p>
<p>&emsp;&emsp;前面提到Ingress的存在会使得Kube-Proxy失去作用，实际是因为Ingress控制器会从Service所属的EndPoints集合中选择一个Pod，并将请求直接发送到当前被选中的Pod上。换句话说，请求不再经过Service层面即可到达Pod上，只是借助Service所掌握的endpoints信息选择一个Pod而已。但是如果使用Ingress以应用负载器的身份作用于Node Port上时，还是需要Kube-Proxy将HTTP请求转发到某个Pod上。这整个过程的执行过程如图4所示：</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1623481973/BlogImages/CloudSerials/Ingress-Workflow-General.webp" style="margin: 0 auto;">
</div>
<div align="center">
  <div align="center"><br>图 - 4 Ingress工作流程</div>
&emsp;
</div>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1623565544/BlogImages/CloudSerials/Ingress-controller-alb-to-pod.webp" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center"><br>图 - 5 Ingress以应用负载均衡器（ALB）直接作用于Pod上</div>
&emsp;
</div>


<p>&emsp;&emsp;在某些场景下，Ingress控制器可以作用于NodePort上。这种场景下，Ingress控制器根据Ingress配置决定由哪个服务来处理当前的HTTP请求，并将请求转发到一个NodePort上，由该节点的Kube-Proxy完成到后端Pod的转发工作。</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1623567520/BlogImages/CloudSerials/Ingress-controller-alb-to-nodeport.webp" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center"><br>图 - 6 Ingress以应用负载均衡器（ALB）直接作用于NodePort上</div>
&emsp;
</div>


<p>&emsp;&emsp;在一些产品实现中，Ingress控制器也可以以网络负载均衡器的身份在OSI第4层发挥作用。在这种应用模式下，Ingress以服务的方式对外集群外暴露，同时配置外部网络负载均衡器（Network Load Balancer，NLB），接入所有来自NLB的流量，之后根据Ingress配置将HTTP请求直接转发到某个Pod上，这种场景同样不需要Kube-Proxy的参与。如图6所示：</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1623563636/BlogImages/CloudSerials/Ingress-in-cluster-mode.webp" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center"><br>图 - 7 Ingress以网络负载均衡器的身份工作</div>
&emsp;
</div>

<p>&emsp;&emsp;有了Ingress，我们可以在对外提供服务的同时满足Service无法提供的诸多特性。你可以根据二者的特性在实际使用过程中进行选择来更好的满足需要。这里对二者进行了一个简单的比较：</p>
<ul>
<li>二者流量方向不同。Kube-Proxy主导下的Service专注的是出站流量，Ingress关注的入站流量（出站、入站指的是出入Pod）</li>
<li>二者在OSI模型中位置不同。Service工作在OSI模型4层，而Ingress工作在7层。针对Ingress控制器的不同实现，有的产品除了7层外还可以根据需要在4层发挥作用</li>
<li>二者功能存在差异。Service无法提供诸如HTTP路由、URL转发等功能，而Ingress提供了负载平衡器的典型特性：HTTP路由、黏性会话、SSL终止、SSL直通、TCP和UDP负载平衡等</li>
<li>二者服务对外暴露实现方案不同。多个Service对外暴露需要多个相互独立的公网IP地址和端口，Ingress可以在一个公网IP地址上完成对多个服务的暴露和路由功能。</li>
</ul>
<h2 id="域名解析和服务发现"><a href="#域名解析和服务发现" class="headerlink" title="域名解析和服务发现"></a>域名解析和服务发现</h2><p>&emsp;&emsp;Kubernetes是可以支持IP地址加端口的形式来完成相互通信和访问的，但是这样会带来一个问题，Kubernetes内部Pod和Service的迭代速度是比较高的，每次迭代都可能导致Pod和Service的IP地址和端口发生变化。但是Service名字等一些标识信息是不会经常变动的，所以Kubernetes更推荐通过Service的名字来访问服务。这就需要一个高效可靠的服务发现机制来支持借助Service名字完成服务访问的功能。</p>
<p>&emsp;&emsp;服务发现的基本实现思想一般是事先部署好一个网络位置稳定的服务注册中心，由服务提供方向注册中心上报自己的相关信息，同时还要及时的向注册中心同步自己的状态变更。服务请求方在发起服务请求时会通过注册中心获取对应的服务提供方的相关信息，从而与提供方建立连接请求服务。根据发现过程的实现方式，服务发现可分为两种类型：</p>
<ul>
<li>客户端发现。客户端自身到注册中心查询其依赖服务的相关信息，因此客户端需要实现一套服务发现程序和发现逻辑</li>
<li>服务端发现。服务请求方将请求发往一个独立的中央路由器或者负载均衡器的组件，这个中央路由器或者负载均衡器负责到注册中心查询服务提供方的相关信息并将客户端请求转发到对应的服务提供方</li>
</ul>
<p>&emsp;&emsp;服务发现和域名（名称）解析是Kubernetes的基础服务之一。Kubernetes集群上的每个Service资源对象在创建时都会被自动委派一个格式为<strong>&lt;service&gt;.&lt;ns&gt;.svc.&lt;zone&gt;</strong>格式的名称，并由ClusterDNS为该名称自动生成资源记录，其中，service、ns、zone分别标识服务的名称、命名空间和集群域名。无论具体采用哪种实现方案，每个Service对象都会拥有如下3种类型的DNS资源记录。</p>
<ol>
<li><p>普通Service对象</p>
<ol>
<li><p>A/AAAA记录</p>
<p>如果是Service的Cluster IP是IPv4地址，会生成一条如下格式的记录：</p>
<p>&lt;service&gt;.&lt;ns&gt;.svc.&lt;zone&gt;. &lt;ttl&gt; IN A &lt;cluster-ip&gt;</p>
<p>如果是Service的Cluster IP是IPv6地址，会生成一条如下格式的记录：</p>
<p>&lt;service&gt;.&lt;ns&gt;.svc.&lt;zone&gt;. &lt;ttl&gt; IN AAAA &lt;cluster-ip&gt;</p>
<p>上述格式中，&lt;service&gt;指的是Service的名称，&lt;ns&gt;为命名空间，&lt;zone&gt;为集群域名，&lt;ttl&gt;为DNS记录的存活时间，&lt;cluster-ip&gt;为Service的Cluster IP</p>
</li>
<li><p>如果存在被定义了名称的端口，那么就为这个端口生成一条SRV记录。未命名的端口则不会有该记录。</p>
<p>_&lt;port&gt;._&lt;proto&gt;.&lt;service&gt;.&lt;ns&gt;.svc.&lt;zone&gt;. &lt;ttl&gt; IN SRV &lt;weight&gt; &lt;priority&gt; &lt;port-number&gt; &lt;service&gt;.&lt;ns&gt;.svc.&lt;zone&gt;.</p>
<p>上述格式中，_&lt;port&gt;为端口名称，_&lt;proto&gt;为端口遵循的协议，&lt;service&gt;为服务名称，&lt;ns&gt;为命名空间，&lt;zone&gt;为集群域名，&lt;ttl&gt;为DNS记录的存活时间，&lt;priority&gt;为目标域名的优先级，值越小越优先，&lt;weight&gt;为相同优先级记录的相对权重，值越大越优先 ，&lt;port-number&gt;为端口号。当有多个server提供服务时，通过priority和weight可以设置由哪个server优先提供服务。换句话，哪个server可以接受并处理更多的请求。如果一个server的priority值越小，那么这个server会接受更多的流量请求。如果几个server的priority值相同，那么server的weight值越高，这个server就会接受更多的流量请求。这两个值看似作用相同，实际上还是有点区别的：在判定由哪个server来处理请求时，会先使用priority进行判定，如果判定成功，那么不论weight值如何，都不会影响判定结果。但如果使用priority无法判定出一个server，此时weight就会介入判定过程。关于&lt;priority&gt;和&lt;weight&gt;的详细定义，可浏览<a href="https://www.rfc-editor.org/rfc/pdfrfc/rfc2782.txt.pdf" target="_blank" rel="noopener">RFC 2782</a>。</p>
</li>
<li><p>针对为每个Service分配的Cluster IP，会生成一条PTR记录。格式如下：</p>
<p>如果Cluster IP为IPv4版本：</p>
<p>&lt;D&gt;.&lt;C&gt;.&lt;B&gt;.&lt;A&gt;.in-addr.arpa. &lt;ttl&gt; IN PTR &lt;service&gt;.&lt;ns&gt;.svc.&lt;zone&gt;.</p>
<p>如果Cluster IP为IPv6版本a1a2a3a4:b1b2b3b4:c1c2c3c4:d1d2d3d4:e1e2e3e4:f1f2f3f4:g1g2g3g4:h1h2h3h4：</p>
<p>h4.h3.h2.h1.g4.g3.g2.g1.f4.f3.f2.f1.e4.e3.e2.e1.d4.d3.d2.d1.c4.c3.c2.c1.b4.b3.b2.b1.a4.a3.a2.a1.ip6.arpa &lt;ttl&gt; IN PTR &lt;service&gt;.&lt;ns&gt;.svc.&lt;zone&gt;.</p>
</li>
</ol>
</li>
<li><p>Headless Service对象</p>
<ol>
<li><p>A/AAAA记录</p>
<p>如果Endpoints的IP是IPv4地址，会生成一条如下记录：</p>
<p>&lt;service&gt;.&lt;ns&gt;.svc.&lt;zone&gt;. &lt;ttl&gt; IN A &lt;endpoint-ip&gt;</p>
<p>上述格式中，&lt;service&gt;指的是Service的名称，&lt;ns&gt;为命名空间，&lt;zone&gt;为集群域名，&lt;ttl&gt;为DNS记录的存活时间，&lt;endpoint-ip&gt;为endpoint的IP地址</p>
<p>如果Endpoints的IP是IPv6地址，会生成一条如下记录：</p>
<p>&lt;service&gt;.&lt;ns&gt;.svc.&lt;zone&gt;. &lt;ttl&gt; IN AAAA &lt;endpoint-ip&gt;</p>
<p>如果Endpoints不仅有IPv4的endpoint-ip，还有域名，那么记录格式如下：</p>
<p>&lt;hostname&gt;.&lt;service&gt;.&lt;ns&gt;.svc.&lt;zone&gt;. &lt;ttl&gt; IN A &lt;endpoint-ip&gt;</p>
<p>如果Endpoints不仅有IPv6的endpoint-ip，还有域名，那么记录格式如下：</p>
<p>&lt;hostname&gt;.&lt;service&gt;.&lt;ns&gt;.svc.&lt;zone&gt;. &lt;ttl&gt; IN AAAA &lt;endpoint-ip&gt;</p>
</li>
<li><p>同普通Service一样，如果存在被定义了名称的端口，那么就为这个端口生成一条SRV记录。未命名的端口则不会有该记录。</p>
<p>_&lt;port&gt;._&lt;proto&gt;.&lt;service&gt;.&lt;ns&gt;.svc.&lt;zone&gt;. &lt;ttl&gt; IN SRV &lt;weight&gt; &lt;priority&gt; &lt;port-number&gt; &lt;hostname&gt;.&lt;service&gt;.&lt;ns&gt;.svc.&lt;zone&gt;.</p>
</li>
<li><p>给定一个分配了域名和IP地址的endpoint，会有一条PTR记录，格式如下：</p>
<p>如果IP地址为IPv4格式&lt;a&gt;.&lt;b&gt;.&lt;c&gt;.&lt;d&gt;：</p>
<p>&lt;d&gt;.&lt;c&gt;.&lt;b&gt;.&lt;a&gt;.in-addr.arpa. &lt;ttl&gt; IN PTR &lt;hostname&gt;.&lt;service&gt;.&lt;ns&gt;.svc.&lt;zone&gt;.</p>
<p>如果IP地址为IPv6格式&lt;a1a2a3a4:b1b2b3b4:c1c2c3c4:d1d2d3d4:e1e2e3e4:f1f2f3f4:g1g2g3g4:h1h2h3h4&gt;：</p>
<p>h4.h3.h2.h1.g4.g3.g2.g1.f4.f3.f2.f1.e4.e3.e2.e1.d4.d3.d2.d1.c4.c3.c2.c1.b4.b3.b2.b1.a4.a3.a2.a1.ip6.arpa &lt;ttl&gt; IN PTR &lt;hostname&gt;.&lt;service&gt;.&lt;ns&gt;.svc.&lt;zone&gt;.</p>
</li>
</ol>
</li>
<li><p>外部服务</p>
<p>如果一个服务被分配了一个外部服务名称，那么会生成一条CNAME记录。格式如下：</p>
<p>&lt;service&gt;.&lt;ns&gt;.svc.&lt;zone&gt;. &lt;ttl&gt; IN CNAME &lt;extname&gt;.</p>
<p>需要注意的是，IPv4和IPv6地址的CNAME记录的格式是一致，需要在查询和解析的时候指明IP地址的版本号：</p>
<p><strong>foo.default.svc.cluster.local. IN A</strong> 会尝试解析域名并得到一条IPv4格式的响应：</p>
<p>​    - foo.default.svc.cluster.local. 10 IN CNAME www.example.com.<br>​    - www.example.com. 28715 IN A 192.0.2.53</p>
<p><strong>foo.default.svc.cluster.local. IN AAAA</strong> 则会尝试解析域名并得到一条IPv6格式的响应：</p>
<p>​    - foo.default.svc.cluster.local. 10 IN CNAME www.example.com.<br>​    - www.example.com. 28715 IN AAAA 2001:db8::1</p>
</li>
<li><p>Pod</p>
<p>在Kubernetes中，Pod也会执行DNS记录的插入和维护工作。如果要为Pod生成一条DNS记录，则其格式如下：</p>
<p>&lt;pod-ip-address&gt;.&lt;my-namespace&gt;.pod.&lt;cluster-domain.example&gt;</p>
<p>例如，给定一个在“dns-test”命名空间里的IP地址为172.172.0.3的Pod，这个Pod所在集群的域名是cluster.dns.test.local，那么生成的记录如下：</p>
<p>172-172-0-3.dnsTest.pod.cluster.dns.test.local</p>
<p>如果Pod是被deployment或者通过Service暴露的daemonSet创建的，那么其对应的DNS记录格式如下：</p>
<p>&lt;pod-ip-address&gt;.&lt;deployment-name&gt;.&lt;my-namespace&gt;.svc.&lt;cluster-domain.example&gt;</p>
</li>
</ol>
<h3 id="集群内DNS"><a href="#集群内DNS" class="headerlink" title="集群内DNS"></a>集群内DNS</h3><p>&emsp;&emsp;在Kubernetes集群内，DNS作为系统级服务，主要用于解析集群内各个Service的服务名，完成从服务名到对应的Cluster IP的解析，因此需要在集群内设置一个相对固定的网络IP地址，还要保证这个IP不能和真实的DNS服务器发生冲突。可以在每台Node的Kubelet启动参数上指定<strong>—cluster-dns=X.X.X.X —cluster-domain= cluster.local</strong>来通知节点内每个Pod关于DNS服务的具体信息，这些信息会在容器的配置文件<strong>/etc/resolv.conf</strong>中得以体现。接下来就需要通过插件来启动集群内的DNS服务了，Kubernetes的DNS服务提供产品也从v1.3之间的SkyDNS、v1.3之后的kube-dns过渡到了v1.10之后的CoreDNS，同时在Kubernetes的v1.21版本中，官方已经停止了对kube-dns的支持。<a href="https://coredns.io" target="_blank" rel="noopener">CoreDNS</a>是CoreOS公司用Go语言开发的Kubernetes DNS服务框架，在Kubernetes v1.10版本中作为beta版集群DNS服务，希望可以逐步替代kube-dns服务。CoreDNS具有高性能、非常灵活、可扩展的插件式模型，各种插件根据请求提供不同的操作，例如日志记录、重定向、自定义DNS记录等。CoreDNS解决了kube-dns的一些问题，例如dnsmasq的安全漏洞、externalName不能使用stubDomains设置，等等。CoreDNS的一般架构如图8所示：</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1623760005/BlogImages/CloudSerials/coredns-general-arch.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 8 CoreDNS一般架构</div>
&emsp;
</div>


<p>&emsp;&emsp;相较于kube-dns，CoreDNS只用一个容器就完成了DNS服务的所有工作，在可用性和效率上会比kube-dns优秀很多。kube-dns中，kubedns用于监控Service和endpoints的变更并建立和更新DNS记录，并将相关记录保存在内存中，dnsmasq则提供具体的DNS解析服务，数据均来自kubedns。sidecar则负责kubedns和dnsmasq的健康状态监测。</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1623760583/BlogImages/CloudSerials/kubedns-general-arch.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 9 kube-dns一般架构</div>
&emsp;
</div>



<p>&emsp;&emsp;CoreDNS服务的相关配置都在corefile文件中得到体现，并且向用户提供了一种简单易懂的DSL来定义满足用户需求的DNS服务实现。DSL的具体语法结构如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">label &#123;</span><br><span class="line">		definition</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//如果不需要换行，那么可以考虑用空格</span><br><span class="line">label1 label2 &#123;</span><br><span class="line">		definition</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//如果需要换行，那么就需要逗号分隔。</span><br><span class="line">//可以只在每行的最后一个label后面加一个逗号，但是不推荐。</span><br><span class="line">label1, label2,</span><br><span class="line">label3, label4,</span><br><span class="line">label5 &#123;</span><br><span class="line">		definition</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在DSL的支持下，corefile的典型格式如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">//ZONE 定义server负责的zone</span><br><span class="line">//PORT 定义server监听的端口，不填则默认监听53号</span><br><span class="line">//PLUGIN 定义server要加载的插件，插件可以按需填写参数</span><br><span class="line">ZONE:[PORT] &#123;</span><br><span class="line">	[PLUGIN]</span><br><span class="line">  [PLUGIN]</span><br><span class="line">  [PLUGIN]</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在corefile中，借助上述语法格式可以定义若干个server block，每个block有一个标签label和紧随其后的一对花括号及括号内的内容构成。每个server block定义了DNS server以什么协议在哪个端口上监听DNS请求、DNS server会用到哪些插件来构建插件链以及DNS server负责哪个zone（可以理解为域名）的DNS解析工作。一个简单的corefile文件定义（部分）如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">coredns.io:5300 &#123;</span><br><span class="line">    file db.coredns.io</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tls://core.corp &#123; # on default port 853 for DNS</span><br><span class="line">	errors</span><br><span class="line">	cache 30</span><br><span class="line">	loop</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">example.io:53 &#123;</span><br><span class="line">    log</span><br><span class="line">    errors</span><br><span class="line">    file db.example.io</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">example.net:53 &#123;</span><br><span class="line">    file db.example.net</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.:53 &#123;</span><br><span class="line">    kubernetes</span><br><span class="line">    forward . 8.8.8.8</span><br><span class="line">    log</span><br><span class="line">    errors</span><br><span class="line">    health</span><br><span class="line">    cache</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在CoreDNS中，每个端口会指向一个dnsserver.Server，所以尽管上述的配置文件中有5个server block，但是最后会得到三个dnsserver.Server。CoreDNS会把指向相同端口的server block聚合成一个dnsserver.Server，如果有多个label标签指向了同一个端口，那么在匹配时会按照自右向左最长匹配原则进行处理和选择。这个Server会在这个相同的端口上通过多路复用提供DNS解析服务，并根据不同的域名传递到不同的插件链中进行处理。</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1623851508/BlogImages/CloudSerials/coredns-corefile-demo.webp" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center"><br>图 - 10 corefile配置示例</div>
&emsp;
</div>


<p>&emsp;&emsp;需要注意的是，在最后一个server block的配置中含有一个health插件，但是在图-10中并未出现对应的health插件。这是因为在CoreDNS的设计中将插件分为了两种类型的插件：一种插件是用来处理DNS请求的，因此会出现在插件链中。还有一类插件仅仅是用来修改server或者server block的配置，换言之，它们和处理DNS请求无任何关系，因此这类插件不会被插入到插件链中。这种类型的插件包括health、tls、startup、shutdown和root等插件。</p>
<p>&emsp;&emsp;CoreDNS支持如下四种协议来访问DNS解析服务：</p>
<ul>
<li>dns:// for plain DNS (默认值，无需指定前缀)</li>
<li>tls:// for DNS over TLS（DoT）, 参考 <a href="https://tools.ietf.org/html/rfc7858" target="_blank" rel="noopener">RFC 7858</a></li>
<li>https:// for DNS over HTTPS（DoH）,参考 <a href="https://tools.ietf.org/html/rfc8484" target="_blank" rel="noopener">RFC 8484</a></li>
<li>grpc:// for DNS over gRPC</li>
</ul>
<p>所以在第二个server block的定义中，定义了<strong>tls://</strong>前缀，这意味着这个server block仅支持使用tls协议来访问CoreDNS完成DNS的解析工作。</p>
<p>&emsp;&emsp;一个可以实现完整功能的CoreDNS应用是由若干个插件完成的，每个插件负责实现一个具体的功能。如果有多个插件，那么这些插件会形成一个调用链，即插件链。当一个DNS解析请求到达时，首先通过贪心原则来匹配zone，进而选择一个处理当前请求的server。接着会根据<strong>plugin.cfg</strong>中定义的顺序顺着插件链逐个通过每个插件完成其功能，每个插件会做出如下判断来决定是否处理当前请求：</p>
<ul>
<li>请求被当前插件处理。当前插件会处理请求并直接向客户端返回响应，插件链调用结束。</li>
<li>请求跳过当前插件。当前插件不会处理请求并将请求直接传递给下一个插件。</li>
<li>请求被当前插件以Fallthrough形式处理。请求在当前插件处理过程中有可能会传递给下一个插件，这种现象称为fallthrough。</li>
<li>请求被当前插件处理并伴随hint信息一同传递给下一个插件。</li>
</ul>
<p>plugin.cfg的内容如下所示（部分）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每行由冒号分隔，前面是插件名称，后面是插件包名。</span></span><br><span class="line"><span class="comment">//包名可以是完整的外部地址，如log:github.com/coredns/coredns/plugin/log</span></span><br><span class="line">metadata:metadata</span><br><span class="line">tls:tls</span><br><span class="line">reload:reload</span><br><span class="line">nsid:nsid</span><br><span class="line">root:root</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>每个插件的声明如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> (</span><br><span class="line">	Plugin <span class="function"><span class="keyword">func</span><span class="params">(Handler)</span> <span class="title">Handler</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	<span class="title">Handler</span> <span class="title">interface</span></span> &#123;</span><br><span class="line">		ServeDNS(context.Context, dns.ResponseWriter, *dns.Msg) (<span class="keyword">int</span>, error)</span><br><span class="line">		Name() <span class="keyword">string</span></span><br><span class="line">	&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;所以只需要实现ServerDNS()和Name()方法，即可实现一个新的插件。所以说，插件的实质就是一个出入参数都是<strong>Handler</strong>的函数。在插件链执行过程中，每个插件可以通过<strong>NextOrFailure</strong>函数调用下一个插件的<strong>ServerDNS()</strong>方法，如果next为<strong>nil</strong>，说明插件链已经调用结束，会直接返回<strong>no next plugin found</strong>。如果不想继续向后传递，也可以通过<strong>WriteMsg()</strong>结束整个调用链。</p>
<blockquote>
<p>CoreDNS is powered by plugins.</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;— coredns.io</p>
</blockquote>
<p>&emsp;&emsp;回到Kubernetes集群，如果想要使用CoreDNS实现DNS解析服务，那么只需要修改configmap文件，在其中加入corefile即可使用CoreDNS。示例如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: coredns</span><br><span class="line">  namespace: kube-system</span><br><span class="line">data:</span><br><span class="line">  Corefile: |</span><br><span class="line">    .:53 &#123;</span><br><span class="line">        errors</span><br><span class="line">        health &#123;</span><br><span class="line">            lameduck 5s</span><br><span class="line">        &#125;</span><br><span class="line">        ready</span><br><span class="line">        kubernetes cluster.local in-addr.arpa ip6.arpa &#123;</span><br><span class="line">            pods insecure</span><br><span class="line">            fallthrough in-addr.arpa ip6.arpa</span><br><span class="line">            ttl 30</span><br><span class="line">        &#125;</span><br><span class="line">        prometheus :9153</span><br><span class="line">        forward . /etc/resolv.conf</span><br><span class="line">        cache 30</span><br><span class="line">        loop</span><br><span class="line">        reload</span><br><span class="line">        loadbalance</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;除了配置集群级别的DNS服务和规则，Kubernetes还支持在Pod上配置相应的DNS策略和配置，从而实现基于Pod的个性化的DNS解析服务。在Pod的资源文件中，可以通过两个字段<strong>spec.dnsPolicy</strong>和<strong>spec.dnsConfig</strong>字段进行设置。其中，dnsPolicy字段用于设置DNS策略，dnsConfig可用来自定义DNS的相关配置。当前版本中，dnsPolicy支持的DNS策略包括如下：</p>
<ul>
<li><p>Default。Pod会直接继承其所在节点（宿主机）的域名解析配置。实质上是让kubelet决定DNS策略，kubelet默认使用所在节点在/etc/resolv.conf下的配置，所以Pod默认会直接继承其所在节点的域名解析配置。同时，kubelet提供了参数<strong>–resolv-conf=</strong>来决定DNS策略的配置。</p>
</li>
<li><p>ClusterFirst。使用集群内的DNS服务（kube-dns或者CoreDNS）完成DNS解析工作。任何无法匹配和使用集群内DNS服务的DNS请求都会被转发到上游域名服务器进行处理，上游域名服务器的相关信息来自于Pod所在节点（宿主机）。</p>
</li>
<li>ClusterFirstWithHostNet。如果有Pod直接运行在宿主机网络上，那么Pod会直接使用宿主机的 /etc/resolv.conf 配置进行DNS解析。如果不想这么做而是继续通过集群内的DNS服务完成解析时，那么应该显式的将DNS策略设置为ClusterFirstWithHostNet。</li>
<li>None。Pod会忽略来自Kubernetes环境变量的所有DNS设置，而由dnsConfig字段的配置提供DNS配置。</li>
</ul>
<p>同时，dnsConfig可以用于设置如下配置信息：</p>
<ul>
<li>nameservers。用来为Pod提供DNS服务的IP地址列表，最多可设置3个。如果Pod的dnsPolicy设置为<strong>None</strong>，这个字段必须至少指定一个IP地址。除了这种情况之外，这个字段可填可不填。</li>
<li>searches。在Pod里用于域名查询的DNS搜索域列表。这个字段是可选项，如果指定了该字段，那么这个列表会被合并到由指定的DNS策略生成的基础搜索域名集合中。如果有重复域名，则只会保留一份。此外Kubernetes限制搜索域的个数最多有6个。</li>
<li>options。DNS的配置选项列表。每个选项必须有一个name属性，可以有一个value属性。列表中的内容会被合并到由指定的DNS策略生成的配置选项数据中，如果有相同配置存在，只会保留一份。</li>
</ul>
<p>&emsp;&emsp;尽管集群DNS服务（kube-dns/CoreDNS）的性能非常优秀，但是随着集群规模的迅速增长，如果每个Pod都直接和集群DNS服务交互完成DNS解析服务，那么集群DNS服务最终也会疲于应对以致性能下降。为了解决这个问题，Kubernetes在v1.18版本引入了<strong>NodeLocal DNSCache</strong>来缓解集群DNS服务的压力。NodeLocal DNSCache会在集群的每个节点上以DaemonSet形式运行一个dns缓存代理Pod，之后Pod会先通过其所在节点的缓存代理完成DNS解析请求，如果解析失败，缓存代理才会向集群DNS服务发起DNS解析请求完成DNS解析。这些dns缓存代理处于其所在节点的kube-system命名空间下。</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1623912290/BlogImages/CloudSerials/nodelocal-dns-cache-arch.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 11 NodeLocal DNSCache 工作流程 <sup id="fnref:3" style="font-size:80%;line-height:80%;"><a href="#fn:3" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[3]</span></a></sup></div>
&emsp;
</div>


<h3 id="自定义DNS服务器和上游DNS服务器"><a href="#自定义DNS服务器和上游DNS服务器" class="headerlink" title="自定义DNS服务器和上游DNS服务器"></a>自定义DNS服务器和上游DNS服务器</h3><p>&emsp;&emsp;kube-dns和CoreDNS都提供了自定义DNS服务器和上游DNS服务器的能力。在kube-dns中，通过如下配置便可以完成DNS服务器和上游服务器的配置：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">data:</span><br><span class="line">  stubDomains: |</span><br><span class="line">        &#123;<span class="attr">"abc.com"</span> : [<span class="string">"1.2.3.4"</span>], <span class="attr">"my.cluster.local"</span> : [<span class="string">"2.3.4.5"</span>]&#125;</span><br><span class="line">  upstreamNameservers: |</span><br><span class="line">        [<span class="string">"8.8.8.8"</span>, <span class="string">"8.8.4.4"</span>]</span><br><span class="line">kind: ConfigMap</span><br></pre></td></tr></table></figure>
<p>上述配置文件转换成CoreDNS的corefile如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">.:53 &#123;</span><br><span class="line">    forward . 8.8.8.8 8.8.4.4</span><br><span class="line">    cache 30</span><br><span class="line">&#125;</span><br><span class="line">abc.com:53 &#123;</span><br><span class="line">    cache 30</span><br><span class="line">    forward . 1.2.3.4</span><br><span class="line">&#125;</span><br><span class="line">my.cluster.local:53 &#123;</span><br><span class="line">    cache 30</span><br><span class="line">    forward . 2.3.4.5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li><p><strong>DNS记录中A、AAAA、SRV、PTR、CNAME的含义</strong></p>
<p>A由<a href="https://tools.ietf.org/html/rfc1035" target="_blank" rel="noopener">RFC 1035</a>定义，用于IPv4版本的DNS解析。常用于将一个主机名映射到一个IPv4地址。记录包括域名、对应IP地址、以秒为单位的TTL值，TTL会告诉DNS服务器应该在缓存中保留给定记录多久。</p>
<p>AAAA由<a href="https://tools.ietf.org/html/rfc3596" target="_blank" rel="noopener">RFC 3596</a>定义，用于IPv6版本的DNS解析。常用于将一个主机名映射到一个IPv6地址。</p>
<p>SRV由<a href="https://tools.ietf.org/html/rfc2782" target="_blank" rel="noopener">RFC 2782</a>定义，SRV记录标记了哪台服务器提供了什么服务。它除了指明服务的IP地址外，还指明了哪个端口会提供对应的服务。</p>
<p>PTR由<a href="https://tools.ietf.org/html/rfc2782" target="_blank" rel="noopener">RFC 1035</a>定义，是A/AAAA记录的逆向记录，用于将IP地址反向映射到一个域名，因此也称为IP反查记录或者指针记录。</p>
<p>CNAME（Canonical Name）由<a href="https://tools.ietf.org/html/rfc1035" target="_blank" rel="noopener">RFC 1035</a>定义，通常称为别名指向。用于将多个域名映射到同一个主机上。</p>
</li>
<li><p><strong>DNS Search Domain</strong></p>
<p> &emsp;&emsp;DNS Search Domain（DNS 搜索域）是DNS服务用来解析非全限定域名的一个概念。</p>
<p> &emsp;&emsp;全限定域名可以从根域（根域只是一个空字符串）逐级向下解析并最终返回一个IP地址。换句话说，全限定域名以诸如.com, .org, .net, .ca之类的顶级域名为后缀。根域包含了为全球顶级域名服务的域名解析服务器信息。</p>
<p> &emsp;&emsp;以www.google.com.为例，在全球DNS体系中它是一个全限定域名。在com.之后是不可见的根域部分，专门在com之后留了一个点，意味着根域就是处理解析请求的最高级别区域。但是，myhost却不是一个全限定域名，在尝试定位和解析myhost的时候可能会引起歧义。</p>
<p> &emsp;&emsp;一个全限定域名（FQDN）一定是非歧义的。可能会有多个IP地址绑定在一个域名上，但是绝不可能出现两条冲突的DNS结果。继续以myhost为例，可能会有myhost.example.com、myhost.example2.com等等之类的域名地址，所以需要一种机制来消除这种歧义现象，这就是DNS搜索域产生的背景。说白了，搜索域就是一个用来追加在一个非全限定域名后面的有序的域列表。</p>
<p> &emsp;&emsp;许多公司和组织机构在构建内部网络时都有它们自己的DNS服务器。鉴于诸如现实和安全等一些目的，不使用全局域是一种普遍情况。一般而言，诸如”.local”, “.localdomain”, 和 “.corp”等等都是常见的内部域，在根域中是无法找到这些域的记录的。在同一台DNS服务器上，可能同时存在myhost.localdomain和myhost.otherdomain，搜索域会告诉服务器应该选择哪一个继续后面的工作。</p>
<p> &emsp;&emsp;上面摘自<a href="https://forums.tomshardware.com/threads/what-does-dns-search-domains-mean.1640744/#:~:text=the%20DNS%20search%20domain%20is,up%20with%20an%20IP%20address." target="_blank" rel="noopener">What does “DNS search domains” mean?</a>中的内容。实际上搜索域就是一个域名后缀的集合，有的时候在做DNS解析的时候有可能给的不是一个完整的域名结构，比如”nrl-iman“。这个时候如果做域名解析的时候可能会有问题，因为”nrl-iman“所属的域无法确定，可能是”nrl-iman.com“、”nrl-iman.org“、”nrl-iman.corp“，”nrl-iman.cn.corp“等等。所以这个时候就需要给一个域后缀列表，指明当处理”nrl-iman“时，要在哪些域中尝试解析”nrl-iman“。假设设置搜索域为“corp”，“cn.corp”，那么当处理”nrl-iman“就只会考虑”nrl-iman.corp“，”nrl-iman.cn.corp“这两种情况，而不会尝试解析”nrl-iman.com“和”nrl-iman.org“。</p>
</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top;">Kubernetes contributors. &quot;<a href="https://kubernetes.io/docs/concepts/services-networking/ingress/" target="_blank" rel="noopener">Ingress</a>&quot; <em>Kubernetes.io</em>. N.p., 19 Aug. 2019. Web. 14 Apr. 2021.</span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top;">shida_csdn. &quot;<a href="https://blog.csdn.net/shida_csdn/article/details/84032019" target="_blank" rel="noopener">K8S 源码探秘 之 Nginx-Ingress 工作原理分析.</a>&quot; <em>CSDN</em>. N.p., 14 Nov. 2018. Web. 14 Apr. 2021.</span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top;">Kubernetes contributors. &quot;<a href="https://kubernetes.io/docs/tasks/administer-cluster/nodelocaldns/" target="_blank" rel="noopener">Using NodeLocal DNSCache in Kubernetes clusters</a>&quot; <em>Kubernetes.io</em>. N.p., 11 Jun. 2019. Web. 14 Apr. 2021.</span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top;">Project Calico. <a href="https://www.youtube.com/watch?v=40VfZ_nIFWI" target="_blank" rel="noopener"><em>Kubernetes Ingress Networking</em></a>. <em>YouTube</em>, 3 May 2020, 14 Apr. 2021.</span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top;">O’Haver, Chris, et al. &quot;<a href="https://github.com/kubernetes/dns/blob/master/docs/specification.md" target="_blank" rel="noopener">Kubernetes DNS-Based Service Discovery.</a>&quot; <em>GitHub</em>. N.p., 10 Jan. 2017. Web. 15 Apr. 2021.</span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top;">&quot;<a href="https://www.cloudflare.com/learning/dns/dns-records/dns-srv-record/" target="_blank" rel="noopener">What Is a DNS SRV Record?</a>&quot; <em>Cloudflare</em>. N.p., n.d. Web. 15 Apr. 2021.</span></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline-block; vertical-align: top;">Wikipedia contributors. &quot;<a href="https://en.wikipedia.org/wiki/List_of_DNS_record_types" target="_blank" rel="noopener">List of DNS record types.</a>&quot; Wikipedia, The Free Encyclopedia. Wikipedia, The Free Encyclopedia, 2 Jun. 2021. Web. 19 Apr. 2021.</span></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">8.</span><span style="display: inline-block; vertical-align: top;">Google Cloud contributors. &quot;<a href="https://cloud.google.com/kubernetes-engine/docs/concepts/ingress" target="_blank" rel="noopener">GKE Ingress for HTTP(S) Load Balancing.</a>&quot; <em>Google Cloud</em>. N.p., n.d. Web. 15 Apr. 2021.</span></li><li id="fn:9"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">9.</span><span style="display: inline-block; vertical-align: top;">Luksa, Marko. <em>Kubernetes in Action中文版</em>. Trans. 七牛容器云团队. 1st ed. 北京: 电子工业出版社, 2019. Print.</span></li><li id="fn:10"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">10.</span><span style="display: inline-block; vertical-align: top;">杜军. <em>Kubernetes网络权威指南：基础、原理与实践</em>. 1st ed. 北京: 电子工业出版社, 2019. Print.</span></li><li id="fn:11"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">11.</span><span style="display: inline-block; vertical-align: top;">闫健勇, et al. <em>Kubernetes权威指南：企业级容器云实战</em>. 1st ed. 北京: 电子工业出版社, 2018. Print.</span></li><li id="fn:12"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">12.</span><span style="display: inline-block; vertical-align: top;">马永亮. <em>Kubernetes进阶实战</em>. 2nd ed. 北京: 机械工业出版社, 2019. Print.</span></li><li id="fn:13"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">13.</span><span style="display: inline-block; vertical-align: top;">Kubernetes contributors. &quot;<a href="https://kubernetes.io/docs/tasks/administer-cluster/dns-custom-nameservers" target="_blank" rel="noopener">Customizing DNS Service</a>&quot; <em>Kubernetes.io</em>. N.p., 20 Jun. 2018. Web. 14 Apr. 2021.</span></li><li id="fn:14"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">14.</span><span style="display: inline-block; vertical-align: top;">CoreDNS contributors. &quot;<a href="https://coredns.io/manual/toc/" target="_blank" rel="noopener">CoreDNS Manual.</a>&quot; <em>CoreDNS</em>. N.p., n.d. Web. 15 Apr. 2021.</span></li><li id="fn:15"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">15.</span><span style="display: inline-block; vertical-align: top;">Kubernetes contributors. &quot;<a href="https://kubernetes.io/docs/concepts/services-networking/dns-pod-service" target="_blank" rel="noopener">DNS for Services and Pods</a>&quot; <em>Kubernetes.io</em>. N.p., 5 May. 2018. Web. 14 Apr. 2021.</span></li><li id="fn:16"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">16.</span><span style="display: inline-block; vertical-align: top;">Project Calico contributors. &quot;<a href="https://docs.projectcalico.org/reference/architecture/overview" target="_blank" rel="noopener">Component Architecture.</a>&quot; <em>Project Calico</em>. N.p., n.d. Web. 15 Apr. 2021.</span></li><li id="fn:17"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">17.</span><span style="display: inline-block; vertical-align: top;">晒太阳的猫. &quot;<a href="https://zhengyinyong.com/post/coredns-plugin-system-implementation" target="_blank" rel="noopener">CoreDNS 插件系统的实现原理.</a>&quot; <em>zhengyinyong.com</em>. N.p., 4 Feb. 2019. Web. 13 Apr. 2021.</span></li><li id="fn:18"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">18.</span><span style="display: inline-block; vertical-align: top;">Google Cloud contributors. &quot;<a href="https://cloud.google.com/kubernetes-engine/docs/how-to/nodelocal-dns-cache" target="_blank" rel="noopener">Setting up NodeLocal DNSCache.</a>&quot; <em>Google Cloud</em>. N.p., n.d. Web. 13 Apr. 2021.</span></li><li id="fn:19"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">19.</span><span style="display: inline-block; vertical-align: top;">Anthony, Cornell. &quot;<a href="https://aws.amazon.com/blogs/opensource/network-load-balancer-nginx-ingress-controller-eks/" target="_blank" rel="noopener">Using a Network Load Balancer with the NGINX Ingress Controller on Amazon EKS.</a>&quot; <em>AWS Open Source Blog</em>. N.p., 9 Aug. 2019. Web. 14 Apr. 2021.</span></li><li id="fn:20"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">20.</span><span style="display: inline-block; vertical-align: top;">Kubernetes contributors. &quot;<a href="https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/" target="_blank" rel="noopener">Ingress Controllers.</a>&quot; <em>Kubernetes</em>. N.p., 18 Feb. 2019. Web. 14 Apr. 2021.</span></li><li id="fn:21"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">21.</span><span style="display: inline-block; vertical-align: top;">Kubernetes contributors. &quot;<a href="https://kubernetes.io/docs/concepts/services-networking/ingress/" target="_blank" rel="noopener">Ingress.</a>&quot; <em>Kubernetes</em>. N.p., 19 Aug. 2019. Web. 14 Apr. 2021.</span></li><li id="fn:22"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">22.</span><span style="display: inline-block; vertical-align: top;">乾坤李. &quot;<a href="https://qiankunli.github.io/2018/10/11/cni.html" target="_blank" rel="noopener">CNI——容器网络是如何打通的.</a>&quot; 李乾坤的博客. N.p., 11 Oct. 2018. Web. 14 Apr. 2021.</span></li><li id="fn:23"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">23.</span><span style="display: inline-block; vertical-align: top;">Belamaric, John, and Cricket Liu. <em>Learning CoreDNS:Configuring DNS for Cloud-Native Environments</em>. 1st ed. Boston: O’Reilly Media, 2019. Print.</span></li><li id="fn:24"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">24.</span><span style="display: inline-block; vertical-align: top;">&quot;<a href="https://kubernetes.github.io/ingress-nginx/how-it-works/" target="_blank" rel="noopener">How It Works.</a>&quot; <em>NGINX Ingress Controller</em>. N.p., n.d. Web. 14 Apr. 2021.</span></li></ol></div><p><br><br><br><br></p></div></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Cloud Computing</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>network</tag>
        <tag>Ingress</tag>
        <tag>CoreDNS</tag>
      </tags>
  </entry>
  <entry>
    <title>Murmurhash初步学习</title>
    <url>/2019/MurMurhash-Learning.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;Murmurhash是由Austin Appleby在2008年发明的一种非常简单的、不具有加密特性的散列函数，可以非常容易的应用在一般的基于散列的查找场景中。Murmurhash非常简单，在X86体系结构的机器上可以用少于52条指令完成所有的计算，由此带来的性能也是非常优秀的。此外，Murmurhash具有非常好的强混淆性（雪崩效应）和非常低的冲突风险。强混淆性指的是输入数据的微小改变，都会产生一个完全不同的散列值。Murmurhash的强混淆性使得通过Murmurhash计算得到的散列值具有非常的分布性。Murmurhash的当前版本是Murmurhash3，可以用来生成一个32位或128的散列值。如果生成结果是128位结果，那么在X86结构和X64结构上的计算结果是不一样的。本文以Murmurhash2为例进行讨论。</p>
<a id="more"></a>
<p>&emsp;&emsp;作者在C版本的代码中对Murmurhash的运行提出了一些假设和解释：</p>
<ol>
<li>假设系统可以一次性读取4个字节；</li>
<li>假设int类型数据的长度是4个字节；</li>
<li>算法不会按照增量的方式工作；</li>
<li>算法在大端（big-endian）和小端（little-endian）结构下的执行结果不一致。</li>
</ol>
<p>&emsp;&emsp;下面我将以32位版本为例进行学习（下述代码由Jedis 3.2.0实现）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(ByteBuffer buf, <span class="keyword">int</span> seed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// save byte order for later restoration</span></span><br><span class="line">    ByteOrder byteOrder = buf.order();</span><br><span class="line">    buf.order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0x5bd1e995</span>;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> h = seed ^ buf.remaining();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">while</span> (buf.remaining() &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">      k = buf.getInt();</span><br><span class="line"></span><br><span class="line">      k *= m;</span><br><span class="line">      k ^= k &gt;&gt;&gt; r;</span><br><span class="line">      k *= m;</span><br><span class="line"></span><br><span class="line">      h *= m;</span><br><span class="line">      h ^= k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (buf.remaining() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      ByteBuffer finish = ByteBuffer.allocate(<span class="number">4</span>).order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">      <span class="comment">// for big-endian version, use this first:</span></span><br><span class="line">      <span class="comment">// finish.position(4-buf.remaining());</span></span><br><span class="line">      finish.put(buf).rewind();</span><br><span class="line">      h ^= finish.getInt();</span><br><span class="line">      h *= m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= h &gt;&gt;&gt; <span class="number">13</span>;</span><br><span class="line">    h *= m;</span><br><span class="line">    h ^= h &gt;&gt;&gt; <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    buf.order(byteOrder);</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在32位版本的方法调用中，需要传入一个seed，seed一方面可以起到降低冲突碰撞概率的发生，对于不同的数据内容而言，即使散列算法非常优秀，也还是会有产生相同散列值的可能。通过在计算过程中加入seed完成随机数的生成计算，可以进一步降低冲突碰撞的概率。另一方面，对相同的数据内容计算散列值，不同的seed值会产生不同的结果，可以一定程度上避免HashDos安全问题的发生。当然，由于Murmurhash自身是非加密的，所以后一种解释对Murmurhash来说不具有任何意义，Murmurhash更多是期望可以通过seed值来降低冲突碰撞发生的概率。在Murmurhash2中用来生成64位散列值的方法中，seed值被指定为<strong>0x1234ABCD</strong>。方法调用者只需要关注需要计算散列值的数据内容即可。</p>
<p>&emsp;&emsp;在hash()方法的第9行代码中，作者基于传入的seed值生成一个随机数，然后按照每4位得到一个int值来多次进行乘法、位移（右移）和异或操作，直至原始的数据内容全部被处理完或者剩余的数据位数不足4位。在操作过程中使用到的<strong>0x5bd1e995</strong>和<strong>24</strong>是事先决定的值，作者之所以取这两个值是因为作者认为这两个值可以产生令人满意的执行结果。作者循环的取出一个int数据（每4位取值），多次执行乘法、位移和异或操作来完成散列值的计算。第23 ~ 30行代码会对剩余的不足4位的数据完成散列值的计算。第32 ~ 34行代码用来保证剩下的最后几位数据在散列之后可以充分的分散在整体的散列结果中。</p>
<h2 id="Murmurhash2-64位实现"><a href="#Murmurhash2-64位实现" class="headerlink" title="Murmurhash2 64位实现"></a>Murmurhash2 64位实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">hash64A</span><span class="params">(ByteBuffer buf, <span class="keyword">int</span> seed)</span> </span>&#123;</span><br><span class="line">    ByteOrder byteOrder = buf.order();</span><br><span class="line">    buf.order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> m = <span class="number">0xc6a4a7935bd1e995L</span>;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">47</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> h = seed ^ (buf.remaining() * m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> k;</span><br><span class="line">    <span class="keyword">while</span> (buf.remaining() &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">      k = buf.getLong();</span><br><span class="line"></span><br><span class="line">      k *= m;</span><br><span class="line">      k ^= k &gt;&gt;&gt; r;</span><br><span class="line">      k *= m;</span><br><span class="line"></span><br><span class="line">      h ^= k;</span><br><span class="line">      h *= m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (buf.remaining() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      ByteBuffer finish = ByteBuffer.allocate(<span class="number">8</span>).order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">      <span class="comment">// for big-endian version, do this first:</span></span><br><span class="line">      <span class="comment">// finish.position(8-buf.remaining());</span></span><br><span class="line">      finish.put(buf).rewind();</span><br><span class="line">      h ^= finish.getLong();</span><br><span class="line">      h *= m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= h &gt;&gt;&gt; r;</span><br><span class="line">    h *= m;</span><br><span class="line">    h ^= h &gt;&gt;&gt; r;</span><br><span class="line"></span><br><span class="line">    buf.order(byteOrder);</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Murmurhash2的缺陷和修复"><a href="#Murmurhash2的缺陷和修复" class="headerlink" title="Murmurhash2的缺陷和修复"></a>Murmurhash2的缺陷和修复</h2><p>&emsp;&emsp;Murmurhash2的设计中存在一个难以修复的缺陷，我们仍然以32位散列值生成函数来讨论这个缺陷：</p>
<p>&emsp;&emsp;如果我们修改程序中的m使之等于1，那么在散列值的计算过程中由于m=1导致k的影响被完全抵消进而产生相同的散列值。即使我们清楚这个问题并严禁将m赋值为1，对同一个输入数据的所有可能散列值也无法达到期望的$ 2^{32} $。</p>
<p>&emsp;&emsp;尽管该缺陷难以修复，但在实际的使用场景中，这个缺陷很难让应用程序运行失败。这个缺陷发生的条件非常苛刻：数据内容中包括重复的4字节值，且数据内容的差异仅存在于这些重复的4字节值上，且重复次数位于4字节的边界。如果真的发生了这种情况，那么散列值的范围将由$ 2^{32} $变成$ 2^{27.4} $。</p>
<p>&emsp;&emsp;在Murmurhash3中，作者采用了更好的设计来完成散列值的计算，规避了Murmurhash2的设计缺陷，且具有更快的计算速度。</p>
<h2 id="Murmurhash和Java语言的执行测试"><a href="#Murmurhash和Java语言的执行测试" class="headerlink" title="Murmurhash和Java语言的执行测试"></a>Murmurhash和Java语言的执行测试</h2><p>&emsp;&emsp;下面为一段字符串为例，观察Java提供的String.hashcode()和Murmurhash的执行结果的差异，Murmurhash的实现由Jedis提供。这里对同一个字符串分别用String.hashCode()方法和Murmurhash的算法来生成散列值，需要注意的是，Murmurhash生成的是64位的散列值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"LiXiansheng01"</span>.hashCode());</span><br><span class="line">    System.out.println(<span class="string">"LiXiansheng02"</span>.hashCode());</span><br><span class="line">    MurmurHash hash = <span class="keyword">new</span> MurmurHash();</span><br><span class="line">    System.out.println(hash.hash(<span class="string">"LiXiansheng01"</span>));</span><br><span class="line">    System.out.println(hash.hash(<span class="string">"LiXiansheng02"</span>));</span><br><span class="line">    System.out.println(hash.hash(<span class="string">"LiXiansheng03"</span>));</span><br><span class="line">    System.out.println(hash.hash(<span class="string">"LiXiansheng04"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;代码执行结果如图 - 1所示：</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1590126930/BlogImages/Algorithm/hash-related/Murmurhash-Learning-Result-About-Java-Hashcode-And-Murmurhash.png" style="margin: 0 auto;">
</div>

<div align="center">
<div align="center">图 - 1</div>
&emsp;
</div>

<p>&emsp;&emsp;可以看到，Java的String类提供的hashCode()方法虽然简单易行，但是对于字符串差异不大的场景来说，其散列值很容易成为连续的散列值，这样带来的一个不足就是散列值的分布性不够均匀和随机，容易造成聚集。反观Murmurhash的执行结果，即使字符串差异不大，其散列值的差别也是非。常大的，这样可以保证散列值具有良好的分布性，尽量减少聚集现象的发生。</p>
<h2 id="基础知识点"><a href="#基础知识点" class="headerlink" title="基础知识点"></a>基础知识点</h2><ol>
<li><p><strong>雪崩效应（Avalanche effect）</strong></p>
<p><strong>雪崩效应</strong>（<strong>Avalanche effect</strong>）是加密算法的一种理想属性，指的是当输入发生最微小的改变时，会导致输出结果发生比较非常明显的变化。该术语最早由Horst Feistel使用，其概念最早可以追溯到克劳德·香农提出的扩散（diffusion）理论。若某种块密码或加密散列函数没有显示出一定程度的雪崩特性，那么它被认为具有较差的随机化特性，从而密码分析者得以仅仅从输出推测输入。这可能导致该算法部分乃至全部被破解。</p>
</li>
<li><p><strong>严格雪崩准则</strong>（<strong>Strict Avalanche Criterion</strong>，<strong>SAC</strong>）</p>
<p><strong>严格雪崩准则</strong>（<strong>Strict Avalanche Criterion</strong>，<strong>SAC</strong>）是雪崩效应的形式化。当任何一个输入位被反转时，输出中的每一位均有50%的概率发生变化。严格雪崩准则建立于密码学的完全性概念上，由Webster和Tavares在1985年提出。</p>
</li>
<li><p><strong>String.hashCode()的思想是什么？</strong></p>
<p>String.hashCode()的实现过程采用了Horner法则（Horner’s rule）的思想，Horner法则也称为秦九韶算法，是一种计算n次多项式的高效算法。Horner法则通过将n次多项式</p>
<script type="math/tex; mode=display">f\left( x\right) =a_{n}x^{n}+a_{n-1}x^{n-1}+a_{n-2}x^{n-2}+\ldots \ldots +a_{2}x^{2}+a_{1}x+a_{0}</script><p>转换成</p>
<script type="math/tex; mode=display">f\left( x\right) =\left( \left( \left( \ldots \left( \left( a_{n}x+a_{n-1}\right) \cdot x+a_{n-2}\right) \cdot x+a_{n-3}\right) x+\ldots \ldots +a_{2}\right) x+a_{1}\right) x+a_{0}</script><p>这样乘法和加法的计算次数就从n次多项式的$ \dfrac {n\left( n+1\right) }{2} $和 n次，降低到了n次乘法和n次加法，进而提高计算性能。</p>
</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>Stack Overflow. <a href="https://stackoverflow.com/questions/9241230/what-is-murmurhash3-seed-parameter" target="_blank" rel="noopener">What is MurmurHash3 seed parameter?</a> [E]</li>
<li>spacewander. <a href="https://segmentfault.com/a/1190000010990136" target="_blank" rel="noopener">漫谈非加密哈希算法</a> [E]</li>
<li>aappleby. <a href="https://github.com/aappleby/smhasher/wiki" target="_blank" rel="noopener">SMHasher</a> [E]</li>
<li>Anderson Dadario. <a href="https://dadario.com.br/cryptographic-and-non-cryptographic-hash-functions/" target="_blank" rel="noopener">Cryptographic and Non-Cryptographic Hash Functions</a> [E]</li>
<li>Wikipedia. <a href="http://en.wikipedia.org/wiki/MurmurHash" target="_blank" rel="noopener">MurmurHash</a> [E]</li>
</ol>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>散列函数</tag>
      </tags>
  </entry>
  <entry>
    <title>PGP工作原理简述</title>
    <url>/2019/PGP-Introduction.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;<strong>PGP</strong>（Pretty Good Privacy，中文翻译“优良保密协议”）是一个基于RSA体系、将公开密钥加密与传统密钥加密相结合的用于信息加密、验证的商业应用程序，由菲尔·齐默尔曼 (Philip R. Zimmermann) 于1991年开发完成并发布。自发布以来，PGP凭借其可以运行于多种操作系统平台、其加密算法得到普遍认可、具有广泛的应用场景等特性使得PGP的应用领域迅速扩大，同时使PGP自身也得到了更好的发展。</p>
<a id="more"></a>
<p>&emsp;&emsp;之后，在1997年，菲尔向 <strong>IETF</strong> 提交了<a href="https://www.openpgp.org" target="_blank" rel="noopener"><strong>OpenPGP</strong></a> 加密标准的提案，OpenPGP标准的详细细节可参考文档<a href="https://www.ietf.org/rfc/rfc4880.txt" target="_blank" rel="noopener">RFC 4880</a>。OpenPGP由PGP衍生而来，是在 PGP 基础上定义的开放标准，号称是世界上使用最广泛的邮件加密标准。OpenPGP标准提供了完整的数据完整性服务，用户可以查看、检验、生成和写入加密信息、秘钥以及签名等。由于美国密码技术出口限制的制约，使得在美国境内严禁编写实现公开密钥软件的软件，即使美国公民在境外完成软件实现也不允许。鉴于此，德国人Werner Koch于1997年开始编写一款称为<a href="https://www.gnupg.org" target="_blank" rel="noopener"><strong>GPG</strong>（<strong>GNU Privacy Guard</strong> 或<strong>GnuPG</strong>）</a>的程序，并于于1998年2月发布了第一个版本。经过一系列的开发工作，GPG 1.0.0版于1999年9月7日正式发布。GPG是一个开源的（依照GNU第三版许可），且具有和PGP相同功能的加密应用程序，其按照OpenPGP标准完成相应的设计和实现工作，是 OpenPGP 协议的一种完备的实现方案，目前由德国政府资助其研发工作。</p>
<blockquote>
<p>OpenPGP is the most widely used email encryption standard in the world. </p>
<p>​                                                                                                           —— <a href="http://www.openpgp.org/" target="_blank" rel="noopener">http://www.openpgp.org/</a></p>
</blockquote>
<p>&emsp;&emsp;PGP在具体过程中采用了一系列散列、数据压缩、对称密钥加密，以及公钥加密的算法。目前，PGP可以支持的操作类型包括数字签名、消息加密、压缩、电子邮件的兼容性以及分段和重装等，每个步骤均支持若干种算法，可以根据实际的应用场景和需求选择合适的算法完成工作。<br>&emsp;</p>
<h2 id="基本服务"><a href="#基本服务" class="headerlink" title="基本服务"></a>基本服务</h2><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>&emsp;&emsp;PGP支持消息身份认证和完整性检查。PGP用数字签名来保证接收者收到的信息一定来自于信息所声明的发送者（即身份认证），且信息在发送者和接收者之间没有被第三者修改（即完整性检查）。需要注意的是，数字签名本身不具有加密能力，在信息发送过程中会将信息和基于信息生成的签名一同发送。具体过程如下（PS：仅讨论数字签名的场景，不包含加解密操作）：</p>
<ol>
<li>发送者创建需要发送给接收者的原始信息内容；</li>
<li>发送者基于原始信息用SHA1算法产生一个160bit的散列值（称为消息摘要），然后用发送者自己的私钥对摘要进行加密；</li>
<li>发送者将第（2）步得到的加密摘要与原始信息封装成报文一同发送给接收者；</li>
<li>接收者收到发送者发送的报文后，通过从发送者处得到的公钥将报文中包含的摘要进行解密，获得原始未加密的摘要信息；</li>
<li>接收者使用相同算法针对报文中含有的原始信息生成一个新的散列值，并与第（4）步得到的解密后的摘要信息进行比对，如果两者完全匹配，则接收者收到的信息来自于发送者（因为接收者用发送者给的公钥解密了发送者发送的加密报文，即身份认证），且在发送过程中未被篡改（接收者生成的摘要和发送者发送的摘要完全匹配，即完整性检查）。</li>
</ol>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1586930445/BlogImages/security/PGP-Introduction-Digital-signature.png" alt></p>
<div align="center">
    <div align="center">
        图 - 1 PGP 数字签名工作流程
    </div>
    &emsp;
</div>

<p>&emsp;&emsp;PGP采用RSA或者DSA完成数字签名的操作。在生成散列值的过程中，除了SHA1外，还支持SHA-2-256，SHA-2-354，SHA-2-512，RIPEMD-160等。</p>
<p>&emsp;&emsp;在PGP中，数字签名可以仅作用到原始信息上，也就是可以存在若干个独立的，分别对原始信息进行了散列操作的消息摘要。以书面合同为例，如果合同涉及了多个参与方，那么每个参与方都需要在合同上签署自己的签名。如果数字签名不作用在原始信息上，那么将会产生递归签名的现象，即生成第二个签名所需要的信息中包含了第一个签名自身，当接收者收到报文后，必须依次对签名进行解密才能获得其他签名。</p>
<h3 id="消息加密"><a href="#消息加密" class="headerlink" title="消息加密"></a>消息加密</h3><p>&emsp;&emsp;在PGP的消息加密过程中，同时使用了对称秘钥加密和公钥加密的方法对消息明文进行加密操作。这是为了保证电子邮件传输过程中的信息机密特性而做出的设计方案。对称秘钥加密具有计算量小，加密速度快，加密效率高的特点，但是对称秘钥在使用过程中需要对秘钥进行分发，秘钥的安全性无法得到保障，且秘钥的管理和维护随着秘钥的增多会越发复杂。对于公钥加密而言，其秘钥体系由公钥和私钥两个部分构成，公钥可以分发给任何需要和秘钥所有者通信的人或组织，而私钥则只能由秘钥所有者保管且绝对不能分发给任何人，所以其保密性更好。但是公钥加密由于算法自身的强度过高而导致加解密速度和对称秘钥加密相比不够理想，所以通常用来加密一些少量的、安全级别要求非常高的信息。</p>
<p>&emsp;&emsp;鉴于二者各自的特性，PGP使用对称秘钥加密对消息明文进行加密，在加密的过程中会需要一个用来加密的秘钥（称为会话秘钥），这个会话秘钥在每次加密时重新生成，所以即使发送者向同一个接收者多次发送加密消息，每条加密消息中包含的会话秘钥都是不同的。之后，发送者利用来自接收者的公钥将会话秘钥进行加密，以此来保证在消息传输过程中会话秘钥、原始信息不会被第三者破解和篡改。最后，发送者将加密后的消息和会话秘钥封装一同发送给接收者。具体过程如下（PS：仅讨论消息加密的场景，不包含数字签名）：</p>
<ol>
<li>发送者创建需要发送给接收者的原始信息内容；</li>
<li>发送者生成用于对称加密的会话秘钥；</li>
<li>发送者采用对称秘钥算法通过第（2）步生成的会话秘钥对原始信息自身进行加密；</li>
<li>发送者采用来自接收者的公钥对第（2）步生成的会话秘钥进行加密；</li>
<li>发送者将加密后的信息和会话秘钥封装成报文一同发送给接收者；</li>
<li>接收者通过自己的私钥将报文中含有的加密的会话秘钥进行解密得到原始的会话秘钥；</li>
<li>接收者利用第（6）步得到的会话秘钥采用和发送者相同的对称秘钥算法对加密信息进行解密，得到原始信息内容。</li>
</ol>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1586930445/BlogImages/security/PGP-Introduction-Encryption.png" alt></p>
<div align="center">
    <div align="center">
        图 - 2 PGP 加密工作流程
    </div>
    &emsp;
</div>

<p>&emsp;&emsp;有一点要注意的是，PGP可以用来自接收者的公钥对会话秘钥进行加密，也可以采用双方事先协商的加密算法或技术对会话秘钥进行加密而无需使用接收者的公钥执行会话秘钥的加密操作。</p>
<h3 id="加密和签名同时使用"><a href="#加密和签名同时使用" class="headerlink" title="加密和签名同时使用"></a>加密和签名同时使用</h3><p>&emsp;&emsp;PGP可以同时对原始信息做签名和加密操作，具体流程如下：</p>
<ol>
<li>发送者创建需要发送给接收者的原始信息内容；</li>
<li>发送者基于原始信息用SHA1算法产生一个160bit的散列值（称为消息摘要），然后用发送者自己的私钥对摘要进行加密；</li>
<li>发送者将第（2）步得到的加密摘要与原始信息封装并采用ZIP算法进行压缩；</li>
<li>发送者生成用于对称加密的会话秘钥；</li>
<li>发送者采用对称秘钥算法通过第（4）步生成的会话秘钥对第（3）步生成的压缩结果进行加密；</li>
<li>发送者采用来自接收者的公钥对第（4）步生成的会话秘钥进行加密；</li>
<li>发送者将加密后的信息和会话秘钥封装成报文一同发送给接收者；</li>
<li>接收者通过自己的私钥将报文中含有的加密的会话秘钥进行解密得到原始的会话秘钥；</li>
<li>接收者利用第（8）步得到的会话秘钥采用和发送者相同的对称秘钥算法对加密信息进行解密，得到压缩后的加密摘要和原始信息；</li>
<li>接收者进行解压缩操作，得到加密摘要和原始信息；</li>
<li>接收者通过从发送者处得到的公钥将报文中包含的摘要进行解密，获得原始未加密的摘要信息；</li>
<li>接收者使用与发送者相同的算法针对报文中含有的原始信息生成一个新的散列值，并与第（11）步得到的解密后的摘要信息进行比对，如果两者完全匹配，则接收者收到的信息来自于发送者（因为接收者用发送者给的公钥解密了发送者发送的加密报文，即身份认证），且在发送过程中未被篡改（接收者生成的摘要和发送者发送的摘要完全匹配，即完整性检查）。</li>
</ol>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1586930445/BlogImages/security/PGP-Introduction-Digital-signature-And-Encryption.png" alt></p>
<div align="center">
    <div align="center">
        图 - 3 PGP 加密和签名工作流程
    </div>
    &emsp;
</div>

<p>&emsp;&emsp;需要注意的是，如果签名和加密都要的话，需要先做签名再做加密，这样可以保证在报文传输过程中发送者的签名信息不会被第三方篡改和替换。如果是先加密，然后对加密后的信息做签名的话，签名信息有可能在传输过程中被第三者替换。</p>
<h3 id="电子邮件的兼容性"><a href="#电子邮件的兼容性" class="headerlink" title="电子邮件的兼容性"></a>电子邮件的兼容性</h3><p>&emsp;&emsp;由于PGP的执行结果是以二进制数据流的形式呈现的，所以有可能在某些电子邮件系统或者其他无法使用和处理二进制数据流的软件中无法正常的传输PGP的加密数据流，所以PGP提供了二进制数据流与文本数据之间相互转换的功能。当需要进行转换时，PGP会将二进制数据转成ASCII radix-64格式的文本数据。</p>
<p>&emsp;&emsp;radix-64在base64的基础上额外增加了检测数据错误的校验和部分。radix-64的处理过程如下：</p>
<ol>
<li>将二进制数据流按照每24个bit位为一组进行分组，也就是三个字节；</li>
<li>对于第(1)步的结果，再对每个三字节分组按照每6个bit位为一组分成四个部分；</li>
<li>每6个bit位的二进制数据可以对应 0 到 $ 2^6 $-1中的任一个值。这个值代表一个可打印的字符。</li>
</ol>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1586939382/BlogImages/security/PGP-Introduction-How-Radix-64-Works.png" alt></p>
<div align="center">
    <div align="center">
        图 - 4 radix-64 工作示意图
    </div>
    &emsp;
</div>

<p><img src="https://res.cloudinary.com/jknight/image/upload/v1586940334/BlogImages/security/PGP-Introduction-Radix-64-demo.png" alt></p>
<div align="center">
    <div align="center">
        图 - 5 radix-64 示例
    </div>
    &emsp;
</div>

<p>&emsp;&emsp;图中”<strong>=njUN</strong>“即为当前PGP消息的校验和内容。</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1586940336/BlogImages/security/PGP-Introduction-Base-64-table.png" alt></p>
<div align="center">
    <div align="center">
        图 - 6 Base64 字符集
    </div>
    &emsp;
</div>

<p>&emsp;&emsp;需要注意的是，radix-64会使得消息长度增加三分之一，但是由于在执行radix-64转换之前已经对消息进行了压缩，所以整体来看，消息的长度并未增加太多。</p>
<h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>&emsp;&emsp;PGP支持可以在有必要的情况下对数据进行压缩，压缩操作通常在加密前进行，可用的算法和格式包括了ZIP、ZLIB、BZIPZ等。之所以对数据进行压缩，一方面是因为压缩后的数据由于体积更小，减轻了传输过程中的时间和存储空间要求。另一方面，对数据进行压缩后能够提高对明文暴力攻击的抵抗能力。</p>
<p>&emsp;&emsp;和签名一样，压缩操作也要在加密之前完成，这么做的初衷是寄希望于提高密码强度。因为压缩后的数据相较于压缩前而言，其冗余程度更低，这样当尝试利用原文中的某种规则性进行破译时，压缩由于消除了规则性而使得其强度显著提升。其次，在暴力破解的场景下，破解者需要尝试每一种秘钥来进行解密工作。如果原文为压缩后的数据，那么破解者需要考虑结果是否被压缩的情形。如果破解者在解密过程中考虑了数据被压缩的情况，那么会使得整个破解过程的时间和成本更大。</p>
<h3 id="分段和重装"><a href="#分段和重装" class="headerlink" title="分段和重装"></a>分段和重装</h3><p>&emsp;&emsp;为了适应最大消息量的限制，PGP可以将一个大文件拆分成若干个文件进行传输（即分段）。同时，也可以将收到的若干个文件重新重装成一个完整的文件。<br>&emsp;</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li><p><strong>什么是数字签名？有什么作用？</strong></p>
<p>数字签名是一种使用了公钥加密算法的技术实现方案，是由发送者生成的一段可以用来鉴别数字信息内容的附加信息。数字签名由公钥加密算法中的私钥生成，通过公钥对签名进行验证和鉴别，因此，数字签名具有身份认证、完整性检查和不可抵赖等特性。通常使用数字签名防止信息在传输过程中可能遇到的伪造、篡改、抵赖等问题。</p>
</li>
<li><p><strong>对称加密和非对称加密（公钥加密）的概念</strong></p>
<p>对称加密指的是加密和解密过程中使用的是同一个秘钥，其主要优点是加密速度快，计算量小，加密效率高的特点，但是对称秘钥在使用过程中需要对秘钥进行分发，秘钥的安全性无法得到保障，且秘钥的管理和维护随着秘钥的增多会越发复杂。</p>
<p>非对称加密（公钥加密）在加密和解密过程中无需同一个秘钥就能完成相应的工作。一般而言，一个非对称加密算法的秘钥对包含了一个公钥和一个私钥，一个公钥加密只能由其对应的私钥解密，同理，一个私钥加密同样只能由其对应的公钥解密。公钥可以通过多种途径对外分发，而私钥是绝对不能对外分发的，所以其保密性更好。但是公钥加密由于算法自身的强度过高而导致加解密速度较慢，所以通常用来加密少量的信息。</p>
</li>
<li><p><strong>散列函数</strong></p>
<p>散列函数是指将任意数据作为输入，能够输出指定长度的数值结果的函数，这个结果就称为输入数据的散列值。在密码学中，对散列函数的要求包括了取散列值的操作要非常容易，但从散列值恢复原始数据的成本大到不实际，以及输入数据的改变一定会造成散列值的变化，以及不同的信息不会产生相同的散列值等。</p>
</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="http://www.philzimmermann.com/EN/background/index.html" target="_blank" rel="noopener">Phil Zimmermann</a></li>
<li>Wikipedia. <a href="https://zh.wikipedia.org/zh-hans/PGP" target="_blank" rel="noopener">PGP</a> [E]</li>
<li>结城浩 [日]. 图解密码技术 第三版 [M] 北京: 人民邮电出版社. 2016.</li>
<li>邓惠洁, 姜明富. <a href="https://www.ixueshu.com/document/cb32586ae4e0afa2318947a18e7f9386.html" target="_blank" rel="noopener">电子邮件系统PGP的加密原理与安全性分析</a> [J]. 现代计算机(专业版), 2010(14):33-35+45.</li>
<li>宋成勇, 胡勇, 陈淑敏, et al. <a href="http://xueshu.baidu.com/usercenter/paper/show?paperid=7b9ea3b2345f685343e226dfe9996329&amp;site=xueshu_se" target="_blank" rel="noopener">PGP工作原理及其安全体制</a> [J]. 电子技术应用, 2004(10):49-51.</li>
<li>荀殿栋. <a href="https://www.ixueshu.com/document/7963918766fbf393318947a18e7f9386.html" target="_blank" rel="noopener">PGP原理与其服务</a> [J]. 军事通信技术, 1998, 019(003):67-73.</li>
<li>Ding Cunsheng. <a href="https://www.cse.ust.hk/faculty/cding/CSIT571/SLIDES/Radix-64.pdf" target="_blank" rel="noopener">Radix-64 Conversion in PGP</a> [E]</li>
</ol>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>加解密</tag>
        <tag>PGP</tag>
      </tags>
  </entry>
  <entry>
    <title>Site Deploy History</title>
    <url>/2018/Site-Deploy-History.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="V23-11-3"><a href="#V23-11-3" class="headerlink" title="V23.11.3"></a>V23.11.3</h1><p>Add:</p>
<ul>
<li>增加思维导图插件的支持</li>
</ul>
<h1 id="V21-4-25"><a href="#V21-4-25" class="headerlink" title="V21.4.25"></a>V21.4.25</h1><p>Add:</p>
<ul>
<li>增加参考文献标注功能</li>
</ul>
<h1 id="21-4-9"><a href="#21-4-9" class="headerlink" title="21.4.9"></a>21.4.9</h1><p>Add:</p>
<ul>
<li>增加本地搜索功能</li>
<li>增加表格折叠功能，优化当表格内容过多导致的页面过长问题</li>
</ul>
<h1 id="V21-4-4"><a href="#V21-4-4" class="headerlink" title="V21.4.4"></a>V21.4.4</h1><p>Add：</p>
<ul>
<li>增加文章中英文切换能力</li>
<li>添加个性化404页面</li>
</ul>
<h1 id="V20-4-17"><a href="#V20-4-17" class="headerlink" title="V20.4.17"></a>V20.4.17</h1><p>Add：</p>
<ul>
<li>增加文章图片单击全屏放大功能</li>
</ul>
<p>Fixed：</p>
<ul>
<li>文章在非常规文章下的尾部显示不匹配问题</li>
<li>优化分类/标签UI</li>
</ul>
<h1 id="V-20-4-2"><a href="#V-20-4-2" class="headerlink" title="V 20.4.2"></a>V 20.4.2</h1><p>Fixed：</p>
<ul>
<li>将mathjax.js的加载方式由官方CDN改为本地加载，js文件加载速度提高</li>
</ul>
<p>TO-DO：</p>
<ul>
<li>修改未通过FireFox验证，待修复</li>
</ul>
<h1 id="V-20-3-20"><a href="#V-20-3-20" class="headerlink" title="V 20.3.20"></a>V 20.3.20</h1><p>Fixed：</p>
<ul>
<li>修复了在主页状态下滚动条滚动问题。当进入主页时鼠标滚轮和方向键不会触发滚动条滚动，可保证当进入首页后滚动条始终置顶</li>
</ul>
<p>TO-DO：</p>
<ul>
<li>主页状态下鼠标左键点击滚动条时，滚动条仍可滚动，待修复</li>
</ul>
<h1 id="V-20-3-2"><a href="#V-20-3-2" class="headerlink" title="V 20.3.2"></a>V 20.3.2</h1><p>Fixed:</p>
<ul>
<li>上一页/下一页标签字符长度超出一行限制时用省略号代替，避免换行</li>
</ul>
<h1 id="v-20-1-20"><a href="#v-20-1-20" class="headerlink" title="v 20.1.20"></a>v 20.1.20</h1><p>Add：</p>
<ul>
<li>增加文章隐藏功能，被隐藏文章不会出现在列表页，上一页/下一页，分类页等位置，唯一可以被访问的方式是通过域名直接访问</li>
</ul>
<h1 id="V18-5-10"><a href="#V18-5-10" class="headerlink" title="V18.5.10"></a>V18.5.10</h1><p>Add：</p>
<ul>
<li>站点第一次发布</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】为什么要实施敏捷</title>
    <url>/2018/The-Why-of-Agile.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;在我很小的时候，家里人给我起了一个绰号：“Bu’why”，这是因为我总是向周围的人问为什么。大多数时候，他们会尝试解答我的问题，但是后来他们给我的这个绰号中也流露出了他们的挫败感。</p>
<p>&emsp;&emsp;直到现在，我依旧执迷于事物背后的真正原因。因为我想知道交通拥堵背后的真正原因，于是我读完了<a href="http://www.amazon.com/gp/product/B001BAGWQE/ref=dp-kindle-redirect?ie=UTF8&amp;btkr=1" target="_blank" rel="noopener">一整本关于交通模式的书籍</a>。因为我想尝试得到更好的休息，我读完了<a href="http://www.amazon.com/gp/product/B008XOG2N4?redirect=true&amp;ref_=kinw_myk_ro_title" target="_blank" rel="noopener">一本关于睡眠的书籍</a>。我坚信，‘为什么’是至关重要的。<br><a id="more"></a></p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><blockquote>
<p>已经被公认或确定的是正确且最高效的商业、专业流程。（<a href="https://en.wikipedia.org/wiki/Best_practice" target="_blank" rel="noopener">维基百科</a>）</p>
</blockquote>
<p>&emsp;&emsp;不幸的是，大多数人想要的是“什么”而不是“为什么”。他们需要处理的事情太多了，他们需要的是能解决他们手上的问题的现成的解决方案：节流、软件模型、制定计划、软件开发方法论、只要你坚持下来，你就能得到承诺于你的一切。</p>
<p>&emsp;&emsp;“我们上一次尝试的系统因为其自身的先天缺陷被视为一个失败品，而这个新系统比上一个更好，这一次一定非常棒。”， Holy Grail 说。可能借助新系统事物的发展不至于太糟糕，但是对其抱有的期望高的有点不切实际了。没有人变得更开心，因为实际上并没有显著的提升。这到底是为什么？</p>
<h2 id="软件开发很复杂"><a href="#软件开发很复杂" class="headerlink" title="软件开发很复杂"></a>软件开发很复杂</h2><p>&emsp;&emsp;2012年，当我在<a href="http://www.startuplessonslearned.com/2011/10/case-study-nordstrom-innovation-lab.html" target="_blank" rel="noopener">Nordstorm创新实验室</a>工作时，我第一次知道了<a href="https://en.wikipedia.org/wiki/Cynefin_Framework" target="_blank" rel="noopener">Cynefin框架</a>。它着眼于给定系统的复杂度，然后来决定什么样的方法可以用在这个系统上。它把系统拆成了<a href="https://commons.wikimedia.org/wiki/File:Cynefin_as_of_1st_June_2014.png" target="_blank" rel="noopener">四个类别，通常用四个象限表示</a>：</p>
<ul>
<li><p><strong>浅显的</strong></p>
</li>
<li><ul>
<li>系统中拥有的关系通俗易懂的而且简单</li>
<li>例子：堆放货架、修剪草坪</li>
<li>方法：确定类别，采用合适的规则集合</li>
</ul>
</li>
<li><p><strong>难懂的</strong></p>
</li>
<li><ul>
<li>需要足够的分析，可以预测到因果关系</li>
<li>例子：摩天大楼，X光机</li>
<li>方法：预先分析场景，确定采用的技术</li>
</ul>
</li>
<li><p><strong>复杂的</strong></p>
</li>
<li><ul>
<li>因果关系仅可以在回顾时得到，但是每次都不会重复</li>
<li>例子：股票市场，天气</li>
<li>方法：调查问题范围，以适应技术</li>
</ul>
</li>
<li><p><strong>混乱的</strong></p>
</li>
<li><ul>
<li>因果关系是无法去感知的</li>
<li>例子：自然灾害和其他紧急事件</li>
<li>方法：应对和适应</li>
</ul>
</li>
</ul>
<p>&emsp;&emsp;你会注意到，越复杂难预测的系统随着时间的推移，创建的那些尝试预测这个系统的规则需要做的适应修改的地方越多。道理都是类似的。就拿股票市场这个复杂的系统来说吧，他的波动规律就经常性地打脸那些尝试预测他的上涨下跌周期的股票理论的脸，作何理论在他面前都变得无用，要在这种领域有所作为，不能一劳永逸，需要不断学习和适应。</p>
<p>&emsp;&emsp;问题是:软件开发在这个连续过程中处在什么位置?有人可能会说这只不过是个工程问题，所以这就像设计建造摩天大楼那样按部就班做即可。另一些开发软件的过程中受到挫折的人，可能会说这就像历史中记载的自然灾害那样完全不可预测。</p>
<p>&emsp;&emsp;有时这很复杂，有时这很混乱无序。大多数时候，这是复杂的。</p>
<h2 id="处理复杂情况"><a href="#处理复杂情况" class="headerlink" title="处理复杂情况"></a>处理复杂情况</h2><p>&emsp;&emsp;Cynefin告诉我们，没有一套最佳实践可以告诉我们如何在给定的复杂系统中采取行动。它也确实指出一些初始的启发式类的方法是有用的，而我们的重点应该是探索问题领域，并随着时间的推移调整我们的方法。</p>
<p>&emsp;&emsp;这听起来很熟悉，不是吗?每当开发团队为给定的项目采用一种新类型的功能时，不确定性就会上升。要知道一个给定的解决方案是否有效，唯一的方法是多探索一下。这就是正在开发的软件系统。还有五个复杂的系统在起作用:</p>
<ul>
<li>开发团队</li>
<li>较大的组织</li>
<li>当前生产环境下的应用</li>
<li>生产环境下应用的用户</li>
<li>商务环境</li>
</ul>
<p>&emsp;&emsp;上述系统中的任意一个都能轻易地导致一个排期紧密的开发项目出现问题：一堆意料之外的影响了正常业务的线上bug，开发团队成员突然的身体不适，业务方提出的关于发展方向上的改变。</p>
<p>&emsp;&emsp;这就是为什么要实施<a href="http://agilemethodology.org/" target="_blank" rel="noopener">敏捷</a>。敏捷帮助开发团队来应对前面提到的所有问题，同时建立一个随时间变化而适应当前形势的框架。敏捷向开发团队提供了一套使之变得最棒、最具有生产力的工具。</p>
<h2 id="关于为什么要实施敏捷的实践"><a href="#关于为什么要实施敏捷的实践" class="headerlink" title="关于为什么要实施敏捷的实践"></a>关于为什么要实施敏捷的实践</h2><p>&emsp;&emsp;接下来会讨论一些特定的“礼仪”以及它们存在的理由。我们需要摆脱“必须”和“应该”的思维模式，我们不这么做是因为它们是必要的，我们这么做是因为我们想从中得到一些我们想要的东西。如果我们没有办法再得到我们想要的，那么我们需要作出一些改变。</p>
<ul>
<li><strong>Sprints</strong> - 人类的规划能力还不是特别的强大。通过任务拆分，如果事情走向出现了问题，他们需要应对的问题就不会特别大。同时，在最开始的时候通过明确任务范围也缩小了外力因素带来的影响。</li>
<li><strong>关于执行完成的严格定义</strong> - 当一个任务已经完成时，确保不会留下任何需要处理的工作来避免“<a href="https://en.wikipedia.org/wiki/Technical_debt" target="_blank" rel="noopener">技术债务</a>”。</li>
<li><strong>故事点而不是小时数</strong> - 确保估算是一种仅用于团队在一段时间内实现计划和执行一致性的工具。 防止管理层认为“开发团队能力不足”，或试图钻制度的空子。</li>
<li><strong>Spikes</strong> - 实际上是从Cynefin复杂域中“调查问题域”来提高确定性并且启动规划。</li>
<li><strong>Sprint 阶段成果</strong> - 开发人员应通过实际完成的产品原型来展示他们的工作成果。庆祝本次Sprint的完成并期待下一个Sprint即将要做的工作。</li>
<li><strong>回顾总结</strong> - 这是敏捷关于适应机制的核心。如果你仅仅做一件事情，那就去做，但是你必须解决在回顾总结过程中暴露出的困难和其他问题。</li>
<li><strong>待办事项列表</strong> - 一旦Sprint启动，在业务方和开发人员之间不应该有频繁的需求变动。在准备开始一个新的sprint会议中，主要由业务方决定本次Sprint中需要完成的事项和任务，当然，有时也需要开发人员的参与。</li>
<li><strong>Sprint计划</strong> - 这个会议的主要目的是开发人员评估任务，同时规划本次Sprint的目标。业务方应该出席会议并对关于本次Sprint中涉及的任务需要最终确认的问题负责解答确认。</li>
</ul>
<p>&emsp;&emsp;现在，那些敏捷教练说的诸如“在你接受采用敏捷的早期，你的估算会被停止”的言论是有道理的。这一切都是因为你处在一个逐步适应和提高的过程中。你的估算会更精确，困难阻碍会被解决，团队也会逐步减少历史遗留下来的技术债务问题。</p>
<h2 id="反馈循环"><a href="#反馈循环" class="headerlink" title="反馈循环"></a>反馈循环</h2><blockquote>
<p>控制系统的一部分，允许其进行反馈和自我修正，以及可以根据实际输出结果和期望的理想输出结果之间的差异调整其接下来的操作。 (<a href="http://www.thefreedictionary.com/feedback+loop" target="_blank" rel="noopener">American Heritage® Dictionary</a>)</p>
</blockquote>
<p>&emsp;&emsp;敏捷可以创建一个引导你走向你的最终目标的反馈循环。每一步都是一个小的胜利，让你感觉良好，给你带来更多的胜利。它就像一个恒温器，只不过你暂时还不知道目标温度是多少。事实证明，反馈循环也是<a href="https://en.wikipedia.org/wiki/Test-driven_development" target="_blank" rel="noopener">测试驱动开发（TTD）</a>和<a href="http://theleanstartup.com/" target="_blank" rel="noopener">精益创业</a>背后的本质。</p>
<p>&emsp;&emsp;这里留给读者一个问题：如何调整你的软件开发反馈循环来使你的团队成为最棒的那个？在我的<a href="https://blog.scottnonnenberg.com/customizing-agile/" target="_blank" rel="noopener">第二篇敏捷文章：可定制的敏捷</a>中，我会为各位读者提供一些思路和想法。</p>
<h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>&emsp;&emsp;本文由<a href="https://my.oschina.net/u/658291" target="_blank" rel="noopener">ZICK_ZEON</a>和作者共同完成，在这里向ZICK_ZEON表示感谢。</p>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>原文链接：<a href="https://blog.chromium.org/2018/09/10-years-of-speed-in-chrome_11.html" target="_blank" rel="noopener">10 years of Speed in Chrome</a> </li>
<li>译文链接：<a href="https://www.oschina.net/translate/the-why-of-agile" target="_blank" rel="noopener">为什么要实施敏捷</a> </li>
</ol>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>外文翻译</category>
      </categories>
      <tags>
        <tag>协作翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数学习笔记01-行列式</title>
    <url>/2018/Linear-algebra-determinant.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><a id="more"></a>
<h2 id="排列与逆序"><a href="#排列与逆序" class="headerlink" title="排列与逆序"></a>排列与逆序</h2><p>&emsp;&emsp;<strong>定义1.1</strong> 在一个n级排列$ i_1i_2…..i_n $中，如果较大的数$ i_t $在较小数$ i_s $前面（$ i_t $ &gt; $ i_s $），则称$ i_t $与$ i_s $构成一个逆序。一个n级排列中逆序的总数称为它的逆序数，记为N（$ i_1i_2…..i_n $）。如果排列$ i_1i_2…..i_n $的逆序数N（$ i_1i_2…..i_n $）是奇数，则称为奇排列，逆序数是偶数则称为偶排列。<br>&emsp;&emsp;在一个排列 $i_1…i_s…i_t…i_n$中，如果仅将它的两个数码$i_s$和$i_t$对调，得到另一个排列 $i_1…i_t…i_s…i_n$,这样的对话记为对换($i_s$，$i_t$)。</p>
<h3 id="逆序数性质"><a href="#逆序数性质" class="headerlink" title="逆序数性质"></a>逆序数性质</h3><p>&emsp;&emsp;<strong>定理1.1</strong> 任意一个排列经过一个对换后改变其奇偶性。</p>
<p>&emsp;&emsp;<strong>定理1.2</strong> n(n &gt; 1)个数码共有n！个n级排列，其中奇、偶排列各占一半。</p>
<h2 id="n阶行列式"><a href="#n阶行列式" class="headerlink" title="n阶行列式"></a>n阶行列式</h2><p>&emsp;&emsp;<strong>定义1.2</strong> 用 $ n^2 $ 个数 $ a_{ij} $(i,j = 1,2,3,…..,n)组成的记号</p>
<script type="math/tex; mode=display">\begin {vmatrix}
     a_{11} & a_{12} & \cdots & a_{1n} \\
     a_{21} & a_{22} & \cdots & a_{2n} \\
     \vdots  & \vdots& \vdots & \vdots \\
     a_{n1} & a_{n2} & \cdots & a_{nn}    
\end {vmatrix}</script><p>称为n阶行列式。其中横排称为行，竖排称为列。它表示所有取自不同的行、列的n个元素乘积的代数和。各项的符号是：当这一项中元素的行标按照自然数顺序排列后，如果对应的列标构成的排列是偶排列取正号，是奇排列则取负号。因此n阶行列式所表示的代数和中的一般项可以写为</p>
<script type="math/tex; mode=display">(-1)^{N(j_1j_2j_3...j_n)}a_{1j_1}a_{2j_2}....a_{nj_n}</script><p>其中，$j_1j_2j_3…j_n$构成一个n级排列，当$ j_1j_2j_3…j_n$取遍所有n级排列时，则得到n级行列式的代数和中所有的项，即 </p>
<script type="math/tex; mode=display">\begin {vmatrix}
     a_{11} & a_{12} & \cdots & a_{1n} \\
     a_{21} & a_{22} & \cdots & a_{2n} \\
     \vdots  & \vdots& \vdots & \vdots \\
     a_{n1} & a_{n2} & \cdots & a_{nn}    
\end {vmatrix}   = \sum(-1)^{N(j_1j_2j_3...j_n)}a_{1j_1}a_{2j_2}....a_{nj_n} .</script><p>&emsp;&emsp;三种特殊的行列式，下三角行列式：</p>
<script type="math/tex; mode=display">D = \begin {vmatrix}
     a_{11} & 0 & 0 &\cdots & 0 \\
     a_{21} & a_{22} & 0 &\cdots & 0 \\
     a_{31} & a_{32} & a_{33} &\cdots & 0 \\
     \vdots  & \vdots& \vdots & \vdots & \vdots\\
     a_{n1} & a_{n2} & a_{n3} & \cdots & a_{nn}    
\end {vmatrix}</script><p>&emsp;&emsp;上三角行列式：</p>
<script type="math/tex; mode=display">D = \begin {vmatrix}
     a_{11} & a_{12} & a_{13} & \cdots & a_{1n} \\
     0 & a_{22} & a_{23} & \cdots & a_{2n} \\
     0 & 0 & a_{33} & \cdots & a_{2n} \\
     \vdots  & \vdots& \vdots & \vdots & \vdots \\
     0 & 0 & 0 & \cdots & a_{nn}  
\end {vmatrix}</script><p>&emsp;&emsp;对角行行列式：</p>
<script type="math/tex; mode=display">D = \begin {vmatrix}
     a_{11} & 0 & 0 &\cdots & 0 \\
     0 & a_{22} & 0 &\cdots & 0 \\
     0 & 0 & a_{33} &\cdots & 0 \\
     \vdots  & \vdots& \vdots & \vdots & \vdots\\
     0 & 0 & 0 & \cdots & a_{nn}    
\end {vmatrix}</script><h3 id="n阶行列式性质"><a href="#n阶行列式性质" class="headerlink" title="n阶行列式性质"></a>n阶行列式性质</h3><p>&emsp;&emsp;<strong>定理1.3</strong> n阶行列式D = |$a_{ij}$|的一般项可以记为 </p>
<script type="math/tex; mode=display">(-1)^{N(i_1i_2i_3...i_n)+N(j_1j_2j_3...j_n)}a_{i_1j_1}a_{i_2j_2}....a_{i_nj_n}.</script><p>其中，$ i_1i_2i_3…i_n $和$ j_1j_2j_3…j_n $均为n阶排列。即</p>
<script type="math/tex; mode=display">\begin {vmatrix}
     a_{11} & a_{12} & \cdots & a_{1n} \\
     a_{21} & a_{22} & \cdots & a_{2n} \\
     \vdots  & \vdots& \vdots & \vdots \\
     a_{n1} & a_{n2} & \cdots & a_{nn}    
\end {vmatrix} = \sum(-1)^{N(i_1i_2i_3...i_n)+N(j_1j_2j_3...j_n)}a_{i_1j_1}a_{i_2j_2}....a_{i_nj_n} .</script><p>&emsp;&emsp;<strong>定理1.4</strong> n阶行列式也可以定义为 </p>
<script type="math/tex; mode=display">D = \sum(-1)^{N(i_1i_2i_3...i_n)}a_{i_11}a_{i_22}....a_{i_nn}.</script><p>其中，$ \sum $表示对所有的n阶排列求和。</p>
<p>&emsp;&emsp;<strong>定理1.5</strong> 行列式与它的转置行列式相等，即</p>
<script type="math/tex; mode=display">D^T = D</script><p>&emsp;&emsp;<strong>定理1.6</strong> 交换行列式的任意两行(列)，行列式变号。<br>&emsp;&emsp;<strong>推论</strong> 如果行列式中有两行（列）的对应元素相同，则此行列式为零。</p>
<p>&emsp;&emsp;<strong>定理1.7</strong> 用数k乘以行列式的一行（列），等于以数k乘以此行列式。即，如果设D=|$a_{ij}$|,则</p>
<script type="math/tex; mode=display">D_1 = \begin {vmatrix}
     a_{11} & a_{12} & \cdots & a_{1n} \\
     \vdots  & \vdots& \vdots & \vdots \\
     ka_{i1} & ka_{i2} & \cdots & ka_{in} \\
     \vdots  & \vdots& \vdots & \vdots \\
     a_{n1} & a_{n2} & \cdots & a_{nn}    
\end {vmatrix}  = k\begin {vmatrix}
     a_{11} & a_{12} & \cdots & a_{1n} \\
     \vdots  & \vdots& \vdots & \vdots \\
     a_{i1} & a_{i2} & \cdots & a_{in} \\
     \vdots  & \vdots& \vdots & \vdots \\
     a_{n1} & a_{n2} & \cdots & a_{nn}    
\end {vmatrix} =kD.</script><p>&emsp;&emsp;<strong>推论1</strong> 如果行列式某行（列）的所有元素有公因子，则公因子可以提到行列式的外面。<br>&emsp;&emsp;<strong>推论2</strong> 如果行列式有两行（列）的对应元素成比例，则行列式为零。</p>
<p>&emsp;&emsp;<strong>定理1.8</strong> 如果行列式D中的某一行（列）的每一个元素都是两个数的和，则此行列式可以写成两个行列式的和，这两个行列式分别以这两个数为所在行（列）对应位置的元素，其他位置的元素与D相同，即如果</p>
<script type="math/tex; mode=display">D = \begin {vmatrix}
     a_{11} & a_{12} & \cdots & a_{1n} \\
     \vdots  & \vdots& \vdots & \vdots \\
     b_{i1} + c_{i1} & b_{i2} + c_{i2} & \cdots & b_{in} + c_{in} \\
     \vdots  & \vdots& \vdots & \vdots \\
     a_{n1} & a_{n2} & \cdots & a_{nn}    
\end {vmatrix} ,</script><script type="math/tex; mode=display">D_1 = \begin {vmatrix}
     a_{11} & a_{12} & \cdots & a_{1n} \\
     \vdots  & \vdots& \vdots & \vdots \\
     b_{i1} & b_{i2} & \cdots & b_{in} \\
     \vdots  & \vdots& \vdots & \vdots \\
     a_{n1} & a_{n2} & \cdots & a_{nn}    
\end {vmatrix} ,  D_2 = \begin {vmatrix}
     a_{11} & a_{12} & \cdots & a_{1n} \\
     \vdots  & \vdots& \vdots & \vdots \\
     c_{i1} & c_{i2} & \cdots & c_{in} \\
     \vdots  & \vdots& \vdots & \vdots \\
     a_{n1} & a_{n2} & \cdots & a_{nn}    
\end {vmatrix} ,</script><p>则<script type="math/tex">D = D_1 + D_2</script><br>&emsp;&emsp;<strong>推论1</strong> 如果将行列式某一行（列）的每一个元素都写成m个数（m为大于2的整数）的和，则此行列式可以写成m个行列式的和。</p>
<p>&emsp;&emsp;<strong>定理1.9</strong> 将行列式某一行（列）的所有元素同乘以数k后加于另一行（列）对应位置的元素上，行列式不变。</p>
<h2 id="行列式按行（列）展开"><a href="#行列式按行（列）展开" class="headerlink" title="行列式按行（列）展开"></a>行列式按行（列）展开</h2><p>&emsp;&emsp;<strong>定义1.3</strong> 在n阶行列式D = |$a_{ij}$|中去掉元素$a_{ij}$所在的第i行和第j列后，余下的n-1阶行列式，称为D中元素$a_{ij}$的余子式，记为$M_{ij}$。在$a_{ij}$的余子式$M_{ij}$前添加符号$(-1)^{i+j}$，称为$a_{ij}$的代数余子式，记为$A_{ij}$，即<script type="math/tex">A_{ij} = (-1)^{i+j}M_{ij} .</script></p>
<p>&emsp;&emsp;<strong>定理1.10</strong> n阶行列式D = |$a_{ij}$|等于它的任意一行（列）的各元素与其对应代数余子式乘积的和，即</p>
<script type="math/tex; mode=display">D = a_{i1}A_{i1} + a_{i2}A_{i2} + a_{i3}A_{i3} + \cdots + a_{in}A_{in}, (i = 1,2,3,\cdots,n),</script><p>或</p>
<script type="math/tex; mode=display">D = a_{1j}A_{1j} + a_{2j}A_{2j} + a_{3j}A_{3j} + \cdots + a_{nj}A_{nj}, (j = 1,2,3,\cdots,n).</script><p>&emsp;&emsp;<strong>定理1.11</strong> n阶行列式D的某一行（列）的元素与另一航（列）的对应位置的元素的代数余子式乘积的和等于0。即</p>
<script type="math/tex; mode=display">a_{i1}A_{s1} + a_{i2}A_{s2} + a_{i3}A_{s3} + \cdots + a_{in}A_{sn} = 0, (i \neq s),</script><p>或</p>
<script type="math/tex; mode=display">
a_{1j}A_{1t} + a_{2j}A_{2t} + a_{3j}A_{3t} + \cdots + a_{nj}A_{nt} = 0, (j \neq t).</script><h2 id="克莱姆法则"><a href="#克莱姆法则" class="headerlink" title="克莱姆法则"></a>克莱姆法则</h2><p>&emsp;&emsp;<strong>定理1.12</strong> 关于线性方程组 </p>
<script type="math/tex; mode=display">\begin{cases}
a_{11}x_1 + a_{12}x_2 + \cdots + a_{1n}x_n = b_1 \\ 
a_{21}x_1 + a_{22}x_2 + \cdots + a_{2n}x_n = b_2 \\ 
\cdots \\ 
a_{n1}x_1 + a_{n2}x_2 + \cdots + a_{nn}x_n = b_n 
\end{cases}</script><p>当其系数行列式  </p>
<script type="math/tex; mode=display">D = \begin {vmatrix}
     a_{11} & a_{12} & \cdots & a_{1n} \\
     a_{21} & a_{22} & \cdots & a_{2n} \\
     \vdots  & \vdots& \vdots & \vdots \\
     a_{n1} & a_{n2} & \cdots & a_{nn}    
\end {vmatrix} \neq 0</script><p>时，有且只有一个唯一解</p>
<script type="math/tex; mode=display">
x_j = \frac{D_j}{D} (j = 1,2,3, \cdots, n)</script><p>其中，$ D_j (j = 1,2,3, \cdots, n) $是将系数行列式中第j列元素$ a_{1j}, a_{2j}, \cdots, a_{nj} $对应地换成方程组的常数项$ b_1, b_2, \cdots, b_n $后得到的行列式。</p>
<p>&emsp;&emsp;<strong>定理1.13</strong> 如果齐次线性方程组 </p>
<script type="math/tex; mode=display">\begin{cases}
a_{11}x_1 + a_{12}x_2 + \cdots + a_{1n}x_n = 0 \\ 
a_{21}x_1 + a_{22}x_2 + \cdots + a_{2n}x_n = 0 \\ 
\cdots \\ 
a_{n1}x_1 + a_{n2}x_2 + \cdots + a_{nn}x_n = 0 
\end{cases}</script><p>的系数行列式$ D \neq 0 $，则它只有零解。<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数学理论</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>技术书籍</title>
    <url>/2019/Tech-Books.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="计算机理论"><a href="#计算机理论" class="headerlink" title="计算机理论"></a>计算机理论</h1><ul>
<li>深入理解计算机系统 第二版</li>
<li>垃圾回收算法手册 自动内存管理的艺术</li>
<li>垃圾回收的算法与实现</li>
</ul>
<h1 id="信息安全"><a href="#信息安全" class="headerlink" title="信息安全"></a>信息安全</h1><ul>
<li>图解密码技术</li>
<li>图解密码技术 第三版</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>技术书籍</tag>
      </tags>
  </entry>
  <entry>
    <title>跳绳感悟</title>
    <url>/2021/Thoughts-of-losing-weight.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;经过半年的坚持，腰带上最里面的那个扣眼终于又能发挥它该有的作用了，喜大普奔，喜极而泣ing。这周过了秤以后发现自己的体重重新回到了80kg大关，离最后的75 ~ 77kg的目标也指日可待。我从这半年堪称煎熬的日子中悟出了一个道理，那就是曾经吃过的汉堡炸鸡烤肉，喝过的肥宅快乐水，都是要还的 T _ T，要么变成汗水，要么变成脂肪，总之，老天不会让你白白享受这么美好的东西的（手动狗头）。</p>
<a id="more"></a>
<p>&emsp;&emsp;人们常说，你在一个目标上付出的努力，时间，精力越多，你就越有希望实现你的目标。对于其他事情而言，这句话怎么说呢，只能说可能性更大一些吧。我自己的一些经历告诉我有的时候即使你付出再多，还是会有可能失败。但是运动或者减肥，或者健身，真的是做到了这一点，童叟无欺。每隔一段时间会录一个阶段视频，脂肪真的在以肉眼可见的速度在消逝。你流了多少汗水，你就会在拥有更好身材这条路上走的更远。至少，我现在不用再因为即使穿上衣服依旧能看到大肚子而难过，我可以更有自信穿上好看的衬衫，帅气的正装。在看了《妙贼警探》这部剧之后就中了正装的毒，毕业后开始撸铁健身，现在减肥刷脂都是在努力实现这个小目标。好看的衬衫有了，正装也有了，就差好身材了，要继续努力啊！！！</p>
<p>&emsp;&emsp;这段时间想了很多，发现这也许是我咬牙坚持逾越的第三个“山头”。上大学的时候因为一次体测跑1000米把自己跑坏了，然后呢就受了刺激，然后就开始晚上下了课跑圈，那是何等的煎熬。从最开始的3圈，到后来可以坚持跑5圈，再到后来跑10圈会很痛苦，但能跑下来，再到后来跑10圈也可以成为家常便饭，再到后来15圈，20圈，一个学期下来可以用一个小时的时间跑完25圈。大学最后一次体测的时候1000m居然成了小组第一拿到了人生第一次90+，这是之前想都不敢想的结果。现在想想，也许这是我“固执”的副作用吧，确定一个目标，咬牙硬杠这期间遇到的困难，直到目标达成。第二个“山头”就是去年的那个考试了，我命里缺数学是妇孺皆知的事情，此外，我还要用比别人少的时间完成和别人相同工作量的复习，甚至要比别人做的更多。生理心理在被现实多次摁在地上摩擦蹂躏之后也变得麻木、崩溃，每天都在质疑自己是否还有继续做下去的希望和必要。每天的状态就是撑过一天赚一天，变成了一个没有感情的复习机器（ ┐(ﾟ～ﾟ)┌ ）。但是很感激自己当初没有放弃坚持了下来，黑夜终将褪去，我也得到了自己期望的结果。这个结果不仅了却了我的愿望，也让我的家人、朋友而自豪。奇怪的是，我的激动不是因为我得到了这个结果，而是我看着家人朋友因为这个结果高兴、激动而激动。也许我以前从来没有好好观察过他们，但是这次我真的，怎么说呢，我因为他们的感动而感动。回到减脂这件事情上，这是我坚持下来的第三个事情。说实话，这半年很痛苦，每天都要和脂肪做斗争，和诱惑做斗争，和自己的惰性做斗争。（这是要斗天斗地斗自己的节奏么）好在坚持下来了，虽然离最后的目标还有个把月的时间，但是都坚持这么久了，应该能走到最后吧。</p>
<p>&emsp;&emsp;做教育辅导的张雪峰曾经说过这么一段话：其实考研带给你们的根本就不是一纸研究生文凭，而是这一年多为了拿到这张通知书你所经历的过程和付出的心血，当你提出一个目标的时候，我相信我一定能做到，因为我做到过。当你再给自己定下一个新的目标的时候你的内心将无所畏惧，因为你做到过，成功过，因为你坚持下来了，因为你发现了一个跟你以前认识自己的那个不一样的自己，你是一个有毅力的人，是一个说到做到的人，是一个提出一个目标就敢于完成这个目标的人。当你完成这个过程的时候，你会发现，前路没有再让你害怕的东西。我想，我应该也会走的更远一些吧，我知道我能走的更远一些，那就走吧，走到走不动为止。</p>
<p>&emsp;&emsp;最后的最后，希望我可以顺顺利利地把减肥这个目标完成，因为减肥只是整个计划的一部分，我想早点穿上帅气的正装，我要做村里最靓的仔！</p>
<p>&emsp;&emsp;为我加油吧。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2018/hello-world.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a></p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】如何构建基于成本的 SQL 优化器？</title>
    <url>/2018/how-we-built-a-cost-based-sql-optimizer.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;在 Cockroach 实验室，我们一直在持续关注性能的提升和可扩展性。为了实现这个目标，我们发布的 2.1  版本产品中包含了一个全新的、从零起步的、基于成本的 SQL  优化器。这个优化器因提供了一个灵活的优化框架会在未来即将发布的版本中带来显著的性能提升，尤其是在一些复杂的报表查询场景中。除此之外，还首次启用了关联子查询等 SQL  功能特性。如果你有一些想要查询速度更快的查询请求场景，把它们交给我们吧！我们正在构建一个用来调节优化器性能的查询库，并以此来规划确定未来工作的优先级顺序。 </p>
<a id="more"></a>
<p>&emsp;&emsp;作为一个工程师，我急切的想要深入了解新优化器是如何工作的（TL;DR -  一个令人兴奋的存在），所以第一件事情就是先要做好各种准备工作。我将会以解释什么是基于成本的 SQL  优化器作为开始，紧接着会告诉你我们是如何决定从众多优化器中选择出最能满足我们需要的一个优化器，以至于我们集合了四个工程师，把他们都关在了封闭的小黑屋里，全权委托他们重写实现了 CockroachDB  的一个主要部件。之后，我会带领大家进入到真正让人着迷的部分，引导大家一探新优化器内部的真面目。鉴于篇幅的缘故，我们不可能完全了解新优化器的全部，因为这不是一篇博文可以做到的。但是也不用太担心，之后还会有详细介绍优化器内部机制的文章不断发布。所以，请各位读者稍安勿躁，敬请期待。 </p>
<h2 id="什么是-SQL-优化器？"><a href="#什么是-SQL-优化器？" class="headerlink" title="什么是 SQL 优化器？"></a>什么是 SQL 优化器？</h2><p>&emsp;&emsp;SQL 优化器会分析一个 SQL 查询语句并选择最高效的方式来执行请求。非常简单的查询可能只有一种执行的方法，与此同时，复杂的查询请求可能有数以千计，甚至数以百万计的方式可供选择。优化器的优化效果越好，就越接近<strong>最佳的执行方案</strong>，而这个最佳方案将会是执行查询请求的最高效方法。</p>
<p>下面是一条看上去简单的查询 SQL ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM customers c, orders o</span><br><span class="line">WHERE c.id=o.cust_id AND c.name &lt; ’John Doe’</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我不会用优化器在处理上述查询时需要考虑的诸多问题让你（或者我）感到无聊和厌烦，但下面的几个注意点会传达出我想要表达的观点:</p>
<ol>
<li>我们应该在表关联前后评估字段名过滤么？</li>
<li>我们应该在索引上使用散列关联、合并关联、或者嵌套循环关联（在 CockroachDB 称为“查找关联”）？</li>
<li>如果是查询关联或者散列关联，我们是要通过枚举客户的方式来查询订单，还是通过枚举订单的方式来查询客户？</li>
<li>如果有一个建立在“name”字段上的辅助索引，我们是否可以通过这个索引来查询匹配的名字？或者说最好用主键索引来查找匹配的id？</li>
</ol>
<p>&emsp;&emsp;除此之外，让优化器孤立地解决上述问题是肯定没办法胜任实际需要的，它需要纵观所有解决方案来发现最好的那一个。可能通过使用查询关联结合辅助索引的方式是非常不错的方法，但如果可以使用合并关联，主键索引会有更好的执行效果。实际上，一个方案是否是最佳的解决方案受数据行总数、众多的硬件运算器的相对性能、数据值的存储位置和查询频率以及其他因素的共同影响。</p>
<h2 id="启发式-vs-基于成本"><a href="#启发式-vs-基于成本" class="headerlink" title="启发式 vs 基于成本"></a>启发式 vs 基于成本</h2><p>&emsp;&emsp;人们是如何在众多可能的执行计划中做出优化选择的？在这件事情上进行开发与思考的历史比我的年龄还要大，所以任何人的回答都会显得不那么精确。但是别灰心，在这个问题上，我们还是有两条通用的途径可以解决的。</p>
<p>&emsp;&emsp;第一条途径是每个人都在第一时间构建自己需要的优化器。人们基于常规原则收集预置的启发式规则。举例来说，假设有一条等式条件是预置的，则可能有一条启发式规则总是使用哈希连接（hash  join）来代替嵌套循环连接。大多数情况下，执行计划在结果上表现得好，那么，这就是一条好的启发式规则。也就是说，像这样的基于规则的优化器就叫做<strong>启发式优化器。</strong></p>
<p>&emsp;&emsp;然而，静态启发式规则也有缺点。他们在大多数情况下工作得很好，但在其他情况下，他们可能找不到最优执行计划。例如，查找联接循环遍历来自外部关系的行，并通过反复探测内部关系上的索引来查找匹配的内部行。当外部行数很少时，这种方法很有效，但是随着外部行数的增加，这种方法会逐渐降低，并且每一行的探测开销开始拖长执行时间。在某些交叉点，散列或合并连接可能会更好。但是很难设计出启发式规则来捕捉这些微妙之处。</p>
<p>&emsp;&emsp;接下来就开始介绍基于成本的优化器。基于成本的优化器将枚举可能的执行计划，并为每个计划分配成本，成本是执行该计划所需的时间和资源的估计值。一旦这些可能性被列举出来，优化器就会选择成本最低的计划并将其交付执行。虽然成本模型通常被设计为最大化吞吐量（即每秒查询），但它也可以被设计为支持其他期望指标的查询行为，例如最小化延迟（即检索第一行的时间）或最小化内存使用。</p>
<p>&emsp;&emsp;基于此，你可能会问：“如果成本模型被证明是有缺陷的怎么办？”。确实如此，基于成本的优化器是否足够好和它分配的成本是成正比的。此外，成本的精确度也高度依赖于优化器评估数据行数时达到的精确度。这听上去就像优化器在执行查询过程中的每个阶段评估实际返回的数据行总数。此时，我们已经引入了另一个研究了数十年的课题：<strong>数据库统计</strong>。</p>
<p>&emsp;&emsp;收集得到的数据库统计信息被发送给优化器希望其可以提供更精确的评估数据行数。有实际帮助的统计信息涵盖了表数据行、无重复的和存在空值的列数以及用于理解值分布的直方图等。这些信息都会传给优化器，优化器依据得到的信息给出关于采用何种关联类型、关联顺序、索引选择以及其他问题的解决方案。</p>
<h2 id="优化器的重生"><a href="#优化器的重生" class="headerlink" title="优化器的重生"></a>优化器的重生</h2><p>&emsp;&emsp;随着时间的推移，CockroachDB从一个简单的、具有启发式探索性质的优化器发展成一个足够复杂的优化器。在2.0版本产品中，基于不可能简单的通过逃避事实的现实，我们开始限制启发式规则的使用数量。经过细微调整过的启发式规则开始与其他规则相互冲突，而我们却很难调查出问题到底出在了哪条规则上。一个非常简单的启发式规则:</p>
<blockquote>
<p>当遇到一个相等条件时采用散列关联</p>
</blockquote>
<p>被变更为</p>
<blockquote>
<p>当遇到一个相等条件时采用三联关联，除非所有的输入参数都是关联键，这种情况下会采用合并关联</p>
</blockquote>
<p>到最后，我们甚至考虑了诸如</p>
<blockquote>
<p>当遇到一个相等条件时采用三联关联，除非所有的输入都是关联键，这种情况下会采用合并关联。如果其中的一个关联输入参数由数量不多的列提供，而其他输入参数可以使用一个有效的索引集，那么就使用查找关联</p>
</blockquote>
<p>这样的规则设置。</p>
<p>&emsp;&emsp;我们加入的每一条启发式规则都必须基于已经存在的规则进行测试检查，以此保证这些新加入的规则可以和其他现有规则正常高效的完成工作。如果说基于成本的优化器是一个平衡的积木塔的话，那么启发探索式优化器则是一个不稳定的结构，非常容易崩溃。</p>
<p>&emsp;&emsp;在2017年后半年，Cockroach实验室内要求取代年代久远的启发探索式优化器的呼声和势头越来越强烈。实验室的联合创始人之一  — Peter  Mattis，安排了一个长达数月的由数据库优化器领域里的专家进行授课的训练营。这个训练营的宗旨是向开发人员传授关于最先进的优化器如何工作的知识，还要求参与学员阅读领域内有影响力的重要文献。为了可以快速决定和推动，Pete创建了一个<a href="https://github.com/petermattis/opttoy" target="_blank" rel="noopener">名叫“opttoy”的基于成本的优化器原型</a>。这个原型演示了一些非常重要的概念，同时也规划了之后的工作方向。</p>
<p>&emsp;&emsp;我在2018年早些时候加入公司，公司达成了当下可以进行下一阶段工作的一致决定。在向我介绍了项目的背景和可能带来的收益之后，我被要求带领一个小团队（团队虽小，但是非常积极主动）从零开始构建一个基于成本的优化器。</p>
<p>&emsp;&emsp;经过9个月的紧张工作，我们团队发布了新优化器的第一个版本，并且该版本被加入到了CockroachDB的2.1版本产品中。新优化器的第一个版本被视为这个项目进行过程中重要的里程牌之一，尽管我们还需要做很多工作来完善优化器。<br>&emsp;&emsp;如下是CockroachDB2.1版本中的优化器已经支持的几个非常重要的新特性：</p>
<ul>
<li><p><strong>关联子查询</strong> - 这些查询请求包含了需要引用外部查询列的内部子查询，比如下面的例子：    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM customers c</span><br><span class="line">WHERE EXISTS (</span><br><span class="line">	SELECT *</span><br><span class="line">	FROM orders o</span><br><span class="line">	WHERE o.cust_id = c.id</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p> 有一篇博客会单独介绍关联子查询的优化，这篇博客会在不久之后完成。</p>
</li>
<li><p><strong>自动规划查询关联</strong>：当需要决定如何执行一个关联操作时，优化器除了合并关联和散列关联之外，还会考虑查询关联。查询关联是一种非常重要的用来快速执行相等关联的手段，经常被用于其中一个输入参数由数量不多的数据行提供，而另一个则具有一个相等条件下的索引集：    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(*)</span><br><span class="line">FROM customers c, orders o</span><br><span class="line">WHERE c.id=o.cust_id AND c.zip=&apos;12345&apos; AND c.name=&apos;John Doe&apos;</span><br></pre></td></tr></table></figure>
<p> 在这个例子中，优化器会决定如何找到第一个客户名为“John Doe”且居住在邮政编码为“12345”地区的客户，然后统计出该客户的下单数。</p>
</li>
</ul>
<h2 id="高级选项"><a href="#高级选项" class="headerlink" title="高级选项"></a>高级选项</h2><p>&emsp;&emsp;正如我之前所说的，我会引导诸位读者一览新优化器的一些高级选项特征。在开始之前，把一个查询想象成一棵树结构，执行计划的中每一个步骤对应树结构的一个节点。事实上，这也是<a href="https://www.cockroachlabs.com/docs/stable/explain.html" target="_blank" rel="noopener">SQL解释器</a>如何展示一个执行计划的整个过程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">group                    |             |</span><br><span class="line"> │                       | aggregate 0 | count_rows()</span><br><span class="line"> │                       | scalar      |</span><br><span class="line"> └── render              |             |</span><br><span class="line">      └── filter         |             |</span><br><span class="line">           │             | filter      | ((id = cust_id) AND</span><br><span class="line">           │             |             | (zip = &apos;12345&apos;)) AND</span><br><span class="line">           │             |             | (name = &apos;John Doe&apos;)</span><br><span class="line">           └── join      |             |</span><br><span class="line">                │        | type        | cross</span><br><span class="line">                ├── scan |             |</span><br><span class="line">                │        | table       | customers@primary</span><br><span class="line">                │        | spans       | ALL</span><br><span class="line">                └── scan |             |</span><br><span class="line">                         | table       | orders@primary</span><br><span class="line">                         | spans       | ALL</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上图所示的输出结果显示了一个<em>未经优化</em>   的查询请求是如何执行的：首先，计算得到一个完整的关于客户表和订单表的交叉乘积结果，之后根据WHERE条件过滤结果集，之后计算结果行数。但是！这个执行过程的性能非常差！如果客户表里有10,000个用户，订单表里有100,000条订单，那么两表交叉乘积后会产生10亿条记录，而大部分数据都是要被过滤废弃掉的，这会造成极大的浪费。</p>
<p>&emsp;&emsp;接下来会证明新优化器的价值所在。新优化器首先会将最开始的执行计划树结构<em>转换</em> 成一系列逻辑上等价的执行计划树，然后从中选出成本最小的那一个。那么问题来了，什么叫“逻辑上等价”呢？两棵执行计划树逻辑上等价意味着这两棵树被执行完成后会返回同样的结果（在没有<code>ORDER BY</code>条件限制时可能数据行顺序不一致）。换言之，从正确性的角度来看，优化器会选中哪个执行计划并不重要，它只关心哪个计划的性能更好。</p>
<h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><p>&emsp;&emsp;新优化器不会一次性生成所有的等价执行计划树。相反，最开始的时候有一个初始化树结构，接着通过一系列递增的转换操作来生成可供选择的树结构。每一次独立的转换操作都是相对简单的；许多简单的转换操作相互结合共同实现复杂的优化需求。观察优化器的运行过程会让你觉得非常不可思议：即使你了解优化器使用的每一个独立的转换操作，它还是会发现可以产生许多令人惊讶的组合，而这些组合可以生产我们从未想到的执行计划。即使对于上述展示的相对简单的查询请求，优化器应用了12个转换操作来实现最终请求。下面展示了4个关键的转换操作流程图。</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1544189634/BlogImages/how-we-built-a-cost-based-sql-optimizer/Cost-based-optimizer-transaction-flow.png" alt></p>
<p>&emsp;&emsp;你可能注意到了为了最大程度的追求性能过滤器条件被向下移动到了join部分，成为了扫描操作的一部分。在最后的转换操作中，优化器决定采用一个带有辅助索引的查询关联来响应查询请求。 </p>
<p>&emsp;&emsp;截止到本文撰写时，基于成本的优化器已经实现了超过160个不同的转换操作，我们会继续在未来的发行版本中加入更多的转换操作类型。由于转换操作完全依赖于新优化器的核心，所以我们花费大量的时间使得这些转换操作尽可能容易的被定义、学习和维护。为了实现这个目的，我们创造了一个称为Optgen的域细节语言(DSL)来表述转换操作的结构，以及用来从DSL生产真实Go语言代码的工具。如下是用Optgen语言表述转换操作的一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[MergeSelectInnerJoin, Normalize]</span><br><span class="line">(Select</span><br><span class="line">	$input:(InnerJoin $left:* $right:* $on:*)</span><br><span class="line">	$filter:*</span><br><span class="line">)</span><br><span class="line">=&gt;</span><br><span class="line">(InnerJoin</span><br><span class="line">	$left</span><br><span class="line">	$right</span><br><span class="line">	(ConcatFilters $on $filter)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个转换将<code>WHERE</code>子句中的条件与内部连接的ON子句中的条件进行了合并。这个操作生成了大约25行的Go语言代码，其中包含了保证传递匹配转换被采用的代码。之后还会有更多的博客文章来详细解释更多的Optgen特性，事实上需要涵盖的内容太多了。如果想要迫切的了解相关知识，<a href="https://github.com/cockroachdb/cockroach/blob/master/pkg/sql/opt/optgen/lang/doc.go" target="_blank" rel="noopener">Optgen文档</a>是一个不错的选择。各位读者也浏览了一些<a href="https://github.com/cockroachdb/cockroach/tree/master/pkg/sql/opt/norm/rules" target="_blank" rel="noopener">转换操作的定义文件</a>，如果你的能力非常优秀，尝试实现一个新的、我们遗漏的转换操作，我们对社区贡献持非常欢迎的态度。</p>
<h2 id="备忘"><a href="#备忘" class="headerlink" title="备忘"></a>备忘</h2><p>&emsp;&emsp;我已经解释了新发布的优化器是如何生成许多的等价执行计划，并且基于成本估计选择其中最理想的一个执行计划。理论上这一套机制听上去还不错，但是优化器实际的效果怎么样呢？它会不会有可能需要指数级的内存空间来存储生成的这些计划？我们可以从一个被称为备忘的精巧的数据结构中得到这个问题的答案。</p>
<p>&emsp;&emsp;备忘被设计用来利用计划之间有意义的冗余来有效存储根据一个给定的查询请求生成的所有执行计划树集合。例如，一个关联查询可能有数个逻辑上相等的、从各个方面角度看都完全相同的执行计划，只不过一个计划采用了散列关联，一个计划采用了合并关联，另一个采用查询关联。除此之外，每个计划可能会有多个变量：一个变量里左连接输入参数使用主键索引来扫描行，在另一个变量里使用辅助索引做相同的工作。单纯地编码的话，这会因为计划的指数膨胀导致需要指数范围的空间来存储这些计划树。</p>
<p>&emsp;&emsp;备忘通过定义一个名为备忘组的等值类集合来解决上述问题，在每个备忘组中包含了一个逻辑上等值的表达式集合。下图详细说明了备忘组的工作原理： </p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1544189628/BlogImages/how-we-built-a-cost-based-sql-optimizer/Cost-based-optimizer-memo-how-work.png" alt></p>
<p>&emsp;&emsp;为了构建一个执行计划，从组1中选任意一个运算符，然后分别从组2和组3中选择操作的左操作数和右操作数。因为在同一个组里的运算符一定是逻辑上相等的，所以不管你选中的是什么，你都会得到一个合法执行计划。简单的算术计算显示了共有12个（3 <em> 2 </em>  2）可能的执行计划会被编码到备忘里。所以，可以尽情想象一下拥有6种关联方式、复杂的聚合、众多的过滤器条件的报表查询可能带来的复杂度。其生成的计划树可能会以千计，如果你对备忘结构一无所知，那么在编码过程过程中需要的存储空间比你期望的要小的多。 </p>
<p>&emsp;&emsp;当然，新的优化器不会随机的从备忘中挑选其中的一个执行方案树。相反，它会记录并选择每个备忘组中成本最小的那一个，然后基于这些选择的表达式中递归构建最终的执行方案。而且，备忘也是一种优雅的数据结构，这让我想起了Dan Brown的小说《天使与魔鬼》中<a href="http://www.johnlangdon.net/works/earth-air-fire-water/" target="_blank" rel="noopener">光明会(illuminati)的钻石</a>双重性。两者都会编码出比看上去可能更多的信息。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;我们团队计划在接下来的时间内连续推出关于CockroachDB内部基于成本的优化器的内部分析文章。在这篇文章里，我仅涉及了优化器的表象。联系我们告诉我们你感兴趣的主题和方向，或者更好的方式是<a href="https://www.cockroachlabs.com/careers/#jobs" target="_blank" rel="noopener">加入Cockroach实验室</a>，与我们共同构建可以一个在全球范围内广泛使用的ACID数据库。</p>
<p>&emsp;</p>
<h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>&emsp;&emsp;本文由<a href="https://my.oschina.net/crooner" target="_blank" rel="noopener">溪边九节</a>, <a href="https://my.oschina.net/u/2560193" target="_blank" rel="noopener">雪落无痕xdj</a>和作者共同完成，在这里向两位表示感谢并期待下一次的合作。</p>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>原文链接：<a href="https://blog.chromium.org/2018/09/10-years-of-speed-in-chrome_11.html" target="_blank" rel="noopener">10 years of Speed in Chrome</a> </li>
<li>首发链接：<a href="https://www.oschina.net/translate/building-cost-based-sql-optimizer" target="_blank" rel="noopener">如何构建基于成本的 SQL 优化器？</a></li>
</ol>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>外文翻译</category>
      </categories>
      <tags>
        <tag>协作翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>Java I/O 25 - BlockDataInputStream</title>
    <url>/2018/java-BlockDataInputStream.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;关于<em> <strong>java.io.ObjectInputStream.BlockDataInputStream</strong> </em>的部分笔记，该类是ObjectInputStream的底层数据读取类，用来完成从流中读取数据的所有操作。本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;BlockDataInputStream有两个读取模式：默认模式中，输入数据按照和DataOutputStream一样的格式被写入，如果在块数据模式中，输入数据被块数据标记包围写入。是否采用缓存支持取决于读取模式，默认模式不会采用缓存机制来获取数据，所有数据直接从底层输入流获取。反之，如果是块数据模式那么数据会被缓存下来供以后读取需要。</p>
<p>&emsp;</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BlockDataInputStream</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.io.InputStream</span><br><span class="line">    --java.io.ObjectInputStream</span><br><span class="line">      --java.io.ObjectInputStream.BlockDataInputStream</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><div class="table-container">
<table>
<thead>
<tr>
<th>类名</th>
<th>实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>BlockDataInputStream</td>
<td>Closeable, DataInput, AutoCloseable</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="BlockDataInputStream"><a href="#BlockDataInputStream" class="headerlink" title="BlockDataInputStream"></a>BlockDataInputStream</h2><h3 id="Constructor-Summary"><a href="#Constructor-Summary" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="public-ObjectInputStream-InputStream-in"><a href="#public-ObjectInputStream-InputStream-in" class="headerlink" title="public ObjectInputStream(InputStream in)"></a>public ObjectInputStream(InputStream in)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BlockDataInputStream(InputStream in) &#123;</span><br><span class="line">    <span class="keyword">this</span>.in = <span class="keyword">new</span> PeekInputStream(in);</span><br><span class="line">    din = <span class="keyword">new</span> DataInputStream(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;根据指定输入流初始化一个底层输入流和一个DataInputStream实例。块数据模式默认被置为false。</p>
<h3 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="boolean-setBlockDataMode-boolean-newmode"><a href="#boolean-setBlockDataMode-boolean-newmode" class="headerlink" title="boolean setBlockDataMode(boolean newmode)"></a>boolean setBlockDataMode(boolean newmode)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">setBlockDataMode</span><span class="params">(<span class="keyword">boolean</span> newmode)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (blkmode == newmode) &#123;</span><br><span class="line">        <span class="keyword">return</span> blkmode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newmode) &#123;</span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">        end = <span class="number">0</span>;</span><br><span class="line">        unread = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pos &lt; end) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"unread block data"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    blkmode = newmode;</span><br><span class="line">    <span class="keyword">return</span> !blkmode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;设置块数据读取模式，true为on，false为off，并返回设置之前的读取模式值。如果在模式从on到off的切换过程中尚有数据需要读取，那么就抛出<strong>IllegalStateException</strong>异常。</p>
<h4 id="boolean-getBlockDataMode"><a href="#boolean-getBlockDataMode" class="headerlink" title="boolean getBlockDataMode()"></a>boolean getBlockDataMode()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">getBlockDataMode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> blkmode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;获取块数据读取模式。</p>
<h4 id="void-skipBlockData"><a href="#void-skipBlockData" class="headerlink" title="void skipBlockData()"></a>void skipBlockData()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">skipBlockData</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!blkmode) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"not in block data mode"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (end &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        refill();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;跳过当前数据块到达当前数据块的结尾位置。如果当前模式不是on，那么抛出异常。refill()方法完成实际的跳过操作。</p>
<h4 id="private-void-refill"><a href="#private-void-refill" class="headerlink" title="private void refill()"></a>private void refill()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refill</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (unread &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> n =</span><br><span class="line">                    in.read(buf, <span class="number">0</span>, Math.min(unread, MAX_BLOCK_SIZE));</span><br><span class="line">                <span class="keyword">if</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    end = n;</span><br><span class="line">                    unread -= n;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> StreamCorruptedException(</span><br><span class="line">                        <span class="string">"unexpected EOF in middle of data block"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> n = readBlockHeader(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">if</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    end = <span class="number">0</span>;</span><br><span class="line">                    unread = n;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    end = -<span class="number">1</span>;</span><br><span class="line">                    unread = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pos == end);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">        end = -<span class="number">1</span>;</span><br><span class="line">        unread = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;用块数据重新填充内部缓冲区buffer。在方法被调用时，buffer中存在的数据被认为是消费过的。新的pos，end，unread字段被认为是新的块数据信息。操作流程如图1所示：</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1544515541/BlogImages/Serializable-related/ObjectInputStream-BlockDataInputStream-refill-example.png" alt></p>
<div align="center">
<div align="center">图 - 1</div>
&emsp;
</div>

<h4 id="private-int-readBlockHeader-boolean-canBlock"><a href="#private-int-readBlockHeader-boolean-canBlock" class="headerlink" title="private int readBlockHeader(boolean canBlock)"></a>private int readBlockHeader(boolean canBlock)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">readBlockHeader</span><span class="params">(<span class="keyword">boolean</span> canBlock)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (defaultDataEnd) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Fix for 4360508: stream is currently at the end of a field</span></span><br><span class="line"><span class="comment">         * value block written via default serialization; since there</span></span><br><span class="line"><span class="comment">         * is no terminating TC_ENDBLOCKDATA tag, simulate</span></span><br><span class="line"><span class="comment">         * end-of-custom-data behavior explicitly.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> avail = canBlock ? Integer.MAX_VALUE : in.available();</span><br><span class="line">            <span class="keyword">if</span> (avail == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> HEADER_BLOCKED;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> tc = in.peek();</span><br><span class="line">            <span class="keyword">switch</span> (tc) &#123;</span><br><span class="line">                <span class="keyword">case</span> TC_BLOCKDATA:</span><br><span class="line">                    <span class="keyword">if</span> (avail &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> HEADER_BLOCKED;</span><br><span class="line">                    &#125;</span><br><span class="line">                    in.readFully(hbuf, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">                    <span class="keyword">return</span> hbuf[<span class="number">1</span>] &amp; <span class="number">0xFF</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> TC_BLOCKDATALONG:</span><br><span class="line">                    <span class="keyword">if</span> (avail &lt; <span class="number">5</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> HEADER_BLOCKED;</span><br><span class="line">                    &#125;</span><br><span class="line">                    in.readFully(hbuf, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">                    <span class="keyword">int</span> len = Bits.getInt(hbuf, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> StreamCorruptedException(</span><br><span class="line">                            <span class="string">"illegal block data header length: "</span> +</span><br><span class="line">                            len);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> len;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * TC_RESETs may occur in between data blocks.</span></span><br><span class="line"><span class="comment">                     * Unfortunately, this case must be parsed at a lower</span></span><br><span class="line"><span class="comment">                     * level than other typecodes, since primitive data</span></span><br><span class="line"><span class="comment">                     * reads may span data blocks separated by a TC_RESET.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                <span class="keyword">case</span> TC_RESET:</span><br><span class="line">                    in.read();</span><br><span class="line">                    handleReset();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">if</span> (tc &gt;= <span class="number">0</span> &amp;&amp; (tc &lt; TC_BASE || tc &gt; TC_MAX)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> StreamCorruptedException(</span><br><span class="line">                            String.format(<span class="string">"invalid type code: %02X"</span>, tc));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (EOFException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StreamCorruptedException(</span><br><span class="line">            <span class="string">"unexpected EOF while reading block data header"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;尝试读取下一个块数据的头部信息，并返回头部指定的块数据长度。</p>
<h4 id="int-currentBlockRemaining"><a href="#int-currentBlockRemaining" class="headerlink" title="int currentBlockRemaining()"></a>int currentBlockRemaining()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">currentBlockRemaining</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (blkmode) &#123;</span><br><span class="line">        <span class="keyword">return</span> (end &gt;= <span class="number">0</span>) ? (end - pos) + unread : <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回当前数据块中剩余的可读数据长度。如果是块数据模式，那么就返回剩余长度，否则抛出异常。</p>
<h4 id="int-peek"><a href="#int-peek" class="headerlink" title="int peek()"></a>int peek()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (blkmode) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos == end) &#123;</span><br><span class="line">            refill();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (end &gt;= <span class="number">0</span>) ? (buf[pos] &amp; <span class="number">0xFF</span>) : -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> in.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;获取（但不会消费掉）下一个字节的内容。如果是块数据模式，那么尝试从底层缓冲区buffer中取数据，否则直接调用底层输入流获取。</p>
<h4 id="byte-peekByte"><a href="#byte-peekByte" class="headerlink" title="byte peekByte()"></a>byte peekByte()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">byte</span> <span class="title">peekByte</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val = peek();</span><br><span class="line">    <span class="keyword">if</span> (val &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">byte</span>) val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;获取（但不会消费掉）下一个字节的内容，内容以字节类型返回。</p>
<h4 id="public-int-read"><a href="#public-int-read" class="headerlink" title="public int read()"></a>public int read()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (blkmode) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos == end) &#123;</span><br><span class="line">            refill();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (end &gt;= <span class="number">0</span>) ? (buf[pos++] &amp; <span class="number">0xFF</span>) : -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;获取下一个字节的内容。如果是块数据模式，那么尝试从底层缓冲区buffer中取数据，否则直接调用底层输入流获取。</p>
<h4 id="public-int-read-byte-b-int-off-int-len"><a href="#public-int-read-byte-b-int-off-int-len" class="headerlink" title="public int read(byte[] b, int off, int len)"></a>public int read(byte[] b, int off, int len)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> read(b, off, len, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;获取字节内容，并存储到字节数组b中自off位置起，长度为len的空间内。返回实际读取的字符内容长度。</p>
<h4 id="int-read-byte-b-int-off-int-len-boolean-copy"><a href="#int-read-byte-b-int-off-int-len-boolean-copy" class="headerlink" title="int read(byte[] b, int off, int len, boolean copy)"></a>int read(byte[] b, int off, int len, boolean copy)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len, <span class="keyword">boolean</span> copy)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (blkmode) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos == end) &#123;</span><br><span class="line">            refill();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nread = Math.min(len, end - pos);</span><br><span class="line">        System.arraycopy(buf, pos, b, off, nread);</span><br><span class="line">        pos += nread;</span><br><span class="line">        <span class="keyword">return</span> nread;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (copy) &#123;</span><br><span class="line">        <span class="keyword">int</span> nread = in.read(buf, <span class="number">0</span>, Math.min(len, MAX_BLOCK_SIZE));</span><br><span class="line">        <span class="keyword">if</span> (nread &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.arraycopy(buf, <span class="number">0</span>, b, off, nread);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nread;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> in.read(b, off, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果是块数据读取模式，尝试从底层缓冲区buffer中获取数据。如果copy为true，那么首先将读取的数据保存到底层缓冲区buffer中，然后在将数据返回到b中。如果不是快数据读取模式，那么直接从底层输入流获取数据。</p>
<h4 id="public-long-skip-long-len"><a href="#public-long-skip-long-len" class="headerlink" title="public long skip(long len)"></a>public long skip(long len)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> remain = len;</span><br><span class="line">    <span class="keyword">while</span> (remain &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (blkmode) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos == end) &#123;</span><br><span class="line">                refill();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> nread = (<span class="keyword">int</span>) Math.min(remain, end - pos);</span><br><span class="line">            remain -= nread;</span><br><span class="line">            pos += nread;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> nread = (<span class="keyword">int</span>) Math.min(remain, MAX_BLOCK_SIZE);</span><br><span class="line">            <span class="keyword">if</span> ((nread = in.read(buf, <span class="number">0</span>, nread)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            remain -= nread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len - remain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;跳过当前块数据中长度为len的内容。</p>
<h4 id="public-int-available"><a href="#public-int-available" class="headerlink" title="public int available()"></a>public int available()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">available</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (blkmode) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pos == end) &amp;&amp; (unread == <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">while</span> ((n = readBlockHeader(<span class="keyword">false</span>)) == <span class="number">0</span>) ;</span><br><span class="line">            <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">                <span class="keyword">case</span> HEADER_BLOCKED:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> -<span class="number">1</span>:</span><br><span class="line">                    pos = <span class="number">0</span>;</span><br><span class="line">                    end = -<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    pos = <span class="number">0</span>;</span><br><span class="line">                    end = <span class="number">0</span>;</span><br><span class="line">                    unread = n;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// avoid unnecessary call to in.available() if possible</span></span><br><span class="line">        <span class="keyword">int</span> unreadAvail = (unread &gt; <span class="number">0</span>) ? Math.min(in.available(), unread) : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (end &gt;= <span class="number">0</span>) ? (end - pos) + unreadAvail : <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> in.available();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回当前块数据中剩余可读的数据量。</p>
<h4 id="public-void-close"><a href="#public-void-close" class="headerlink" title="public void close()"></a>public void close()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (blkmode) &#123;</span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">        end = -<span class="number">1</span>;</span><br><span class="line">        unread = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    in.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;关闭当前底层输入流。</p>
<h4 id="primitive-data-input-methods"><a href="#primitive-data-input-methods" class="headerlink" title="primitive data input methods"></a>primitive data input methods</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ----------------- primitive data input methods ------------------ */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFully</span><span class="params">(<span class="keyword">byte</span>[] b)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    readFully(b, <span class="number">0</span>, b.length, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFully</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    readFully(b, off, len, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFully</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len, <span class="keyword">boolean</span> copy)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = read(b, off, len, copy);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</span><br><span class="line">        &#125;</span><br><span class="line">        off += n;</span><br><span class="line">        len -= n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">skipBytes</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> din.skipBytes(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">readBoolean</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v = read();</span><br><span class="line">    <span class="keyword">if</span> (v &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (v != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">readByte</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v = read();</span><br><span class="line">    <span class="keyword">if</span> (v &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">byte</span>) v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readUnsignedByte</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v = read();</span><br><span class="line">    <span class="keyword">if</span> (v &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">readChar</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!blkmode) &#123;</span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">        in.readFully(buf, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end - pos &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> din.readChar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> v = Bits.getChar(buf, pos);</span><br><span class="line">    pos += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">short</span> <span class="title">readShort</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!blkmode) &#123;</span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">        in.readFully(buf, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end - pos &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> din.readShort();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">short</span> v = Bits.getShort(buf, pos);</span><br><span class="line">    pos += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readUnsignedShort</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!blkmode) &#123;</span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">        in.readFully(buf, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end - pos &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> din.readUnsignedShort();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> v = Bits.getShort(buf, pos) &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">    pos += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readInt</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!blkmode) &#123;</span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">        in.readFully(buf, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end - pos &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> din.readInt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> v = Bits.getInt(buf, pos);</span><br><span class="line">    pos += <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">readFloat</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!blkmode) &#123;</span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">        in.readFully(buf, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end - pos &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> din.readFloat();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">float</span> v = Bits.getFloat(buf, pos);</span><br><span class="line">    pos += <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">readLong</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!blkmode) &#123;</span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">        in.readFully(buf, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end - pos &lt; <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> din.readLong();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> v = Bits.getLong(buf, pos);</span><br><span class="line">    pos += <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">readDouble</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!blkmode) &#123;</span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">        in.readFully(buf, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end - pos &lt; <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> din.readDouble();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> v = Bits.getDouble(buf, pos);</span><br><span class="line">    pos += <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">readUTF</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> readUTFBody(readUnsignedShort());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">readLine</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> din.readLine();      <span class="comment">// deprecated, not worth optimizing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="primitive-data-array-input-methods"><a href="#primitive-data-array-input-methods" class="headerlink" title="primitive data array input methods"></a>primitive data array input methods</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -------------- primitive data array input methods --------------- */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readBooleans</span><span class="params">(<span class="keyword">boolean</span>[] v, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> stop, endoff = off + len;</span><br><span class="line">    <span class="keyword">while</span> (off &lt; endoff) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!blkmode) &#123;</span><br><span class="line">            <span class="keyword">int</span> span = Math.min(endoff - off, MAX_BLOCK_SIZE);</span><br><span class="line">            in.readFully(buf, <span class="number">0</span>, span);</span><br><span class="line">            stop = off + span;</span><br><span class="line">            pos = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end - pos &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            v[off++] = din.readBoolean();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stop = Math.min(endoff, off + end - pos);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (off &lt; stop) &#123;</span><br><span class="line">            v[off++] = Bits.getBoolean(buf, pos++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readChars</span><span class="params">(<span class="keyword">char</span>[] v, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> stop, endoff = off + len;</span><br><span class="line">    <span class="keyword">while</span> (off &lt; endoff) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!blkmode) &#123;</span><br><span class="line">            <span class="keyword">int</span> span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            in.readFully(buf, <span class="number">0</span>, span &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            stop = off + span;</span><br><span class="line">            pos = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end - pos &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            v[off++] = din.readChar();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stop = Math.min(endoff, off + ((end - pos) &gt;&gt; <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (off &lt; stop) &#123;</span><br><span class="line">            v[off++] = Bits.getChar(buf, pos);</span><br><span class="line">            pos += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readShorts</span><span class="params">(<span class="keyword">short</span>[] v, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> stop, endoff = off + len;</span><br><span class="line">    <span class="keyword">while</span> (off &lt; endoff) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!blkmode) &#123;</span><br><span class="line">            <span class="keyword">int</span> span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            in.readFully(buf, <span class="number">0</span>, span &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            stop = off + span;</span><br><span class="line">            pos = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end - pos &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            v[off++] = din.readShort();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stop = Math.min(endoff, off + ((end - pos) &gt;&gt; <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (off &lt; stop) &#123;</span><br><span class="line">            v[off++] = Bits.getShort(buf, pos);</span><br><span class="line">            pos += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readInts</span><span class="params">(<span class="keyword">int</span>[] v, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> stop, endoff = off + len;</span><br><span class="line">    <span class="keyword">while</span> (off &lt; endoff) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!blkmode) &#123;</span><br><span class="line">            <span class="keyword">int</span> span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; <span class="number">2</span>);</span><br><span class="line">            in.readFully(buf, <span class="number">0</span>, span &lt;&lt; <span class="number">2</span>);</span><br><span class="line">            stop = off + span;</span><br><span class="line">            pos = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end - pos &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            v[off++] = din.readInt();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stop = Math.min(endoff, off + ((end - pos) &gt;&gt; <span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (off &lt; stop) &#123;</span><br><span class="line">            v[off++] = Bits.getInt(buf, pos);</span><br><span class="line">            pos += <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readFloats</span><span class="params">(<span class="keyword">float</span>[] v, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> span, endoff = off + len;</span><br><span class="line">    <span class="keyword">while</span> (off &lt; endoff) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!blkmode) &#123;</span><br><span class="line">            span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; <span class="number">2</span>);</span><br><span class="line">            in.readFully(buf, <span class="number">0</span>, span &lt;&lt; <span class="number">2</span>);</span><br><span class="line">            pos = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end - pos &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            v[off++] = din.readFloat();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            span = Math.min(endoff - off, ((end - pos) &gt;&gt; <span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bytesToFloats(buf, pos, v, off, span);</span><br><span class="line">        off += span;</span><br><span class="line">        pos += span &lt;&lt; <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readLongs</span><span class="params">(<span class="keyword">long</span>[] v, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> stop, endoff = off + len;</span><br><span class="line">    <span class="keyword">while</span> (off &lt; endoff) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!blkmode) &#123;</span><br><span class="line">            <span class="keyword">int</span> span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; <span class="number">3</span>);</span><br><span class="line">            in.readFully(buf, <span class="number">0</span>, span &lt;&lt; <span class="number">3</span>);</span><br><span class="line">            stop = off + span;</span><br><span class="line">            pos = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end - pos &lt; <span class="number">8</span>) &#123;</span><br><span class="line">            v[off++] = din.readLong();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stop = Math.min(endoff, off + ((end - pos) &gt;&gt; <span class="number">3</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (off &lt; stop) &#123;</span><br><span class="line">            v[off++] = Bits.getLong(buf, pos);</span><br><span class="line">            pos += <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readDoubles</span><span class="params">(<span class="keyword">double</span>[] v, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> span, endoff = off + len;</span><br><span class="line">    <span class="keyword">while</span> (off &lt; endoff) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!blkmode) &#123;</span><br><span class="line">            span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; <span class="number">3</span>);</span><br><span class="line">            in.readFully(buf, <span class="number">0</span>, span &lt;&lt; <span class="number">3</span>);</span><br><span class="line">            pos = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end - pos &lt; <span class="number">8</span>) &#123;</span><br><span class="line">            v[off++] = din.readDouble();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            span = Math.min(endoff - off, ((end - pos) &gt;&gt; <span class="number">3</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bytesToDoubles(buf, pos, v, off, span);</span><br><span class="line">        off += span;</span><br><span class="line">        pos += span &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="String-readLongUTF"><a href="#String-readLongUTF" class="headerlink" title="String readLongUTF()"></a>String readLongUTF()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">readLongUTF</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> readUTFBody(readLong());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;读取并返回以长UTF格式写入流中的字符串。长UTF格式有别于标准的UTF格式，因为长UTF格式采用8个比特位作为头部来传输UTF编码长度，而标准UTF只有两个比特位。</p>
<h4 id="private-String-readUTFBody-long-utflen"><a href="#private-String-readUTFBody-long-utflen" class="headerlink" title="private String readUTFBody(long utflen)"></a>private String readUTFBody(long utflen)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">readUTFBody</span><span class="params">(<span class="keyword">long</span> utflen)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    StringBuilder sbuf = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">if</span> (!blkmode) &#123;</span><br><span class="line">        end = pos = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (utflen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> avail = end - pos;</span><br><span class="line">        <span class="keyword">if</span> (avail &gt;= <span class="number">3</span> || (<span class="keyword">long</span>) avail == utflen) &#123;</span><br><span class="line">            utflen -= readUTFSpan(sbuf, utflen);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (blkmode) &#123;</span><br><span class="line">                <span class="comment">// near block boundary, read one byte at a time</span></span><br><span class="line">                utflen -= readUTFChar(sbuf, utflen);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// shift and refill buffer manually</span></span><br><span class="line">                <span class="keyword">if</span> (avail &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.arraycopy(buf, pos, buf, <span class="number">0</span>, avail);</span><br><span class="line">                &#125;</span><br><span class="line">                pos = <span class="number">0</span>;</span><br><span class="line">                end = (<span class="keyword">int</span>) Math.min(MAX_BLOCK_SIZE, utflen);</span><br><span class="line">                in.readFully(buf, avail, end - avail);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sbuf.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;读取并返回UTF编码除了头部之外的数据内容。</p>
<h4 id="private-long-readUTFSpan-StringBuilder-sbuf-long-utflen"><a href="#private-long-readUTFSpan-StringBuilder-sbuf-long-utflen" class="headerlink" title="private long readUTFSpan(StringBuilder sbuf, long utflen)"></a>private long readUTFSpan(StringBuilder sbuf, long utflen)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">readUTFSpan</span><span class="params">(StringBuilder sbuf, <span class="keyword">long</span> utflen)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cpos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> start = pos;</span><br><span class="line">    <span class="keyword">int</span> avail = Math.min(end - pos, CHAR_BUF_SIZE);</span><br><span class="line">    <span class="comment">// stop short of last char unless all of utf bytes in buffer</span></span><br><span class="line">    <span class="keyword">int</span> stop = pos + ((utflen &gt; avail) ? avail - <span class="number">2</span> : (<span class="keyword">int</span>) utflen);</span><br><span class="line">    <span class="keyword">boolean</span> outOfBounds = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (pos &lt; stop) &#123;</span><br><span class="line">            <span class="keyword">int</span> b1, b2, b3;</span><br><span class="line">            b1 = buf[pos++] &amp; <span class="number">0xFF</span>;</span><br><span class="line">            <span class="keyword">switch</span> (b1 &gt;&gt; <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="number">7</span>:   <span class="comment">// 1 byte format: 0xxxxxxx</span></span><br><span class="line">                    cbuf[cpos++] = (<span class="keyword">char</span>) b1;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="number">13</span>:  <span class="comment">// 2 byte format: 110xxxxx 10xxxxxx</span></span><br><span class="line">                    b2 = buf[pos++];</span><br><span class="line">                    <span class="keyword">if</span> ((b2 &amp; <span class="number">0xC0</span>) != <span class="number">0x80</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> UTFDataFormatException();</span><br><span class="line">                    &#125;</span><br><span class="line">                    cbuf[cpos++] = (<span class="keyword">char</span>) (((b1 &amp; <span class="number">0x1F</span>) &lt;&lt; <span class="number">6</span>) |</span><br><span class="line">                                           ((b2 &amp; <span class="number">0x3F</span>) &lt;&lt; <span class="number">0</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="number">14</span>:  <span class="comment">// 3 byte format: 1110xxxx 10xxxxxx 10xxxxxx</span></span><br><span class="line">                    b3 = buf[pos + <span class="number">1</span>];</span><br><span class="line">                    b2 = buf[pos + <span class="number">0</span>];</span><br><span class="line">                    pos += <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> ((b2 &amp; <span class="number">0xC0</span>) != <span class="number">0x80</span> || (b3 &amp; <span class="number">0xC0</span>) != <span class="number">0x80</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> UTFDataFormatException();</span><br><span class="line">                    &#125;</span><br><span class="line">                    cbuf[cpos++] = (<span class="keyword">char</span>) (((b1 &amp; <span class="number">0x0F</span>) &lt;&lt; <span class="number">12</span>) |</span><br><span class="line">                                           ((b2 &amp; <span class="number">0x3F</span>) &lt;&lt; <span class="number">6</span>) |</span><br><span class="line">                                           ((b3 &amp; <span class="number">0x3F</span>) &lt;&lt; <span class="number">0</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">default</span>:  <span class="comment">// 10xx xxxx, 1111 xxxx</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> UTFDataFormatException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException ex) &#123;</span><br><span class="line">        outOfBounds = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (outOfBounds || (pos - start) &gt; utflen) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * Fix for 4450867: if a malformed utf char causes the</span></span><br><span class="line"><span class="comment">                     * conversion loop to scan past the expected end of the utf</span></span><br><span class="line"><span class="comment">                     * string, only consume the expected number of utf bytes.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">            pos = start + (<span class="keyword">int</span>) utflen;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UTFDataFormatException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sbuf.append(cbuf, <span class="number">0</span>, cpos);</span><br><span class="line">    <span class="keyword">return</span> pos - start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="private-int-readUTFChar-StringBuilder-sbuf-long-utflen"><a href="#private-int-readUTFChar-StringBuilder-sbuf-long-utflen" class="headerlink" title="private int readUTFChar(StringBuilder sbuf, long utflen)"></a>private int readUTFChar(StringBuilder sbuf, long utflen)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">readUTFChar</span><span class="params">(StringBuilder sbuf, <span class="keyword">long</span> utflen)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b1, b2, b3;</span><br><span class="line">    b1 = readByte() &amp; <span class="number">0xFF</span>;</span><br><span class="line">    <span class="keyword">switch</span> (b1 &gt;&gt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:     <span class="comment">// 1 byte format: 0xxxxxxx</span></span><br><span class="line">            sbuf.append((<span class="keyword">char</span>) b1);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">13</span>:    <span class="comment">// 2 byte format: 110xxxxx 10xxxxxx</span></span><br><span class="line">            <span class="keyword">if</span> (utflen &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UTFDataFormatException();</span><br><span class="line">            &#125;</span><br><span class="line">            b2 = readByte();</span><br><span class="line">            <span class="keyword">if</span> ((b2 &amp; <span class="number">0xC0</span>) != <span class="number">0x80</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UTFDataFormatException();</span><br><span class="line">            &#125;</span><br><span class="line">            sbuf.append((<span class="keyword">char</span>) (((b1 &amp; <span class="number">0x1F</span>) &lt;&lt; <span class="number">6</span>) |</span><br><span class="line">                                ((b2 &amp; <span class="number">0x3F</span>) &lt;&lt; <span class="number">0</span>)));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">14</span>:    <span class="comment">// 3 byte format: 1110xxxx 10xxxxxx 10xxxxxx</span></span><br><span class="line">            <span class="keyword">if</span> (utflen &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (utflen == <span class="number">2</span>) &#123;</span><br><span class="line">                    readByte();         <span class="comment">// consume remaining byte</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UTFDataFormatException();</span><br><span class="line">            &#125;</span><br><span class="line">            b2 = readByte();</span><br><span class="line">            b3 = readByte();</span><br><span class="line">            <span class="keyword">if</span> ((b2 &amp; <span class="number">0xC0</span>) != <span class="number">0x80</span> || (b3 &amp; <span class="number">0xC0</span>) != <span class="number">0x80</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UTFDataFormatException();</span><br><span class="line">            &#125;</span><br><span class="line">            sbuf.append((<span class="keyword">char</span>) (((b1 &amp; <span class="number">0x0F</span>) &lt;&lt; <span class="number">12</span>) |</span><br><span class="line">                                ((b2 &amp; <span class="number">0x3F</span>) &lt;&lt; <span class="number">6</span>) |</span><br><span class="line">                                ((b3 &amp; <span class="number">0x3F</span>) &lt;&lt; <span class="number">0</span>)));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:   <span class="comment">// 10xx xxxx, 1111 xxxx</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UTFDataFormatException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="PeekInputStream"><a href="#PeekInputStream" class="headerlink" title="PeekInputStream"></a>PeekInputStream</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PeekInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** underlying stream */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InputStream in;</span><br><span class="line">    <span class="comment">/** peeked byte */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> peekb = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates new PeekInputStream on top of given underlying stream.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PeekInputStream(InputStream in) &#123;</span><br><span class="line">        <span class="keyword">this</span>.in = in;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Peeks at next byte value in stream.  Similar to read(), except</span></span><br><span class="line"><span class="comment">     * that it does not consume the read value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (peekb &gt;= <span class="number">0</span>) ? peekb : (peekb = in.read());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (peekb &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = peekb;</span><br><span class="line">            peekb = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> in.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (peekb &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> in.read(b, off, len);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            b[off++] = (<span class="keyword">byte</span>) peekb;</span><br><span class="line">            len--;</span><br><span class="line">            peekb = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> n = in.read(b, off, len);</span><br><span class="line">            <span class="keyword">return</span> (n &gt;= <span class="number">0</span>) ? (n + <span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">readFully</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &lt; len) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = read(b, off + n, len - n);</span><br><span class="line">            <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</span><br><span class="line">            &#125;</span><br><span class="line">            n += count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> skipped = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (peekb &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            peekb = -<span class="number">1</span>;</span><br><span class="line">            skipped++;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> skipped + skip(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">available</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> in.available() + ((peekb &gt;= <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li>NIL</li>
</ol>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>NIL</li>
</ol>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java I/O 22 - BufferedReader &amp; BufferedWriter</title>
    <url>/2018/java-BufferedReader-BufferedWriter.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;关于<em> <strong>java.io.BufferedReader</strong> </em> 和<em> <strong>java.io.BufferedWriter</strong> </em> 的部分笔记，对字符读写提供了一个缓冲区作为中间媒介，以此降低读写操作与物理存储的交互次数并提高其读写效率和性能。本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;BufferedReader和BufferedWriter同BufferedInputStream和BufferedOutputStream一样，对输入输出提供了一套缓冲区机制，以此来提高数据读写的效率和性能。BufferedReader和BufferedWriter内部的缓冲区默认大小为8192，通过将数据存储在缓冲区中（本质上是存储在内存中）可以降低读写与物理存储介质的交互次数，以达到优化读写速度的目标。但是和BufferedInputStream和BufferedOutputStream不同的是，BufferedReader和BufferedWriter处理的字符流，其数据范围是0 ~ 65535，而BufferedInputStream和BufferedOutputStream处理的字节流。</p>
<p>&emsp;</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BufferedReader</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.io.Writer</span><br><span class="line">    --java.io.BufferedReader</span><br><span class="line">    </span><br><span class="line"><span class="comment">// BufferedWriter</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.io.Writer</span><br><span class="line">    --java.io.BufferedWriter</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类名</th>
<th style="text-align:center">实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">BufferedReader</td>
<td style="text-align:center">Closeable, AutoCloseable,Readable</td>
</tr>
<tr>
<td style="text-align:center">BufferedReader</td>
<td style="text-align:center">Closeable, AutoCloseable,Flushable, Appendable</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a>BufferedReader</h2><h3 id="Constructor-Summary"><a href="#Constructor-Summary" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="public-BufferedReader-Reader-in-int-sz"><a href="#public-BufferedReader-Reader-in-int-sz" class="headerlink" title="public BufferedReader(Reader in, int sz)"></a>public BufferedReader(Reader in, int sz)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedReader</span><span class="params">(Reader in, <span class="keyword">int</span> sz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(in);</span><br><span class="line">    <span class="keyword">if</span> (sz &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Buffer size &lt;= 0"</span>);</span><br><span class="line">    <span class="keyword">this</span>.in = in;</span><br><span class="line">    cb = <span class="keyword">new</span> <span class="keyword">char</span>[sz];</span><br><span class="line">    nextChar = nChars = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个字符输入流。底层缓存区buffer的长度由参数sz指定。nextChar指向下一个需要被读取的字符串位置，nChars标记缓冲区数组中存储的最后一个字符的位置下标。</p>
<h4 id="public-BufferedReader-Reader-in"><a href="#public-BufferedReader-Reader-in" class="headerlink" title="public BufferedReader(Reader in)"></a>public BufferedReader(Reader in)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedReader</span><span class="params">(Reader in)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(in, defaultCharBufferSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个字符输入流。底层缓存区buffer的长度默认为8192。通过调用构造方法<strong>BufferedReader(Reader in, int sz)</strong>完成初始化操作。</p>
<h3 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="private-void-ensureOpen"><a href="#private-void-ensureOpen" class="headerlink" title="private void ensureOpen()"></a>private void ensureOpen()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureOpen</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (in == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Stream closed"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;检查当前底层输出流是否开启且可用。</p>
<h4 id="private-void-fill"><a href="#private-void-fill" class="headerlink" title="private void fill()"></a>private void fill()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dst;</span><br><span class="line">    <span class="keyword">if</span> (markedChar &lt;= UNMARKED) &#123;</span><br><span class="line">        <span class="comment">/* No mark */</span></span><br><span class="line">        dst = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Marked */</span></span><br><span class="line">        <span class="keyword">int</span> delta = nextChar - markedChar;</span><br><span class="line">        <span class="keyword">if</span> (delta &gt;= readAheadLimit) &#123;</span><br><span class="line">            <span class="comment">/* Gone past read-ahead limit: Invalidate mark */</span></span><br><span class="line">            markedChar = INVALIDATED;</span><br><span class="line">            readAheadLimit = <span class="number">0</span>;</span><br><span class="line">            dst = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (readAheadLimit &lt;= cb.length) &#123;</span><br><span class="line">                <span class="comment">/* Shuffle in the current buffer */</span></span><br><span class="line">                System.arraycopy(cb, markedChar, cb, <span class="number">0</span>, delta);</span><br><span class="line">                markedChar = <span class="number">0</span>;</span><br><span class="line">                dst = delta;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* Reallocate buffer to accommodate read-ahead limit */</span></span><br><span class="line">                <span class="keyword">char</span> ncb[] = <span class="keyword">new</span> <span class="keyword">char</span>[readAheadLimit];</span><br><span class="line">                System.arraycopy(cb, markedChar, ncb, <span class="number">0</span>, delta);</span><br><span class="line">                cb = ncb;</span><br><span class="line">                markedChar = <span class="number">0</span>;</span><br><span class="line">                dst = delta;</span><br><span class="line">            &#125;</span><br><span class="line">            nextChar = nChars = delta;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        n = in.read(cb, dst, cb.length - dst);</span><br><span class="line">    &#125; <span class="keyword">while</span> (n == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        nChars = dst + n;</span><br><span class="line">        nextChar = dst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;向当前底层缓冲区buffer中填充字符数据。在buffer中的数据都读完（即 nextChar &gt;= nChars）时调用触发此方法。第2行代码定义了一个dst用来记录数据填充完成后下一个读取位置。第3 ~ 5行代码表示如果在填充之前没有调用过mark方法，那么会将缓冲区buffer的内容从头开始全部重新填充。</p>
<p>&emsp;&emsp;第6 ~ 30行代码则处理在填充之前曾调用过mark方法的场景。其中，第8行代码用于计算最近一次mark方法产生的标记值到buffer结束的数据长度，如果得到的数据长度超过了允许的最大限度，那么将重新赋值并清除mark相关信息。反之，则将自mark标识位置起到buffer缓冲区结束的内容全部移动到缓冲区首部，释放尾部的空间以此容纳新读入的数据内容，如果需要的话，会适当对缓冲区buffer数组进行扩容处理（即第21 ~ 27行代码中的处理）。数据移动完成后，清除markedChar标记内容，同时更新下一个读取位置的具体位置信息（即dst）。第28行代码则更新了在完成数据移动后缓冲区buffer中下一个读取位置、buffer中存储内容的最后一个位置等信息。</p>
<p>&emsp;&emsp;第32 ~ 35行代码会从底层输入流中读取新的字符内容，其长度足以全部填充缓冲区buffer的可用空间。读取执行结束后，更新nChars值为dst + n，理论上等于缓冲区buffer的长度。nextChar为下一个读取位置的值，需要注意的，如果执行了mark方法，那么这里返回的nextChar并不会重读起始位置，如果需要从标记重读位置开始读取数据，需要另外调用reset方法来更新nextChar值。</p>
<h4 id="public-int-read"><a href="#public-int-read" class="headerlink" title="public int read()"></a>public int read()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nextChar &gt;= nChars) &#123;</span><br><span class="line">                fill();</span><br><span class="line">                <span class="keyword">if</span> (nextChar &gt;= nChars)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (skipLF) &#123;</span><br><span class="line">                skipLF = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (cb[nextChar] == <span class="string">'\n'</span>) &#123;</span><br><span class="line">                    nextChar++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cb[nextChar++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;读取并返回一个字符内容，返回-1则表示文件已经读到了尾部。通过synchronized保证了多线程环境下的线程安全。第5 ~ 9行代码处理缓冲区buffer中已经没有内容可供读取需要从底层输入流中获取新的数据内容的场景。如果当前运行环境中指定了需要忽略换行符（skipLF = true），那么就跳过缓冲区buffer中存储的值为换行符的内容，读取下一个内容并执行相关的计算和判断。第17行代码则返回了缓冲区buffer中存储的一个字符内容给方法调用方。</p>
<h4 id="public-int-read-char-cbuf-int-off-int-len"><a href="#public-int-read-char-cbuf-int-off-int-len" class="headerlink" title="public int read(char cbuf[], int off, int len)"></a>public int read(char cbuf[], int off, int len)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> cbuf[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line">        <span class="keyword">if</span> ((off &lt; <span class="number">0</span>) || (off &gt; cbuf.length) || (len &lt; <span class="number">0</span>) ||</span><br><span class="line">            ((off + len) &gt; cbuf.length) || ((off + len) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = read1(cbuf, off, len);</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n &lt; len) &amp;&amp; in.ready()) &#123;</span><br><span class="line">            <span class="keyword">int</span> n1 = read1(cbuf, off + n, len - n);</span><br><span class="line">            <span class="keyword">if</span> (n1 &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            n += n1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">read1</span><span class="params">(<span class="keyword">char</span>[] cbuf, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nextChar &gt;= nChars) &#123;</span><br><span class="line">        <span class="comment">/* If the requested length is at least as large as the buffer, and</span></span><br><span class="line"><span class="comment">        	if there is no mark/reset activity, and if line feeds are not</span></span><br><span class="line"><span class="comment">        	being skipped, do not bother to copy the characters into the</span></span><br><span class="line"><span class="comment">        	local buffer.  In this way buffered streams will cascade</span></span><br><span class="line"><span class="comment">        	harmlessly. */</span></span><br><span class="line">        <span class="keyword">if</span> (len &gt;= cb.length &amp;&amp; markedChar &lt;= UNMARKED &amp;&amp; !skipLF) &#123;</span><br><span class="line">            <span class="keyword">return</span> in.read(cbuf, off, len);</span><br><span class="line">        &#125;</span><br><span class="line">        fill();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nextChar &gt;= nChars) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (skipLF) &#123;</span><br><span class="line">        skipLF = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (cb[nextChar] == <span class="string">'\n'</span>) &#123;</span><br><span class="line">            nextChar++;</span><br><span class="line">            <span class="keyword">if</span> (nextChar &gt;= nChars)</span><br><span class="line">                fill();</span><br><span class="line">            <span class="keyword">if</span> (nextChar &gt;= nChars)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = Math.min(len, nChars - nextChar);</span><br><span class="line">    System.arraycopy(cb, nextChar, cbuf, off, n);</span><br><span class="line">    nextChar += n;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;读取并将读取的内容保存到字符数组cbuf并返回实际读取长度，返回-1则表示文件已经读到了尾部。通过synchronized保证了多线程环境下的线程安全。第4 ~ 9行代码对入参做了有效性校验，避免了溢出越界的发生。第11行代码则从底层buffer中获取数据，读取时会尽可能满足入参len规定的长度要求。如果读到了EOF标识，那么返回EOF表示已读完底层输入流的数据内容。如果长度要求没有达到且底层输入流仍旧可以提供数据，那么会继续读取数据（即第13 ~ 17行代码的操作流程）。最后返回实际读取的数据长度。</p>
<p>&emsp;&emsp;整个读取过程调用的方法是<strong>private int read1(char[] cbuf, int off, int len)</strong>。在该方法中，如果缓冲区buffer中的内容已经读完，且如果入参len要求的长度超出了缓冲区的长度且未记录到打标信息且不容许忽略换行符，那么会直接从底层输入流中读取内容并返回，不会从缓冲区buffer中获取数据。如果缓冲区中的内容已经读完，那么会通过fill方法从底层输入流中获取数据填充到缓冲区buffer中。第34行代码如果在调用了fille方法进行缓冲区数据填充后还是没有可读取的数据，那么就认为底层输入流中已经没有可读取的数据了，所以返回EOF标识。第35 ~ 44行代码处理的需要忽略换行符的场景。如果缓冲区buffer中遇到了换行符<strong>\n</strong>，那么跳过该内容读取下一个内容，需要的时候可以调用fill方法向缓冲区buffer中填充新的数据内容或者返回EOF标识。</p>
<p>&emsp;&emsp;第45行代码计算缓冲区buffer可以提供的数据容量，并将缓冲区buffer中的内容存储到字符数组cbuf中。之后更新nextChar的值并返回实际读取的字符内容长度。</p>
<h4 id="public-String-readLine"><a href="#public-String-readLine" class="headerlink" title="public String readLine()"></a>public String readLine()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">readLine</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> readLine(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">readLine</span><span class="params">(<span class="keyword">boolean</span> ignoreLF)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    StringBuffer s = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> startChar;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line">        <span class="keyword">boolean</span> omitLF = ignoreLF || skipLF;</span><br><span class="line"></span><br><span class="line">        bufferLoop:</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nextChar &gt;= nChars)</span><br><span class="line">                fill();</span><br><span class="line">            <span class="keyword">if</span> (nextChar &gt;= nChars) &#123; <span class="comment">/* EOF */</span></span><br><span class="line">                <span class="keyword">if</span> (s != <span class="keyword">null</span> &amp;&amp; s.length() &gt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> s.toString();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> eol = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">char</span> c = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Skip a leftover '\n', if necessary */</span></span><br><span class="line">            <span class="keyword">if</span> (omitLF &amp;&amp; (cb[nextChar] == <span class="string">'\n'</span>))</span><br><span class="line">                nextChar++;</span><br><span class="line">            skipLF = <span class="keyword">false</span>;</span><br><span class="line">            omitLF = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            charLoop:</span><br><span class="line">            <span class="keyword">for</span> (i = nextChar; i &lt; nChars; i++) &#123;</span><br><span class="line">                c = cb[i];</span><br><span class="line">                <span class="keyword">if</span> ((c == <span class="string">'\n'</span>) || (c == <span class="string">'\r'</span>)) &#123;</span><br><span class="line">                    eol = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span> charLoop;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            startChar = nextChar;</span><br><span class="line">            nextChar = i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (eol) &#123;</span><br><span class="line">                String str;</span><br><span class="line">                <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    str = <span class="keyword">new</span> String(cb, startChar, i - startChar);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    s.append(cb, startChar, i - startChar);</span><br><span class="line">                    str = s.toString();</span><br><span class="line">                &#125;</span><br><span class="line">                nextChar++;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'\r'</span>) &#123;</span><br><span class="line">                    skipLF = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> str;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">                s = <span class="keyword">new</span> StringBuffer(defaultExpectedLineLength);</span><br><span class="line">            s.append(cb, startChar, i - startChar);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;读取一行内容并返回，每行内容由<strong>\n</strong>、<strong>\r</strong>或者二者的组合分隔拆分得到。第16 ~ 23行代码中如果缓冲区buffer中的数据内容已经读取完毕，那么就调用fill()方法向buffer中填充新数据内容，如果底层输入流中已经到达了文件尾部，那么就以String形式当前已经得到的数据内容。第29行代码如果下一个读取位置存储的是一个换行符，那么跳过并读取下一个内容。第34 ~ 41行代码循环读取缓冲区buffer，获得两个换行符之间的完整数据内容。第46 ~ 59行代码处理的是成功读取了一行内容的场景：如果成功的读到了一行完整的内容（即eol = true），那么就从缓冲区buffer中取出这一行完整的内容并将之转换成一个String内容。更新维护nextChar的值并返回String字符串。如果当读取到缓冲区buffer尾部时尚未得到一行完整的内容（即eol = false），那么继续通过fill方法向缓冲区buffer填充新内容并执行上述计算过程。</p>
<h4 id="public-long-skip-long-n"><a href="#public-long-skip-long-n" class="headerlink" title="public long skip(long n)"></a>public long skip(long n)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0L</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"skip value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line">        <span class="keyword">long</span> r = n;</span><br><span class="line">        <span class="keyword">while</span> (r &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nextChar &gt;= nChars)</span><br><span class="line">                fill();</span><br><span class="line">            <span class="keyword">if</span> (nextChar &gt;= nChars) <span class="comment">/* EOF */</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (skipLF) &#123;</span><br><span class="line">                skipLF = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (cb[nextChar] == <span class="string">'\n'</span>) &#123;</span><br><span class="line">                    nextChar++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> d = nChars - nextChar;</span><br><span class="line">            <span class="keyword">if</span> (r &lt;= d) &#123;</span><br><span class="line">                nextChar += r;</span><br><span class="line">                r = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                r -= d;</span><br><span class="line">                nextChar = nChars;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;跳过n个字符内容的长度，并从n+1位置开始读取字符内容。对n的要求是必须是一个大于等于0的数字。通过synchronized保证了多线程环境下的线程安全。第9 ~ 12行代码处理当前缓冲区buffer需要填充新数据内容的场景，且如果执行fill方法之后依旧没有新内容，那么会返回EOF标识给方法调用方。第13 ~ 18行代码处理需要忽略换行符的场景，如果遇到了换行符，那么就跳过该内容读取下一个内容。</p>
<p>&emsp;&emsp;第19行代码计算缓冲区buffer中剩余的尚未读取的数据内容长度。如果入参跳过的长度n小于buffer剩余未读取的数据长度，那么会跳过缓冲区buffer中n个长度的内容并返回实际跳过长度给方法调用方。反之，则将缓冲区buffer中尚未读取的内容全部跳过，同时调用fill方法填充新的数据内容并继续计算需要跳过的长度直到跳过内容的总长度达到了n或者读到了文件结束位置。第30行代码计算最终跳过的长度并返回计算结果。</p>
<h4 id="public-boolean-ready"><a href="#public-boolean-ready" class="headerlink" title="public boolean ready()"></a>public boolean ready()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">ready</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If newline needs to be skipped and the next char to be read</span></span><br><span class="line"><span class="comment">         * is a newline character, then just skip it right away.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (skipLF) &#123;</span><br><span class="line">            <span class="comment">/* Note that in.ready() will return true if and only if the next</span></span><br><span class="line"><span class="comment">             * read on the stream will not block.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (nextChar &gt;= nChars &amp;&amp; in.ready()) &#123;</span><br><span class="line">                fill();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nextChar &lt; nChars) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cb[nextChar] == <span class="string">'\n'</span>)</span><br><span class="line">                    nextChar++;</span><br><span class="line">                skipLF = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (nextChar &lt; nChars) || in.ready();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通知方法调用方当前缓冲区buffer和底层输入流中的任意一个是否可以对外提供数据。通过synchronized保证了多线程环境下的线程安全。如果当前运行环境需要忽略换行符，首先在缓冲区buffer无未读取数据的情况下先从底层输入流中获取数据填充到缓冲区buffer中。之后判断下一个读取位置是否为换行符，如果是的话就跳过并读取下一个字符内容。通过计算缓冲区buffer中是否有尚未读取的数据内容，或者底层输入流是否可以继续提供数据来判断ready方法的返回值。</p>
<h4 id="public-boolean-markSupported"><a href="#public-boolean-markSupported" class="headerlink" title="public boolean markSupported()"></a>public boolean markSupported()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">markSupported</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;BufferedReader支持标记重读操作，所以返回true。</p>
<h4 id="public-void-mark-int-readAheadLimit"><a href="#public-void-mark-int-readAheadLimit" class="headerlink" title="public void mark(int readAheadLimit)"></a>public void mark(int readAheadLimit)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> readAheadLimit)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (readAheadLimit &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Read-ahead limit &lt; 0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line">        <span class="keyword">this</span>.readAheadLimit = readAheadLimit;</span><br><span class="line">        markedChar = nextChar;</span><br><span class="line">        markedSkipLF = skipLF;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;标记需要重读的数据内容的起点位置。通过synchronized保证了多线程环境下的线程安全。该方法执行过后，通过执行reset方法可以重新读取已经读取过的数据内容。调用mark方法需要readAheadLimit大于等于0。通过synchronized保证了多线程环境下的线程安全。方法内部会将当前数据的读取位置nextChar的值记录到markedChar中，同时维护是否需要忽略换行符的信息。</p>
<h4 id="public-void-reset"><a href="#public-void-reset" class="headerlink" title="public void reset()"></a>public void reset()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line">        <span class="keyword">if</span> (markedChar &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException((markedChar == INVALIDATED)</span><br><span class="line">                                  ? <span class="string">"Mark invalid"</span></span><br><span class="line">                                  : <span class="string">"Stream not marked"</span>);</span><br><span class="line">        nextChar = markedChar;</span><br><span class="line">        skipLF = markedSkipLF;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;重置下一个读取位置实现数据重复读取场景。通过synchronized保证了多线程环境下的线程安全。在实现数据重读时，首先计算存储重读起始位置的markedChar是否有效。如果markedChar无效，那么会向上抛出异常，反之将nextChar的值更新为markedChar中维护的值，同时更新skipLF以完成所有操作。</p>
<h4 id="public-void-close"><a href="#public-void-close" class="headerlink" title="public void close()"></a>public void close()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (in == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        in.close();</span><br><span class="line">        in = <span class="keyword">null</span>;</span><br><span class="line">        cb = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;关闭当前输入流。通过使用synchronized关键字保证了多线程环境下的线程安全。如果底层输入流已经关闭，那么直接返回，否则通过调用底层输入流的close()方法关闭底层输入流并释放占用的相关资源。</p>
<p>&emsp;</p>
<h2 id="BufferedWriter"><a href="#BufferedWriter" class="headerlink" title="BufferedWriter"></a>BufferedWriter</h2><h3 id="Constructor-Summary-1"><a href="#Constructor-Summary-1" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="public-BufferedWriter-Writer-out-int-sz"><a href="#public-BufferedWriter-Writer-out-int-sz" class="headerlink" title="public BufferedWriter(Writer out, int sz)"></a>public BufferedWriter(Writer out, int sz)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedWriter</span><span class="params">(Writer out, <span class="keyword">int</span> sz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(out);</span><br><span class="line">    <span class="keyword">if</span> (sz &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Buffer size &lt;= 0"</span>);</span><br><span class="line">    <span class="keyword">this</span>.out = out;</span><br><span class="line">    cb = <span class="keyword">new</span> <span class="keyword">char</span>[sz];</span><br><span class="line">    nChars = sz;</span><br><span class="line">    nextChar = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    lineSeparator = java.security.AccessController.doPrivileged(</span><br><span class="line">        <span class="keyword">new</span> sun.security.action.GetPropertyAction(<span class="string">"line.separator"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个字符输出流。底层缓存区buffer的长度由参数sz指定。nextChar指向下一个保存字符内容的位置，nChars标记缓冲区数组中可以保存字符内容的最后一个位置。第10 ~ 11行代码初始化一个基于代码运行环境的行分隔符。</p>
<h4 id="public-BufferedWriter-Writer-out"><a href="#public-BufferedWriter-Writer-out" class="headerlink" title="public BufferedWriter(Writer out)"></a>public BufferedWriter(Writer out)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedWriter</span><span class="params">(Writer out)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(out, defaultCharBufferSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个字符输出流。底层缓存区buffer的长度默认为8192。通过调用构造方法<strong>BufferedWriter(Writer out, int sz)</strong>完成初始化操作。</p>
<h3 id="部分方法-1"><a href="#部分方法-1" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="private-void-ensureOpen-1"><a href="#private-void-ensureOpen-1" class="headerlink" title="private void ensureOpen()"></a>private void ensureOpen()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureOpen</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (out == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Stream closed"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;检查当前底层输出流是否开启且可用。</p>
<h4 id="void-flushBuffer"><a href="#void-flushBuffer" class="headerlink" title="void flushBuffer()"></a>void flushBuffer()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flushBuffer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line">        <span class="keyword">if</span> (nextChar == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        out.write(cb, <span class="number">0</span>, nextChar);</span><br><span class="line">        nextChar = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将当前缓冲区buffer中的内容推送到底层的目标输出流中。通过synchronized保证了多线程环境下的线程安全。如果缓冲区buffer中尚未存储任何内容（即nextChar == 0），那么不做任何操作直接返回。否则将缓冲区buffer中的内容推送到底层输出流中，同时将nextChar重新置为0。</p>
<h4 id="public-void-write-int-c"><a href="#public-void-write-int-c" class="headerlink" title="public void write(int c)"></a>public void write(int c)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> c)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line">        <span class="keyword">if</span> (nextChar &gt;= nChars)</span><br><span class="line">            flushBuffer();</span><br><span class="line">        cb[nextChar++] = (<span class="keyword">char</span>) c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;向底层输出流写入一个字符内容（实际上是首先写入到了底层缓冲区buffer中）。通过synchronized保证了多线程环境下的线程安全。如果在写入前发现当前缓冲区buffer空间已满无法容纳新的内容，那么就调用flushBuffer()方法将缓冲区buffer中的内容推送到目标输出位置并释放缓冲区buffer的空间。之后将传入的字符数据c写入到缓冲区中保存。</p>
<h4 id="public-void-write-char-cbuf-int-off-int-len"><a href="#public-void-write-char-cbuf-int-off-int-len" class="headerlink" title="public void write(char cbuf[], int off, int len)"></a>public void write(char cbuf[], int off, int len)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> cbuf[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line">        <span class="keyword">if</span> ((off &lt; <span class="number">0</span>) || (off &gt; cbuf.length) || (len &lt; <span class="number">0</span>) ||</span><br><span class="line">            ((off + len) &gt; cbuf.length) || ((off + len) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len &gt;= nChars) &#123;</span><br><span class="line">            <span class="comment">/* If the request length exceeds the size of the output buffer,</span></span><br><span class="line"><span class="comment">                   flush the buffer and then write the data directly.  In this</span></span><br><span class="line"><span class="comment">                   way buffered streams will cascade harmlessly. */</span></span><br><span class="line">            flushBuffer();</span><br><span class="line">            out.write(cbuf, off, len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> b = off, t = off + len;</span><br><span class="line">        <span class="keyword">while</span> (b &lt; t) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = min(nChars - nextChar, t - b);</span><br><span class="line">            System.arraycopy(cbuf, b, cb, nextChar, d);</span><br><span class="line">            b += d;</span><br><span class="line">            nextChar += d;</span><br><span class="line">            <span class="keyword">if</span> (nextChar &gt;= nChars)</span><br><span class="line">                flushBuffer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将字符数组cbuf中的内容写入到底层输出流中（实际上是首先写入到了底层缓冲区buffer中）。通过synchronized保证了多线程环境下的线程安全。第4 ~ 10行代码完成了参数的有效性校验，避免发生越界溢出。</p>
<p>&emsp;&emsp;如果入参长度len大于缓冲区的容量，那么cbuf中的数据不会被保存到缓冲区中，而是首先将缓冲区buffer已有的数据推送到底层目标输出位置，然后直接把cbuf中的数据写入到底层目标输出位置里。反之，将cbuf中的数据先维护到缓冲区buffer中，如果buffer空间已满，则调用flushBuffer()方法将buffer中的数据推送到底层输出位置中，清空并释放buffer空间以此容纳新的数据，重复该过程直到cbuf中的内容全部被保存到了缓冲区buffer中（可能有部分数据已经被推送到了底层输出位置上）。</p>
<h4 id="public-void-write-String-s-int-off-int-len"><a href="#public-void-write-String-s-int-off-int-len" class="headerlink" title="public void write(String s, int off, int len)"></a>public void write(String s, int off, int len)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String s, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> b = off, t = off + len;</span><br><span class="line">        <span class="keyword">while</span> (b &lt; t) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = min(nChars - nextChar, t - b);</span><br><span class="line">            s.getChars(b, b + d, cb, nextChar);</span><br><span class="line">            b += d;</span><br><span class="line">            nextChar += d;</span><br><span class="line">            <span class="keyword">if</span> (nextChar &gt;= nChars)</span><br><span class="line">                flushBuffer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将字符串s中的内容写入到底层输出流中（实际上是首先写入到了底层缓冲区buffer中）。通过synchronized保证了多线程环境下的线程安全。第7行代码计算当前缓冲区buffer实际能容纳的s中的内容长度，第8行代码则将s中自off位置起，长度为d的内容复制保存到缓冲区buffer中。之后更新b、nextChar的值，如果缓冲区buffer空间已满则将缓冲区buffer中的内容推送到目标输出位置中。重复处理直到s中自off位置起长度为len的内容全部被保存到缓冲区buffer中（可能有部分数据已经被推送到了底层输出位置上）。</p>
<h4 id="public-void-newLine"><a href="#public-void-newLine" class="headerlink" title="public void newLine()"></a>public void newLine()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">newLine</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    write(lineSeparator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;写入一个换行符，实现换行效果。lineSeparator匹配当前运行环境机器的换行符格式。</p>
<h4 id="public-void-flush"><a href="#public-void-flush" class="headerlink" title="public void flush()"></a>public void flush()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        flushBuffer();</span><br><span class="line">        out.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将当前缓冲区buffer中的内容推送到底层输出流。推送完毕后调用底层输出流的flush()方法将数据真正推送到目标输出位置。</p>
<h4 id="public-void-close-1"><a href="#public-void-close-1" class="headerlink" title="public void close()"></a>public void close()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (out == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            flushBuffer();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            out.close();</span><br><span class="line">            out = <span class="keyword">null</span>;</span><br><span class="line">            cb = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;关闭当前输出流。通过使用synchronized关键字保证了多线程环境下的线程安全。如果底层输出流已经关闭，那么直接返回，否则首先将缓冲区buffer中的数据推送到目标输出位置，然后调用底层输出流的close()方法关闭底层输出流并释放占用的相关资源。</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li>NIL</li>
</ol>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>NIL</li>
</ol>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java I/O 18 - CharArrayReader &amp; CharArrayWriter</title>
    <url>/2018/java-CharArrayReader-CharArrayWriter.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;关于<em> <strong>java.io.CharArrayReader</strong> </em> 和 <em> <strong>java.io.CharArrayWriter</strong> </em>的部分笔记，这两个类属于内存流的一种，参考流的思想操作内存空间中的数组内容。本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;CharArrayReader和CharArrayWriter是典型的内存流，这两个类在内存中维护了一个char数组，把char数组视为输入/输出流的位置并实现了一套对char数组进行读写的方法API。可以在一些需要Reader/Writer作为参数，且实际内容是char数组的场合中使用CharArrayReader和CharArrayWriter。因为没有调用过除了内存之外的其他系统资源，所以这两个类的close()方法除了释放char数组占用的资源外无其他操作。</p>
<p>&emsp;</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CharArrayReader</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.io.Reader</span><br><span class="line">    --java.io.CharArrayReader</span><br><span class="line"></span><br><span class="line"><span class="comment">// CharArrayWriter</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.io.Writer</span><br><span class="line">    --java.io.CharArrayWriter</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类名</th>
<th style="text-align:center">实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CharArrayReader</td>
<td style="text-align:center">Closeable, AutoCloseable,Readable</td>
</tr>
<tr>
<td style="text-align:center">CharArrayWriter</td>
<td style="text-align:center">Closeable, Flushable, AutoCloseable, Appendable</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="CharArrayReader"><a href="#CharArrayReader" class="headerlink" title="CharArrayReader"></a>CharArrayReader</h2><h3 id="Constructor-Summary"><a href="#Constructor-Summary" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="public-CharArrayReader-char-buf"><a href="#public-CharArrayReader-char-buf" class="headerlink" title="public CharArrayReader(char buf[])"></a>public CharArrayReader(char buf[])</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CharArrayReader</span><span class="params">(<span class="keyword">char</span> buf[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.buf = buf;</span><br><span class="line">    <span class="keyword">this</span>.pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.count = buf.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个字符数组输入流。该输入流的数据来源是字符数组buf，同时初始化pos值和数据长度count。</p>
<h4 id="public-CharArrayReader-char-buf-int-offset-int-length"><a href="#public-CharArrayReader-char-buf-int-offset-int-length" class="headerlink" title="public CharArrayReader(char buf[], int offset, int length)"></a>public CharArrayReader(char buf[], int offset, int length)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CharArrayReader</span><span class="params">(<span class="keyword">char</span> buf[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((offset &lt; <span class="number">0</span>) || (offset &gt; buf.length) || (length &lt; <span class="number">0</span>) ||</span><br><span class="line">        ((offset + length) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.buf = buf;</span><br><span class="line">    <span class="keyword">this</span>.pos = offset;</span><br><span class="line">    <span class="keyword">this</span>.count = Math.min(offset + length, buf.length);</span><br><span class="line">    <span class="keyword">this</span>.markedPos = offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个字符数组输入流。第2 ~ 5行代码用来完成参数的有效性校验。第8行代码用来计算实际的数组结束边界。第9行代码用来标识数据重读的起始边界，因为offset可能不为0，也就意味着offset之前的内容永远不会读到，通过设置markedPos可以保证这一点不会发生。</p>
<h3 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="private-void-ensureOpen"><a href="#private-void-ensureOpen" class="headerlink" title="private void ensureOpen()"></a>private void ensureOpen()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureOpen</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (buf == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Stream closed"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;检查当前buf是否有效且是否含有内容。</p>
<h4 id="public-int-read"><a href="#public-int-read" class="headerlink" title="public int read()"></a>public int read()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line">        <span class="keyword">if</span> (pos &gt;= count)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> buf[pos++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从buf中读取一个字符的内容并返回。通过synchronized关键字保证了多线程环境下的线程安全。如果pos到达了数组边界，则认为数组内容已经全部读取完毕，返回EOF标识给方法调用方。</p>
<h4 id="public-int-read-char-b-int-off-int-len"><a href="#public-int-read-char-b-int-off-int-len" class="headerlink" title="public int read(char b[], int off, int len)"></a>public int read(char b[], int off, int len)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line">        <span class="keyword">if</span> ((off &lt; <span class="number">0</span>) || (off &gt; b.length) || (len &lt; <span class="number">0</span>) ||</span><br><span class="line">            ((off + len) &gt; b.length) || ((off + len) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pos &gt;= count) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos + len &gt; count) &#123;</span><br><span class="line">            len = count - pos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.arraycopy(buf, pos, b, off, len);</span><br><span class="line">        pos += len;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从buf中读取长度为len的内容并保存到数组b中起始位置为off的空间中。通过synchronized关键字保证了多线程环境下的线程安全。第4 ~ 9行代码完成了参数的有效性校验。如果pos到达了数组边界，则认为数组内容已经全部读取完毕，返回EOF标识给方法调用方。第14 ~ 16行代码计算实际可以读取的长度值。</p>
<p>&emsp;&emsp;第20行代码则将buf中自pos位置起长度为len的内容复制到数组b中起始位置为off的空间里。之后计算更新后的pos值并返回实际读取的内容长度。</p>
<h4 id="public-long-skip-long-n"><a href="#public-long-skip-long-n" class="headerlink" title="public long skip(long n)"></a>public long skip(long n)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line">        <span class="keyword">if</span> (pos + n &gt; count) &#123;</span><br><span class="line">            n = count - pos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pos += n;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;跳过buf中数组中指定长度的内容。通过synchronized关键字保证了多线程环境下的线程安全。第4 ~ 6行代码计算实际需要跳过的长度。如果入参n是一个负数，那么什么操作都不执行，直接返回0。第10行代码计算跳过后的pos值，并返回实际跳过的长度值给方法调用方。</p>
<h4 id="public-boolean-ready"><a href="#public-boolean-ready" class="headerlink" title="public boolean ready()"></a>public boolean ready()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">ready</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line">        <span class="keyword">return</span> (count - pos) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通知方法调用方当前输入流是否可以通过read方法提供字符内容。通过synchronized关键字保证了多线程环境下的线程安全。如果count - pos &gt; 0 则认为当前底层buf中还有未读取的内容可供read方法读取获得。</p>
<h4 id="public-boolean-markSupported"><a href="#public-boolean-markSupported" class="headerlink" title="public boolean markSupported()"></a>public boolean markSupported()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">markSupported</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;CharArrayReader支持标记重读操作，所以返回true。</p>
<h4 id="public-void-mark-int-readAheadLimit"><a href="#public-void-mark-int-readAheadLimit" class="headerlink" title="public void mark(int readAheadLimit)"></a>public void mark(int readAheadLimit)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> readAheadLimit)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line">        markedPos = pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;标记重读起始位置。当前方法调用后如果执行reset()方法，下一个读取位置pos值会变成当前执行mark方法时的pos值，实现重读功能。</p>
<h4 id="public-void-reset"><a href="#public-void-reset" class="headerlink" title="public void reset()"></a>public void reset()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line">        pos = markedPos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;重置下一个读取位置值。如果在调用reset()方法之前从未调用过mark()方法，那么调用reset()方法后会将pos重置为0，即从头读取。</p>
<h4 id="public-void-close"><a href="#public-void-close" class="headerlink" title="public void close()"></a>public void close()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    buf = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;关闭当前输入流。</p>
<p>&emsp;</p>
<h2 id="CharArrayWriter"><a href="#CharArrayWriter" class="headerlink" title="CharArrayWriter"></a>CharArrayWriter</h2><h3 id="Constructor-Summary-1"><a href="#Constructor-Summary-1" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="public-CharArrayWriter"><a href="#public-CharArrayWriter" class="headerlink" title="public CharArrayWriter()"></a>public CharArrayWriter()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CharArrayWriter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">32</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个字符数组输出流，底层字符数组的长度为32。</p>
<h4 id="public-CharArrayWriter-int-initialSize"><a href="#public-CharArrayWriter-int-initialSize" class="headerlink" title="public CharArrayWriter(int initialSize)"></a>public CharArrayWriter(int initialSize)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CharArrayWriter</span><span class="params">(<span class="keyword">int</span> initialSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialSize &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Negative initial size: "</span></span><br><span class="line">                                           + initialSize);</span><br><span class="line">    &#125;</span><br><span class="line">    buf = <span class="keyword">new</span> <span class="keyword">char</span>[initialSize];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个字符数组输出流，底层字符数组的长度为入参initialSize。因为在初始化时需要依赖initialSize，所以该字段的值不能小于0。</p>
<h3 id="部分方法-1"><a href="#部分方法-1" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="public-void-writeTo-Writer-out"><a href="#public-void-writeTo-Writer-out" class="headerlink" title="public void writeTo(Writer out)"></a>public void writeTo(Writer out)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeTo</span><span class="params">(Writer out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        out.write(buf, <span class="number">0</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将当前缓冲区buffer中的内容写入到另一个字符输出流中。</p>
<h4 id="public-void-write-int-c"><a href="#public-void-write-int-c" class="headerlink" title="public void write(int c)"></a>public void write(int c)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">int</span> newcount = count + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (newcount &gt; buf.length) &#123;</span><br><span class="line">            buf = Arrays.copyOf(buf, Math.max(buf.length &lt;&lt; <span class="number">1</span>, newcount));</span><br><span class="line">        &#125;</span><br><span class="line">        buf[count] = (<span class="keyword">char</span>)c;</span><br><span class="line">        count = newcount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;向缓冲区buf中写入一个字符。通过使用synchronized关键字可以保证多线程环境下的线程安全。在操作时，首先计算新的buf尾部边界，如果新的尾部边界大于当前buf的长度，那么执行扩容处理。扩容原则是新的buf数组长度是当前buf长度的两倍。然后将入参字符c写入保存到底层缓冲区buf中，同时更新buf的count值。</p>
<h4 id="public-void-write-char-c-int-off-int-len"><a href="#public-void-write-char-c-int-off-int-len" class="headerlink" title="public void write(char c[], int off, int len)"></a>public void write(char c[], int off, int len)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> c[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((off &lt; <span class="number">0</span>) || (off &gt; c.length) || (len &lt; <span class="number">0</span>) ||</span><br><span class="line">        ((off + len) &gt; c.length) || ((off + len) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">int</span> newcount = count + len;</span><br><span class="line">        <span class="keyword">if</span> (newcount &gt; buf.length) &#123;</span><br><span class="line">            buf = Arrays.copyOf(buf, Math.max(buf.length &lt;&lt; <span class="number">1</span>, newcount));</span><br><span class="line">        &#125;</span><br><span class="line">        System.arraycopy(c, off, buf, count, len);</span><br><span class="line">        count = newcount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将字符数组c中的内容写入到缓冲区buf中。第2 ~ 7行代码用来完成参数的有效性校验，避免发生越界溢出。通过使用synchronized关键字可以保证多线程环境下的线程安全。第9行代码计算存储数组c需要的空间，如果空间不足，需要对buf进行扩容处理。扩容原则是新的buf数组长度是当前buf长度的两倍。接着通过调用System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length)方法将数组c中的内容写入到buf中，最后更新count值。</p>
<h4 id="public-void-write-String-str-int-off-int-len"><a href="#public-void-write-String-str-int-off-int-len" class="headerlink" title="public void write(String str, int off, int len)"></a>public void write(String str, int off, int len)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String str, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">int</span> newcount = count + len;</span><br><span class="line">        <span class="keyword">if</span> (newcount &gt; buf.length) &#123;</span><br><span class="line">            buf = Arrays.copyOf(buf, Math.max(buf.length &lt;&lt; <span class="number">1</span>, newcount));</span><br><span class="line">        &#125;</span><br><span class="line">        str.getChars(off, off + len, buf, count);</span><br><span class="line">        count = newcount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将字符串str中自off位置起长度为len的内容写入到缓冲区buf中。通过使用synchronized关键字可以保证多线程环境下的线程安全。第3行计算需要的存储空间，如果空间不足，需要对buf进行扩容处理。扩容原则是新的buf数组长度是当前buf长度的两倍。然后将str自off位置起长度为len的内容写入到缓冲区buf中，最后更新count值。</p>
<h4 id="public-CharArrayWriter-append-CharSequence-csq"><a href="#public-CharArrayWriter-append-CharSequence-csq" class="headerlink" title="public CharArrayWriter append(CharSequence csq)"></a>public CharArrayWriter append(CharSequence csq)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CharArrayWriter <span class="title">append</span><span class="params">(CharSequence csq)</span> </span>&#123;</span><br><span class="line">    String s = (csq == <span class="keyword">null</span> ? <span class="string">"null"</span> : csq.toString());</span><br><span class="line">    write(s, <span class="number">0</span>, s.length());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将CharSequence中包含的内容写入到缓冲区buf中，如果csq为null，那么就将“null”这四个字符写入到buf中。底层调用的方法是<strong>write(String str, int off, int len)</strong>。</p>
<h4 id="public-CharArrayWriter-append-CharSequence-csq-int-start-int-end"><a href="#public-CharArrayWriter-append-CharSequence-csq-int-start-int-end" class="headerlink" title="public CharArrayWriter append(CharSequence csq, int start, int end)"></a>public CharArrayWriter append(CharSequence csq, int start, int end)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CharArrayWriter <span class="title">append</span><span class="params">(CharSequence csq, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    String s = (csq == <span class="keyword">null</span> ? <span class="string">"null"</span> : csq).subSequence(start, end).toString();</span><br><span class="line">    write(s, <span class="number">0</span>, s.length());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将CharSequence中包含的内容写入到缓冲区buf中。实际需要写入的内容包含在start位置到end位置之间。底层调用的方法是<strong>write(String str, int off, int len)</strong>。</p>
<h4 id="public-CharArrayWriter-append-char-c"><a href="#public-CharArrayWriter-append-char-c" class="headerlink" title="public CharArrayWriter append(char c)"></a>public CharArrayWriter append(char c)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CharArrayWriter <span class="title">append</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    write(c);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将一个字符写入到底层缓冲区buf中。底层调用的方法是<strong>write(int c)</strong>。</p>
<h4 id="public-void-reset-1"><a href="#public-void-reset-1" class="headerlink" title="public void reset()"></a>public void reset()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将count值归零。可以直接通过覆盖的方式存储新的数据内容而不用重复分配新的数组空间。</p>
<h4 id="public-char-toCharArray"><a href="#public-char-toCharArray" class="headerlink" title="public char toCharArray()[]"></a>public char toCharArray()[]</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">toCharArray</span><span class="params">()</span>[] </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(buf, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将当前缓冲区buf中的内容复制一份并返回其复制内容。</p>
<h4 id="public-int-size"><a href="#public-int-size" class="headerlink" title="public int size()"></a>public int size()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回当前缓冲区buf中的数据长度。</p>
<h4 id="public-String-toString"><a href="#public-String-toString" class="headerlink" title="public String toString()"></a>public String toString()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="number">0</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将当前缓冲区buf中的内容转换成一个String字符串并返回。</p>
<h4 id="public-void-flush"><a href="#public-void-flush" class="headerlink" title="public void flush()"></a>public void flush()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将缓冲区buf中的内容推到目标输出位置上。方法体是个空方法，不执行任何操作。</p>
<h4 id="public-void-close-1"><a href="#public-void-close-1" class="headerlink" title="public void close()"></a>public void close()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;关闭当前输出流。方法体是个空方法，不执行任何操作。</p>
<p>&emsp;</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li>NIL</li>
</ol>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>NIL</li>
</ol>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Collection 02 - AbstractList</title>
    <url>/2018/java-Collection-AbstractList.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;关于<em> <strong>java.util.AbstractList&lt;E&gt;</strong> </em>的部分笔记，AbstractList是List的默认最小化实现。在具体的使用场景中，由继承AbstractList的具体实现类完成数据的存储和操作需求。本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;AbstractList是List接口的最小程度的实现。之所以说是最小程度，是因为AbstractList中大部分已经实现的方法基本上都是只返回了异常信息而没有做任何有效的处理操作。List有两个抽象实现，一个是AbstractList，另一个是AbstractSequentialList。AbstractList实现了一种随机访问存储数据的方案，类似于数组那样,所以其具有元素访问速度快的特点，但是由于其底层实现采用的数组的方式，所以在插入元素时会因为需要移动元素分配空间而导致元素插入速度相对较慢。而AbstractSequentialList则实现了一种顺序访问存储数据的方案，其继承类便是LinkedList。</p>
<p>&emsp;&emsp;对于AbstractList的子类来说，如果想要处理的是不可修改的list集合，那么只需要实现AbstractList中的get(int index)和int size()方法就足够了。如果要处理的可修改list集合，那么就需要额外实现set(int index, E element)。如果想要处理一个可变长度的list集合，那么还需要实现add(int index, E element)和remove(int index)方法。</p>
<p>&emsp;&emsp;除此之外，AbstractList自身实现了iterator和list iterator迭代器的功能。而且，像get(int index)、set(int index, E element)、add(int index, E element)和remove(int index)方法都可以通过随机访问的对集合元素进行操作处理。</p>
<p>&emsp;</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractList&lt;E&gt;</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.util.AbstractCollection&lt;E&gt;</span><br><span class="line">    --java.util.AbstractList&lt;E&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><div class="table-container">
<table>
<thead>
<tr>
<th>类名</th>
<th>实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>AbstractList&lt;E&gt;</td>
<td>Iterable&lt;E&gt;, Collection&lt;E&gt;, List&lt;E&gt;</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="AbstractList"><a href="#AbstractList" class="headerlink" title="AbstractList"></a>AbstractList</h2><h3 id="Constructor-Summary"><a href="#Constructor-Summary" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="protected-AbstractList"><a href="#protected-AbstractList" class="headerlink" title="protected AbstractList()"></a>protected AbstractList()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;默认构造函数。采用protected修饰的原因是因为AbstractList不直接用于集合的初始化操作，而是在使用真正可用的list集合处理类时提供一些基础准备工作。所以这个方法不应该暴露到外界去，所以不能用public修饰。同样的原因，因为AbstractList不涉及到单例模式的设计，所以也不会是private，这样其子类也没办法继承到父类的无参构造方法。所以综上考虑，protected是最理想的选择。</p>
<h3 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="public-boolean-add-E-e"><a href="#public-boolean-add-E-e" class="headerlink" title="public boolean add(E e)"></a>public boolean add(E e)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    add(size(), e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在集合尾部加入新的元素e。实际调用的是add(int index, E element)方法。该方法可能会限制e的类型，不满足条件的e可能无法加入到集合中。需要注意的是AbstractList中的add(int index, E element)方法需要被子类重写其实现，否则会抛出<strong>UnsupportedOperationException</strong>异常。</p>
<h4 id="public-void-add-int-index-E-element"><a href="#public-void-add-int-index-E-element" class="headerlink" title="public void add(int index, E element)"></a>public void add(int index, E element)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;AbstractList中的add(int index, E element)方法直接抛出<strong>UnsupportedOperationException</strong>异常，需要在子类中重写实现过程。</p>
<h4 id="abstract-public-E-get-int-index"><a href="#abstract-public-E-get-int-index" class="headerlink" title="abstract public E get(int index)"></a>abstract public E get(int index)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回index指定的位置的元素。AbstractList中该方法被声明为抽象方法。需要子类重写实现过程。</p>
<h4 id="public-E-set-int-index-E-element"><a href="#public-E-set-int-index-E-element" class="headerlink" title="public E set(int index, E element)"></a>public E set(int index, E element)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;替换list集合中index位置的元素为element。AbstractList中的set(int index, E element)方法直接抛出<strong>UnsupportedOperationException</strong>异常，需要在子类中重写实现过程。</p>
<h4 id="public-E-remove-int-index"><a href="#public-E-remove-int-index" class="headerlink" title="public E remove(int index)"></a>public E remove(int index)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;删除index位置的元素并返回该元素。删除执行完成后index位置之后的所有元素都会向前移动一个位置。AbstractList中的remove(int index)方法直接抛出<strong>UnsupportedOperationException</strong>异常，需要在子类中重写实现过程。</p>
<h4 id="public-int-indexOf-Object-o"><a href="#public-int-indexOf-Object-o" class="headerlink" title="public int indexOf(Object o)"></a>public int indexOf(Object o)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    ListIterator&lt;E&gt; it = listIterator();</span><br><span class="line">    <span class="keyword">if</span> (o==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">            <span class="keyword">if</span> (it.next()==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> it.previousIndex();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">            <span class="keyword">if</span> (o.equals(it.next()))</span><br><span class="line">                <span class="keyword">return</span> it.previousIndex();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回元素o在list集合中第一次出现的位置，如果list集合中尚未存储元素o，那么返回-1。如果入参元素o为null，那么就寻找list集合中第一个null元素存储的位置，否则，根据o的equals()方法寻找集合中该元素第一次出现的位置。由于在调用next()方法获取元素时，内部的cursor会自动移动到下一个位置，所以需要通过调用previousIndex()获取匹配元素的准备下标位置，方法内部会计算并返回cursor - 1的结果。</p>
<h4 id="public-int-lastIndexOf-Object-o"><a href="#public-int-lastIndexOf-Object-o" class="headerlink" title="public int lastIndexOf(Object o)"></a>public int lastIndexOf(Object o)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    ListIterator&lt;E&gt; it = listIterator(size());</span><br><span class="line">    <span class="keyword">if</span> (o==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasPrevious())</span><br><span class="line">            <span class="keyword">if</span> (it.previous()==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> it.nextIndex();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasPrevious())</span><br><span class="line">            <span class="keyword">if</span> (o.equals(it.previous()))</span><br><span class="line">                <span class="keyword">return</span> it.nextIndex();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回元素o在list集合中最后一次出现的位置，如果list集合中尚未存储元素o，那么返回-1。如果入参元素o为null，那么就寻找list集合中最后一个null元素存储的位置，否则，根据o的equals()方法寻找集合中该元素最后一次出现的位置。</p>
<h4 id="public-void-clear"><a href="#public-void-clear" class="headerlink" title="public void clear()"></a>public void clear()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    removeRange(<span class="number">0</span>, size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;移除集合中含有的所有元素。实际调用的是<strong>removeRange(int fromIndex, int toIndex)</strong>方法，因为需要在子类中实现remove(int index)或者removeRange(int fromIndex, int toIndex)，所以直接调用AbstractList的clear()方法会抛出<strong>UnsupportedOperationException</strong>异常。<strong>removeRange(int fromIndex, int toIndex)</strong>的处理逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    ListIterator&lt;E&gt; it = listIterator(fromIndex);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, n=toIndex-fromIndex; i&lt;n; i++) &#123;</span><br><span class="line">        it.next();</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;移除list集合中从fromIndex 到 toIndex的所有元素。删除的元素中包含fromIndex位置的元素，但是不包括toIndex位置的元素。方法执行完成后会将toIndex之后的元素前移填补空缺位置。由于第5行代码调用的remove()方法底层实际调用的是<strong>remove(int index)</strong>方法，而该方法在AbstractList中直接抛出<strong>UnsupportedOperationException</strong>异常，所以子类需要重写removeRange(int fromIndex, int toIndex)或者remove(int index)。</p>
<h4 id="public-boolean-addAll-int-index-Collection-lt-extends-E-gt-c"><a href="#public-boolean-addAll-int-index-Collection-lt-extends-E-gt-c" class="headerlink" title="public boolean addAll(int index, Collection&lt;? extends E&gt; c)"></a>public boolean addAll(int index, Collection&lt;? extends E&gt; c)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">        add(index++, e);</span><br><span class="line">        modified = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将c中的所有元素加入到list集合中自index起的位置上，自index位置起的元素会后移以便为c中的元素提供空间。第2行代码会检查当前list集合的剩余空间情况。之后遍历c中的每个元素，调用<strong>add(int index, E element)</strong>方法将其保存到list集合中。AbstractList中的add(int index, E element)方法由于需要子类实现，所以会直接抛出<strong>UnsupportedOperationException</strong>异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">outOfBoundsMsg</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Index: "</span>+index+<span class="string">", Size: "</span>+size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="public-Iterator-lt-E-gt-iterator"><a href="#public-Iterator-lt-E-gt-iterator" class="headerlink" title="public Iterator&lt;E&gt; iterator()"></a>public Iterator&lt;E&gt; iterator()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回一个可以遍历list集合的迭代器对象。该迭代器对象Itr是AbstractList中的一个私有类，其相关实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Index of element to be returned by subsequent call to next.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> cursor = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Index of element returned by most recent call to next or</span></span><br><span class="line"><span class="comment">     * previous.  Reset to -1 if this element is deleted by a call</span></span><br><span class="line"><span class="comment">     * to remove.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The modCount value that the iterator believes that the backing</span></span><br><span class="line"><span class="comment">     * List should have.  If this expectation is violated, the iterator</span></span><br><span class="line"><span class="comment">     * has detected concurrent modification.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = cursor;</span><br><span class="line">            E next = get(i);</span><br><span class="line">            lastRet = i;</span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            AbstractList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; cursor)</span><br><span class="line">                cursor--;</span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Itr是一个实现了Iterator\<e\>接口的迭代器类。Itr可以实现遍历list集合中的元素，并根据条件安全的删除其中特定元素。cursor标记了通过next()方法返回下一个元素的下标值，lastRet总是比cursor慢一个节拍（用于可能的删除操作），即在通过remove方法删除元素时，系统将直接删除lastRet位置的元素。第19行代码存在的变量需要判断当前list集合是否存在被其他迭代器修改的情况。如果当前list集合被其他迭代器修改过，那么会立即抛出异常（即fail-fast）。</e\></p>
<p>&emsp;&emsp;第21 ~ 23 行代码当前迭代器是否遍历到list集合尾部，如果到达了尾部会返回false，防止调用next()方法时越界溢出。</p>
<p>&emsp;&emsp;第25 ~ 37行代码返回迭代器即将遍历的下一个元素。在返回元素之前会首先判断当前list集合是否被其他迭代器修改过，如果修改过，那么直接抛出异常。如果没有被其他迭代器修改过，通过AbstractList中的get(int index)方法获取一个元素。之后更新lastRet和cursor的值，并返回获取的元素给方法调用方。</p>
<p>&emsp;&emsp;第39 ~ 53行代码迭代器会删除最近一次调用next()方法获取的元素。如果lastRet小于0（实际上通常为-1）表示在删除之前没有调用过next()方法，这个时候是无法调用remove()方法的。还有一种情况是在调用remove()方法前刚执行了一次remove()操作，实际上这种操作是不允许的。第42行代码判断当前list集合是否被其他迭代器修改过，如果修改过，那么直接抛出异常。第45行代码通过调用AbstractList中的<strong>remove(int index)</strong>方法直接删除lastRet位置处的元素。在删除之后lastRet会被重新置为-1。同时更新expectedModCount的值。</p>
<p>&emsp;&emsp;需要注意的是，由于下文中的ListItr继承了Itr，而ListItr是一个可以双向遍历的迭代器，且其继承了Itr的remove()方法。所以第46 ~ 47行代码对cursor的更新做了限定，只有在lastRet &lt; cursor时（即从前向后遍历并执行删除操作）才可以更新cursor的值。</p>
<p>&emsp;&emsp;第55 ~ 58行代码则判断当前list集合的最近一次修改是否是由当前迭代器执行的，如果不是，则会抛出异常。</p>
<h4 id="public-ListIterator-lt-E-gt-listIterator"><a href="#public-ListIterator-lt-E-gt-listIterator" class="headerlink" title="public ListIterator&lt;E&gt; listIterator()"></a>public ListIterator&lt;E&gt; listIterator()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> listIterator(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个list集合迭代器。其返回的迭代器对象ListItr是一个私有类，ListItr的相关实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">extends</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    ListItr(<span class="keyword">int</span> index) &#123;</span><br><span class="line">        cursor = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = cursor - <span class="number">1</span>;</span><br><span class="line">            E previous = get(i);</span><br><span class="line">            lastRet = cursor = i;</span><br><span class="line">            <span class="keyword">return</span> previous;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            AbstractList.<span class="keyword">this</span>.set(lastRet, e);</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = cursor;</span><br><span class="line">            AbstractList.<span class="keyword">this</span>.add(i, e);</span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;ListItr是一个既实现了Iterator\<e\>接口同时又继承了Itr的迭代器类。第2 ~ 4行代码实现了一个带参数的构造函数，该方法指定了迭代器在list集合中开始迭代的起点位置。</e\></p>
<p>&emsp;&emsp;第6 ~ 8行代码返回当前迭代器是否可以继续返回前驱节点元素。</p>
<p>&emsp;&emsp;第10 ~ 21行代码则返回当前节点的一个前驱节点元素。首先通过调用checkForComodification()方法判断当前list集合的最近一次修改是否是由当前迭代器执行的，如果不是，则会抛出异常。通过AbstractList中的get(int index)方法获取一个元素并返回获取的这个元素。之后更新lastRet和cursor的值。</p>
<p>&emsp;&emsp;第23 ~ 25行代码返回后继元素的下标值。而27 ~ 29行代码则返回前驱元素的下标值。</p>
<p>&emsp;&emsp;第31 ~ 42行代码将lastRet位置的元素替换为参数e。如果lastRet小于0，那么认为在调用<strong>set(E e)</strong>方法之前尚未调用过next()或者previous()方法，那么此时无法通过set(E e)方法实现元素替换。接着会检查当前list集合的最近一次修改是否是由当前迭代器执行的，如果不是，则会抛出异常。如果检查通过，那么调用AbstractList中的set(int index, E element)方法完成元素的替换。最后更新expectedModCount的值标记当前迭代器对list集合做出了修改。</p>
<p>&emsp;&emsp;第44 ~ 56行代码将新的元素e加入到cursor标识的位置上。在完成当前list集合的最近一次修改是否是由当前迭代器执行的检查后，通过AbstractList中的add(int index, E element)方法完成元素的加入。操作完成后将lastRet重置为-1，同时将cursor移动到下一个位置上。最后更新expectedModCount的值完成所有操作。</p>
<p>&emsp;&emsp;图1描述了ListIterator中关于cursor游标是如何工作的：</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1543500093/BlogImages/java-collection/list/AbstractList-Itr-ListItr-cursor.png" alt></p>
<div align="center">
<div align="center">图 - 1</div>
&emsp;
</div>

<h4 id="public-List-lt-E-gt-subList-int-fromIndex-int-toIndex"><a href="#public-List-lt-E-gt-subList-int-fromIndex-int-toIndex" class="headerlink" title="public List&lt;E&gt; subList(int fromIndex, int toIndex)"></a>public List&lt;E&gt; subList(int fromIndex, int toIndex)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> RandomAccess ?</span><br><span class="line">            <span class="keyword">new</span> RandomAccessSubList&lt;&gt;(<span class="keyword">this</span>, fromIndex, toIndex) :</span><br><span class="line">            <span class="keyword">new</span> SubList&lt;&gt;(<span class="keyword">this</span>, fromIndex, toIndex));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;取出当前list集合中自fromIndex（包含fromIndex）起，到toIndex（不含toIndex）为止的元素集合。根据当前list集合自身的类型会返回一个<a href="#RandomAccessSubList">RandomAccessSubList</a>或者一个<a href="#SubList">SubList</a>。</p>
<h4 id="public-boolean-equals-Object-o"><a href="#public-boolean-equals-Object-o" class="headerlink" title="public boolean equals(Object o)"></a>public boolean equals(Object o)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> List))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    ListIterator&lt;E&gt; e1 = listIterator();</span><br><span class="line">    ListIterator e2 = ((List) o).listIterator();</span><br><span class="line">    <span class="keyword">while</span> (e1.hasNext() &amp;&amp; e2.hasNext()) &#123;</span><br><span class="line">        E o1 = e1.next();</span><br><span class="line">        Object o2 = e2.next();</span><br><span class="line">        <span class="keyword">if</span> (!(o1==<span class="keyword">null</span> ? o2==<span class="keyword">null</span> : o1.equals(o2)))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !(e1.hasNext() || e2.hasNext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;判断两个list集合是否相等。如果入参o等于自身，那么返回true。如果o的类型不是list，那么返回false。如果当前list和o的集合中存在一个及以上不一致的元素，或者包含的元素个数不一致，那么返回false。</p>
<h4 id="public-int-hashCode"><a href="#public-int-hashCode" class="headerlink" title="public int hashCode()"></a>public int hashCode()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hashCode = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (E e : <span class="keyword">this</span>)</span><br><span class="line">        hashCode = <span class="number">31</span>*hashCode + (e==<span class="keyword">null</span> ? <span class="number">0</span> : e.hashCode());</span><br><span class="line">    <span class="keyword">return</span> hashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;计算list集合的散列值。</p>
<p>&emsp;</p>
<h2 id="SubList-lt-E-gt"><a href="#SubList-lt-E-gt" class="headerlink" title="SubList&lt;E&gt;"></a><span id="SubList">SubList&lt;E&gt;</span></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AbstractList&lt;E&gt; l;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，完成初始化操作</span></span><br><span class="line">    SubList(AbstractList&lt;E&gt; list, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"fromIndex = "</span> + fromIndex);</span><br><span class="line">        <span class="keyword">if</span> (toIndex &gt; list.size())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"toIndex = "</span> + toIndex);</span><br><span class="line">        <span class="keyword">if</span> (fromIndex &gt; toIndex)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"fromIndex("</span> + fromIndex +</span><br><span class="line">                                               <span class="string">") &gt; toIndex("</span> + toIndex + <span class="string">")"</span>);</span><br><span class="line">        l = list;</span><br><span class="line">        offset = fromIndex;</span><br><span class="line">        size = toIndex - fromIndex;</span><br><span class="line">        <span class="keyword">this</span>.modCount = l.modCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用element替换到子list集合中index位置处的元素，实际调用AbstractList中的set(int index, E element)方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">return</span> l.set(index+offset, element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取index位置的元素，实际调用AbstractList中的get(int index)方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">return</span> l.get(index+offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取子list集合的元素总数。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将element加入到子list集合中index位置处，实际调用AbstractList中的add(int index, E element)方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">        checkForComodification();</span><br><span class="line">        l.add(index+offset, element);</span><br><span class="line">        <span class="keyword">this</span>.modCount = l.modCount;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除index位置的元素，实际调用AbstractList中的remove(int index)方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        checkForComodification();</span><br><span class="line">        E result = l.remove(index+offset);</span><br><span class="line">        <span class="keyword">this</span>.modCount = l.modCount;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除自fromIndex起到toIndex为止的元素，实际调用AbstractList中的gremoveRange(int fromIndex, int toIndex)方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        l.removeRange(fromIndex+offset, toIndex+offset);</span><br><span class="line">        <span class="keyword">this</span>.modCount = l.modCount;</span><br><span class="line">        size -= (toIndex-fromIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将c中元素加入到子list集合中，实际调用AbstractList中的addAll(int index, Collection&lt;? extends E&gt; c)。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将c中元素加入到子list集合中自index位置起的位置离，实际调用AbstractList中的addAll(int index, Collection&lt;? extends E&gt; c)。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">        <span class="keyword">int</span> cSize = c.size();</span><br><span class="line">        <span class="keyword">if</span> (cSize==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        checkForComodification();</span><br><span class="line">        l.addAll(offset+index, c);</span><br><span class="line">        <span class="keyword">this</span>.modCount = l.modCount;</span><br><span class="line">        size += cSize;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个子list集合迭代器。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> listIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListIterator&lt;E&gt;() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> ListIterator&lt;E&gt; i = l.listIterator(index+offset);</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> nextIndex() &lt; size;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (hasNext())</span><br><span class="line">                    <span class="keyword">return</span> i.next();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> previousIndex() &gt;= <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (hasPrevious())</span><br><span class="line">                    <span class="keyword">return</span> i.previous();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> i.nextIndex() - offset;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> i.previousIndex() - offset;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                i.remove();</span><br><span class="line">                SubList.<span class="keyword">this</span>.modCount = l.modCount;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">                i.set(e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">                i.add(e);</span><br><span class="line">                SubList.<span class="keyword">this</span>.modCount = l.modCount;</span><br><span class="line">                size++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SubList&lt;&gt;(<span class="keyword">this</span>, fromIndex, toIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">outOfBoundsMsg</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Index: "</span>+index+<span class="string">", Size: "</span>+size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.modCount != l.modCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="RandomAccessSubList-lt-E-gt"><a href="#RandomAccessSubList-lt-E-gt" class="headerlink" title="RandomAccessSubList&lt;E&gt;"></a><span id="RandomAccessSubList">RandomAccessSubList&lt;E&gt;</span></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomAccessSubList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">SubList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">RandomAccess</span> </span>&#123;</span><br><span class="line">    RandomAccessSubList(AbstractList&lt;E&gt; list, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex) &#123;</span><br><span class="line">        <span class="keyword">super</span>(list, fromIndex, toIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandomAccessSubList&lt;&gt;(<span class="keyword">this</span>, fromIndex, toIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;RandomAccessSubList继承了上文提到的SubList，同时实现了RandomAccess接口，实现了一种类似于数组的以常量时间复杂度获取元素的操作方法。在RandomAccessSubList中目前只实现了获取子集合的方法。</p>
<p>&emsp;&emsp;鉴于RandomAccessSubList实现了RandomAccess接口，而RandomAccess本身仅仅起到了一个打标的作用，内部没有任何需要实现的方法，任何实现了RandomAccess的类都可以使用更加高效的、可以使用随机访问的算法来访问集合内部元素。在list集合同时存在随机访问和顺序访问两种方案，前者以ArrayList为代表，LinkedList则采用了顺序访问的思想来访问集合内元素。而决定采用随机访问还是顺序访问的方式访问集合内元素的依据就是当前实现类是否实现了RandomAccess接口。</p>
<p>&emsp;</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li>Itr和ListItr之间的不同点：<ol>
<li>Itr只能执行向后迭代遍历，ListItr可以做双向迭代遍历；</li>
<li>Itr基于整个list集合进行迭代遍历，其初始节点位置下标从0开始。ListItr可以从list集合中的某个特定节点开始遍历，其初始节点位置下标可以被设置为list集合中的任意一个特定节点位置；</li>
<li>Itr简单实现了Iterator&lt;E&gt;接口，而ListItr则继承Itr的同时又实现了ListIterator&lt;E&gt;接口。</li>
</ol>
</li>
</ol>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>千念飞羽. <a href="https://blog.csdn.net/u011518120/article/details/51932040" target="_blank" rel="noopener">源码分析-java-AbstractList-Itr和ListItr的实现</a> [E]</li>
</ol>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java I/O 11 - ByteArrayInputStream &amp; ByteArrayOutputStream</title>
    <url>/2018/java-ByteArrayInputStream-ByteArrayOutputStream.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;关于<em> <strong>java.io.ByteArrayInputStream</strong> </em> 和 <em> <strong>java.io.ByteArrayOutputStream</strong> </em>的部分笔记，这两个类相互合作借助内存来完成数据的读写和转移。本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;ByteArrayInputStream和ByteArrayOutputStream没有太多涉及到和其他输入输出流进行交互的设计和实现，更多的是通过这两个类内部维护在内存中的字节数组来完成数据的读写和转移。对于一些不需要做持久处理的数据而言，以内存作为中转站来完成数据的操作和转移相对于写文件或者数据库等持久化处理来说性能更乐观，同时也省掉了很多不必要的、没有实际价值的处理和操作。</p>
<p>&emsp;</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ByteArrayInputStream</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.io.InputStream</span><br><span class="line">    --java.io.ByteArrayInputStream</span><br><span class="line"></span><br><span class="line"><span class="comment">// ByteArrayOutputStream</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.io.InputStream</span><br><span class="line">    --java.io.ByteArrayOutputStream</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类名</th>
<th style="text-align:center">实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ByteArrayInputStream</td>
<td style="text-align:center">Closeable, AutoCloseable</td>
</tr>
<tr>
<td style="text-align:center">ByteArrayOutputStream</td>
<td style="text-align:center">Closeable, Flushable, AutoCloseable</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="ByteArrayInputStream"><a href="#ByteArrayInputStream" class="headerlink" title="ByteArrayInputStream"></a>ByteArrayInputStream</h2><h3 id="Constructor-Summary"><a href="#Constructor-Summary" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="public-ByteArrayInputStream-byte-buf"><a href="#public-ByteArrayInputStream-byte-buf" class="headerlink" title="public ByteArrayInputStream(byte buf[])"></a>public ByteArrayInputStream(byte buf[])</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ByteArrayInputStream</span><span class="params">(<span class="keyword">byte</span> buf[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.buf = buf;</span><br><span class="line">    <span class="keyword">this</span>.pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.count = buf.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;参数是一个byte类型的数组，该数组的内容会被指向输入流中的字段<strong>buf</strong>，所以入参buf的内容会成为输入流方法read()中的数据源。pos指向了下一个可以读取数据的位置。count指向了缓冲区数组中数据结束的位置。</p>
<h4 id="public-ByteArrayInputStream-byte-buf-int-offset-int-length"><a href="#public-ByteArrayInputStream-byte-buf-int-offset-int-length" class="headerlink" title="public ByteArrayInputStream(byte buf[], int offset, int length)"></a>public ByteArrayInputStream(byte buf[], int offset, int length)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ByteArrayInputStream</span><span class="params">(<span class="keyword">byte</span> buf[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.buf = buf;</span><br><span class="line">    <span class="keyword">this</span>.pos = offset;</span><br><span class="line">    <span class="keyword">this</span>.count = Math.min(offset + length, buf.length);</span><br><span class="line">    <span class="keyword">this</span>.mark = offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;参数是一个byte类型的数组，该数组的内容会被指向输入流中的字段<strong>buf</strong>，所以入参buf的内容会成为输入流方法read()中的数据源。由参数offset确定pos指向的下一个可以读取数据的位置，同时指定mark，因为offset可能不为0，所以通过mark可以保证offset之前的数据永远不会被读到。</p>
<h3 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="public-synchronized-int-read"><a href="#public-synchronized-int-read" class="headerlink" title="public synchronized int read()"></a>public synchronized int read()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (pos &lt; count) ? (buf[pos++] &amp; <span class="number">0xff</span>) : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回缓冲区数组中的当前读取位置的数据。由于数组中存储的是byte类型，所以需要通过“<strong>0xff</strong>”来完成向int类型的转换。如果当前pos位置大于等于count，那么认为数据已经读完了，所以返回<strong>-1</strong>。</p>
<h4 id="public-ynchronized-int-read-byte-b-int-off-int-len"><a href="#public-ynchronized-int-read-byte-b-int-off-int-len" class="headerlink" title="public ynchronized int read(byte b[], int off, int len)"></a>public ynchronized int read(byte b[], int off, int len)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (off &lt; <span class="number">0</span> || len &lt; <span class="number">0</span> || len &gt; b.length - off) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pos &gt;= count) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> avail = count - pos;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; avail) &#123;</span><br><span class="line">        len = avail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.arraycopy(buf, pos, b, off, len);</span><br><span class="line">    pos += len;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将数据读取到入参数组b中。第2 ~ 6行代码用来完成相关参数的校验，保证不会发生越界问题。第8 ~ 10行代码如果当前读取位置大于等于count，那么认为缓冲区数组中已经没有可读数据了，所以返回-1标识文件读取结束。第12行计算缓冲区数组中剩余的未读取数据的容量，如果入参长度len大于第12行代码的计算结果，那么就把缓冲区数组中的内容全部返回给数组b。第19行代码用来完成数据复制和填充，之后会更新pos的值，最后返回实际读取的数据长度给方法调用方。</p>
<h4 id="public-synchronized-long-skip-long-n"><a href="#public-synchronized-long-skip-long-n" class="headerlink" title="public synchronized long skip(long n)"></a>public synchronized long skip(long n)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> k = count - pos;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; k) &#123;</span><br><span class="line">        k = n &lt; <span class="number">0</span> ? <span class="number">0</span> : n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pos += k;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;跳过输入流缓冲区数组中指定长度的内容。第2行代码首先计算了缓冲区数组中剩余的未读取的数据长度。第3 ~ 5行则计算缓冲区数组的剩余未读取数据的长度和入参n的大小关系，如果缓冲区数组中的剩余数据长度大于n，那么实际跳过长度等于入参n，否则实际跳过长度等于缓冲区数组的剩余数据长度（即直接跳到缓冲区数组尾部）。如果入参n小于0，那么跳过长度为0。第7行代码计算了跳过后的pos值，并返回实际跳过的长度给方法调用方。</p>
<h4 id="public-synchronized-int-available"><a href="#public-synchronized-int-available" class="headerlink" title="public synchronized int available()"></a>public synchronized int available()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">available</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count - pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;计算缓冲区数组中剩余的未读取的数据长度。</p>
<h4 id="public-boolean-markSupported"><a href="#public-boolean-markSupported" class="headerlink" title="public boolean markSupported()"></a>public boolean markSupported()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">markSupported</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;ByteArrayInputStream支持mark标记。</p>
<h4 id="public-void-mark-int-readAheadLimit"><a href="#public-void-mark-int-readAheadLimit" class="headerlink" title="public void mark(int readAheadLimit)"></a>public void mark(int readAheadLimit)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> readAheadLimit)</span> </span>&#123;</span><br><span class="line">    mark = pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;重复读取打标。方法入参readAheadLimit没有任何意义。在调用过若干次read()方法后调用mark()方法，可以设置一个mark标记位置，该位置记录希望重复读取数据的起点。如果下面的reset()方法恢复pos位置到上一次调用mark()方法的位置。</p>
<h4 id="public-synchronized-void-reset"><a href="#public-synchronized-void-reset" class="headerlink" title="public synchronized void reset()"></a>public synchronized void reset()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pos = mark;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;设置重读取位置。</p>
<h4 id="public-void-close"><a href="#public-void-close" class="headerlink" title="public void close()"></a>public void close()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;ByteArrayInputStream的关闭方法不执行任何操作，涉及的资源会直接被GC回收和释放掉。</p>
<p>&emsp;</p>
<h2 id="ByteArrayOutputStream"><a href="#ByteArrayOutputStream" class="headerlink" title="ByteArrayOutputStream"></a>ByteArrayOutputStream</h2><h3 id="Constructor-Summary-1"><a href="#Constructor-Summary-1" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="public-ByteArrayOutputStream"><a href="#public-ByteArrayOutputStream" class="headerlink" title="public ByteArrayOutputStream()"></a>public ByteArrayOutputStream()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ByteArrayOutputStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">32</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个输出流。设置缓冲区数组的大小为32个长度。</p>
<h4 id="public-ByteArrayOutputStream-int-size"><a href="#public-ByteArrayOutputStream-int-size" class="headerlink" title="public ByteArrayOutputStream(int size)"></a>public ByteArrayOutputStream(int size)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ByteArrayOutputStream</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Negative initial size: "</span> + size);</span><br><span class="line">    &#125;</span><br><span class="line">    buf = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个输出流。设置缓冲区数组的大小为入参size个长度。</p>
<h3 id="部分方法-1"><a href="#部分方法-1" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="public-synchronized-void-write-int-b"><a href="#public-synchronized-void-write-int-b" class="headerlink" title="public synchronized void write(int b)"></a>public synchronized void write(int b)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    ensureCapacity(count + <span class="number">1</span>);</span><br><span class="line">    buf[count] = (<span class="keyword">byte</span>) b;</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;向缓冲区数组中写入一个字节的数据。第2行代码首先会判断当前缓冲区数组中是否有足够的空间容纳新写入的内容，如果空间不足，那么会对当前缓冲区数组做扩容处理。然后将数据写入到缓冲区数组中，同时将count值加一。</p>
<h4 id="public-synchronized-void-write-byte-b-int-off-int-len"><a href="#public-synchronized-void-write-byte-b-int-off-int-len" class="headerlink" title="public synchronized void write(byte b[], int off, int len)"></a>public synchronized void write(byte b[], int off, int len)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((off &lt; <span class="number">0</span>) || (off &gt; b.length) || (len &lt; <span class="number">0</span>) ||</span><br><span class="line">        ((off + len) - b.length &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125;</span><br><span class="line">    ensureCapacity(count + len);</span><br><span class="line">    System.arraycopy(b, off, buf, count, len);</span><br><span class="line">    count += len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;向缓冲区数组中写入入参数组b中的内容。第2 ~ 5行代码用来完成入参的有效性校验，保证不会发生溢出越界的情况。第6行代码判断当前缓冲区数组中是否有足够的空间容纳新写入的内容，如果空间不足，那么会对当前缓冲区数组做扩容处理。第7行代码将数组b中的内容维护到缓冲区数组中，同时维护count值。</p>
<h4 id="private-void-ensureCapacity-int-minCapacity"><a href="#private-void-ensureCapacity-int-minCapacity" class="headerlink" title="private void ensureCapacity(int minCapacity)"></a>private void ensureCapacity(int minCapacity)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - buf.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = buf.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    buf = Arrays.copyOf(buf, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE : MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;用来完成缓冲区数组剩余空间不足以容纳新写入数据时的扩容处理。第3行代码计算缓冲区数组是否有足够的剩余空间容纳新数据。如果空间不足，那么调用grow()方法完成扩充处理。第9 ~ 10行代码首先将现有缓冲区数组的长度扩大一倍，如果扩大后的长度还是比实际需要的长度小，那么就用实际需要的长度作为缓冲区数组的长度。第13 ~ 14行代码中，如果newCapacity超出了ByteArrayOutputStream种规定的可分配的最大数组长度（<strong>Integer.MAX_VALUE - 8</strong>）那么就根据实际所需长度和MAX_ARRAY_SIZE的关系来决定最终分配的数据长度。最后完成缓冲区数组的扩容，同时将旧缓冲区数组中的内容维护到新数组中去。</p>
<h4 id="public-synchronized-void-writeTo-OutputStream-out"><a href="#public-synchronized-void-writeTo-OutputStream-out" class="headerlink" title="public synchronized void writeTo(OutputStream out)"></a>public synchronized void writeTo(OutputStream out)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writeTo</span><span class="params">(OutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    out.write(buf, <span class="number">0</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;向指定输出流中把缓冲区数组的内容写进去。</p>
<h4 id="public-synchronized-void-reset-1"><a href="#public-synchronized-void-reset-1" class="headerlink" title="public synchronized void reset()"></a>public synchronized void reset()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;清空缓冲区数组。其中包含的数据都会被清空。</p>
<h4 id="public-synchronized-byte-toByteArray"><a href="#public-synchronized-byte-toByteArray" class="headerlink" title="public synchronized byte toByteArray()[]"></a>public synchronized byte toByteArray()[]</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">byte</span> <span class="title">toByteArray</span><span class="params">()</span>[] </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(buf, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将当前缓冲区数组转成新的byte数组。会把当前缓冲区数组中的内容完整的复制一份到新的byte数组中去。</p>
<h4 id="public-synchronized-int-size"><a href="#public-synchronized-int-size" class="headerlink" title="public synchronized int size()"></a>public synchronized int size()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回当前缓冲区数组中有效内容的长度。</p>
<h4 id="public-synchronized-String-toString-String-charsetName"><a href="#public-synchronized-String-toString-String-charsetName" class="headerlink" title="public synchronized String toString(String charsetName)"></a>public synchronized String toString(String charsetName)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">toString</span><span class="params">(String charsetName)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="number">0</span>, count, charsetName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;把缓冲区数组中的内容转成一个String字符串并返回。转换使用的字符集采用的是方法传入的字符集。转化后的字符串长度因为字符集编码的不同可能不会等同于缓冲区数组的长度。</p>
<h4 id="public-synchronized-String-toString"><a href="#public-synchronized-String-toString" class="headerlink" title="public synchronized String toString()"></a>public synchronized String toString()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="number">0</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;把缓冲区数组中的内容转成一个String字符串并返回。转换使用的字符集采用的是平台默认的字符集。转化后的字符串长度因为字符集编码的不同可能不会等同于缓冲区数组的长度。</p>
<h4 id="public-void-close-1"><a href="#public-void-close-1" class="headerlink" title="public void close()"></a>public void close()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span>  <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;ByteArrayInputStream的关闭方法不执行任何操作，涉及的资源会直接被GC回收和释放掉。</p>
<p>&emsp;</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li>NIL</li>
</ol>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>Windsor90. <a href="https://blog.csdn.net/zhuwenchao90/article/details/54645814" target="_blank" rel="noopener">【Java基础知识】IO流—内存操作流ByteArrayInputStream、ByteArrayOutputStream</a> [E]</li>
<li>yuleichun. <a href="https://blog.csdn.net/yuleichun/article/details/60129134" target="_blank" rel="noopener">在java开发过程中什么时候使用ByteArrayInputStream和ByteArrayOuitputStream?</a> [E]</li>
</ol>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Map 02 - AbstractMap</title>
    <url>/2018/java-Collection-AbstractMap.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;关于<em> <strong>java.util.AbstractMap&lt;K, V&gt;</strong> </em>的部分笔记，提供了对Map接口的最小实现。本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;AbstractMap提供了关于Map接口的一个最小规模实现。</p>
<p>&emsp;&emsp;如果需要实现一个不可修改的map集合，开发人员只需要继承AbstractMap类并提供一个entrySet方法的实现。该方法以set集合形式返回了当前map集合的键值对映射，返回的set集合不支持add和remove方法，对应的迭代器也不支持remove操作。</p>
<p>&emsp;&emsp;如果需要实现一个可修改的map集合，需要额外实现put方法，且返回的迭代器类需要实现remove方法。</p>
<p>&emsp;&emsp;AbstractMap类的方法可以在需要提升性能的情况下被子类覆盖重新实现。</p>
<p>&emsp;</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractSet&lt;E&gt;</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.util.AbstractMap&lt;K,V&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><div class="table-container">
<table>
<thead>
<tr>
<th>类名</th>
<th>实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>AbstractMap&lt;E&gt;</td>
<td>Map&lt;K,V&gt;</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="AbstractMap"><a href="#AbstractMap" class="headerlink" title="AbstractMap"></a>AbstractMap</h2><h3 id="Constructor-Summary"><a href="#Constructor-Summary" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="protected-AbstractMap"><a href="#protected-AbstractMap" class="headerlink" title="protected AbstractMap()"></a>protected AbstractMap()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;默认构造函数。采用protected修饰的原因是因为AbstractMap不直接用于集合的初始化操作，而是在使用真正可用的Set集合处理类时提供一些基础准备工作。所以这个方法不应该暴露到外界去，所以不能用public修饰。同样的原因，因为AbstractMap不涉及到单例模式的设计，所以也不会是private，这样其子类也没办法继承到父类的无参构造方法。所以综上考虑，protected是最理想的选择。</p>
<h3 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="public-int-size"><a href="#public-int-size" class="headerlink" title="public int size()"></a>public int size()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> entrySet().size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回当前map集合中存储的键值对数量，如果超过了Integer的最大值（MAX_VALUE）那么就返回MAX_VALUE。</p>
<h4 id="public-boolean-isEmpty"><a href="#public-boolean-isEmpty" class="headerlink" title="public boolean isEmpty()"></a>public boolean isEmpty()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果当前map集合不包含任何键值对，那么返回true。</p>
<h4 id="public-boolean-containsValue-Object-value"><a href="#public-boolean-containsValue-Object-value" class="headerlink" title="public boolean containsValue(Object value)"></a>public boolean containsValue(Object value)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">    <span class="keyword">if</span> (value==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            <span class="keyword">if</span> (e.getValue()==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            <span class="keyword">if</span> (value.equals(e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;判断当前集合是否存储val为value的键值对映射。如果当前集合中存储了一个及以上val为value的键值对，那么就返回true，否则返回false。整个过程需要O（n）time，n为当前集合中存储的元素数量。方法采用equals()方法完成元素相等检查。</p>
<h4 id="public-boolean-containsKey-Object-key"><a href="#public-boolean-containsKey-Object-key" class="headerlink" title="public boolean containsKey(Object key)"></a>public boolean containsKey(Object key)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">    <span class="keyword">if</span> (key==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            <span class="keyword">if</span> (e.getKey()==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            <span class="keyword">if</span> (key.equals(e.getKey()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;判断当前集合是否存储key为入参key的键值对映射。如果当前集合中存储了一个及以上key为入参key的键值对，那么就返回true，否则返回false。整个过程需要O（n）time，n为当前集合中存储的元素数量。方法采用equals()方法完成元素相等检查。</p>
<h4 id="public-V-get-Object-key"><a href="#public-V-get-Object-key" class="headerlink" title="public V get(Object key)"></a>public V get(Object key)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">    <span class="keyword">if</span> (key==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            <span class="keyword">if</span> (e.getKey()==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> e.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            <span class="keyword">if</span> (key.equals(e.getKey()))</span><br><span class="line">                <span class="keyword">return</span> e.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从当前集合中查找并返回key为入参key的键值对映射中含有的value。如果集合中未存储key为入参key的键值对映射，那么返回null。整个过程需要O（n）time，n为当前集合中存储的元素数量。方法采用equals()方法完成元素相等检查。</p>
<h4 id="public-V-put-K-key-V-value"><a href="#public-V-put-K-key-V-value" class="headerlink" title="public V put(K key, V value)"></a>public V put(K key, V value)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;向当前map集合中插入一个key-value键值对。当前类不支持该操作，抛出异常。</p>
<h4 id="public-V-remove-Object-key"><a href="#public-V-remove-Object-key" class="headerlink" title="public V remove(Object key)"></a>public V remove(Object key)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">    Entry&lt;K,V&gt; correctEntry = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (key==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (correctEntry==<span class="keyword">null</span> &amp;&amp; i.hasNext()) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            <span class="keyword">if</span> (e.getKey()==<span class="keyword">null</span>)</span><br><span class="line">                correctEntry = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (correctEntry==<span class="keyword">null</span> &amp;&amp; i.hasNext()) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            <span class="keyword">if</span> (key.equals(e.getKey()))</span><br><span class="line">                correctEntry = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V oldValue = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (correctEntry !=<span class="keyword">null</span>) &#123;</span><br><span class="line">        oldValue = correctEntry.getValue();</span><br><span class="line">        i.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从当前map集合中删除入参key的键值对映射，并返回映射对应的value值。第2 ~ 16行代码用来查找集合中对应于入参key的键值对映射，如果找到一个，那么就退出循环执行删除操作。第19 ~ 22行代码得到要删除的键值对映射的value值，并利用迭代器删除该键值对映射，最后返回value值。</p>
<h4 id="public-void-putAll-Map-lt-extends-K-extends-V-gt-m"><a href="#public-void-putAll-Map-lt-extends-K-extends-V-gt-m" class="headerlink" title="public void putAll(Map&lt;? extends K, ? extends V&gt; m)"></a>public void putAll(Map&lt;? extends K, ? extends V&gt; m)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())</span><br><span class="line">        put(e.getKey(), e.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;当前集合m中的键值对映射逐个保存到当前map集合中。底层调用的是<strong>put(K key, V value)</strong>方法，在AbstractMap中不支持插入操作，所以会抛出异常。</p>
<h4 id="public-void-clear"><a href="#public-void-clear" class="headerlink" title="public void clear()"></a>public void clear()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    entrySet().clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;清空当前map集合中存储的所有键值对映射。</p>
<h4 id="public-Set-lt-K-gt-keySet"><a href="#public-Set-lt-K-gt-keySet" class="headerlink" title="public Set&lt;K&gt; keySet()"></a>public Set&lt;K&gt; keySet()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (keySet == <span class="keyword">null</span>) &#123;</span><br><span class="line">        keySet = <span class="keyword">new</span> AbstractSet&lt;K&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;K&gt;() &#123;</span><br><span class="line">                    <span class="keyword">private</span> Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line"></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> i.hasNext();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> K <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> i.next().getKey();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        i.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> AbstractMap.<span class="keyword">this</span>.size();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> AbstractMap.<span class="keyword">this</span>.isEmpty();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                AbstractMap.<span class="keyword">this</span>.clear();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> AbstractMap.<span class="keyword">this</span>.containsKey(k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> keySet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回当前map集合中存储的键值对映射的key值集合。该内容会在方法第一次被调用时创建，如果在方法调用时该内容已经存在，那么不做任何处理。</p>
<p>&emsp;&emsp;对该集合做的操作会同步出现在map集合上，反之亦然。该返回集合支持remove操作，操作后的执行效果是将map集合中对应的键值对删除。</p>
<h4 id="public-Collection-lt-V-gt-values"><a href="#public-Collection-lt-V-gt-values" class="headerlink" title="public Collection&lt;V&gt; values()"></a>public Collection&lt;V&gt; values()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (values == <span class="keyword">null</span>) &#123;</span><br><span class="line">        values = <span class="keyword">new</span> AbstractCollection&lt;V&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Iterator&lt;V&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;V&gt;() &#123;</span><br><span class="line">                    <span class="keyword">private</span> Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line"></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> i.hasNext();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> V <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> i.next().getValue();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        i.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> AbstractMap.<span class="keyword">this</span>.size();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> AbstractMap.<span class="keyword">this</span>.isEmpty();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                AbstractMap.<span class="keyword">this</span>.clear();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object v)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> AbstractMap.<span class="keyword">this</span>.containsValue(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回当前map集合中存储的键值对映射的value值集合。该内容会在方法第一次被调用时创建，如果在方法调用时该内容已经存在，那么不做任何处理。</p>
<p>&emsp;&emsp;对该集合做的操作会同步出现在map集合上，反之亦然。该集合支持remove操作，删除操作后的执行结果是将当前map集合中对应的键值对删除。</p>
<h4 id="public-abstract-Set-lt-Entry-lt-K-V-gt-gt-entrySet"><a href="#public-abstract-Set-lt-Entry-lt-K-V-gt-gt-entrySet" class="headerlink" title="public abstract Set&lt;Entry&lt;K,V&gt;&gt; entrySet()"></a>public abstract Set&lt;Entry&lt;K,V&gt;&gt; entrySet()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Set&lt;Entry&lt;K,V&gt;&gt; entrySet();</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;需要子类实现的抽象方法，用来返回当前map集合的键值对映射的set集合。</p>
<h4 id="public-boolean-equals-Object-o"><a href="#public-boolean-equals-Object-o" class="headerlink" title="public boolean equals(Object o)"></a>public boolean equals(Object o)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Map&lt;K,V&gt; m = (Map&lt;K,V&gt;) o;</span><br><span class="line">    <span class="keyword">if</span> (m.size() != size())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!(m.get(key)==<span class="keyword">null</span> &amp;&amp; m.containsKey(key)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!value.equals(m.get(key)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassCastException unused) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException unused) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;判断对象o和当前map是否相等。如果o也是一个map且两个map拥有相同的键值对（数量一致，内容一致），那么方法返回true。</p>
<p>&emsp;&emsp;方法会首先检查o是否是当前map自身，如果是，直接返回true。然后检查o是否是一个map，如果不是返回false。如果是，那么检查o存储的键值对数量和当前map集合是否一致，如果不一致返回false。数量校验处理完后检查两个map中的每个键值对的key和value是否存在不一致的结果，如果存在返回false。所有的检查都通过后，认为两个map相等，返回true。</p>
<p>&emsp;&emsp;在整个过程中通过equals()方法完成相等比较。</p>
<h4 id="public-int-hashCode"><a href="#public-int-hashCode" class="headerlink" title="public int hashCode()"></a>public int hashCode()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">    Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (i.hasNext())</span><br><span class="line">        h += i.next().hashCode();</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回当前map集合的hashcode值。map的hashcode值由map中所有键值对实例的hashcode值求和得到。Entry对象的hashcode计算规则是：</p>
<blockquote>
<p>(e.getKey() == null   ? 0 : e.getKey().hashCode())  ^  </p>
<p>(e.getValue() == null ? 0 : e.getValue().hashCode())</p>
</blockquote>
<p>对key的hashcode和value的hashcode求异或运算。</p>
<h4 id="public-String-toString"><a href="#public-String-toString" class="headerlink" title="public String toString()"></a>public String toString()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">    <span class="keyword">if</span> (! i.hasNext())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;&#125;"</span>;</span><br><span class="line"></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(<span class="string">'&#123;'</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">        K key = e.getKey();</span><br><span class="line">        V value = e.getValue();</span><br><span class="line">        sb.append(key   == <span class="keyword">this</span> ? <span class="string">"(this Map)"</span> : key);</span><br><span class="line">        sb.append(<span class="string">'='</span>);</span><br><span class="line">        sb.append(value == <span class="keyword">this</span> ? <span class="string">"(this Map)"</span> : value);</span><br><span class="line">        <span class="keyword">if</span> (! i.hasNext())</span><br><span class="line">            <span class="keyword">return</span> sb.append(<span class="string">'&#125;'</span>).toString();</span><br><span class="line">        sb.append(<span class="string">','</span>).append(<span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回当前map集合的String表示形式。所有的键值对内容被“{}”包围，每个键值对之间用“，”分隔，单个键值对以“=”连接键和值。</p>
<h4 id="protected-Object-clone"><a href="#protected-Object-clone" class="headerlink" title="protected Object clone()"></a>protected Object clone()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    AbstractMap&lt;K,V&gt; result = (AbstractMap&lt;K,V&gt;)<span class="keyword">super</span>.clone();</span><br><span class="line">    result.keySet = <span class="keyword">null</span>;</span><br><span class="line">    result.values = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将当前AbstractMap集合复制一份并返回。执行的是浅度复制，且只复制map集合本身，内部的键值对不会被复制。</p>
<h4 id="private-static-boolean-eq-Object-o1-Object-o2"><a href="#private-static-boolean-eq-Object-o1-Object-o2" class="headerlink" title="private static boolean eq(Object o1, Object o2)"></a>private static boolean eq(Object o1, Object o2)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">eq</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> o1 == <span class="keyword">null</span> ? o2 == <span class="keyword">null</span> : o1.equals(o2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="SimpleEntry-lt-K-V-gt"><a href="#SimpleEntry-lt-K-V-gt" class="headerlink" title="SimpleEntry&lt;K,V&gt;"></a>SimpleEntry&lt;K,V&gt;</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleEntry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">8499721149061103585L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> K key;</span><br><span class="line">	<span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 初始化一个map集合中键值对实体</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SimpleEntry</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.key = key;</span><br><span class="line">		<span class="keyword">this</span>.value = value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 初始化一个map集合中键值对实体</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SimpleEntry</span><span class="params">(Entry&lt;? extends K, ? extends V&gt; entry)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.key = entry.getKey();</span><br><span class="line">		<span class="keyword">this</span>.value = entry.getValue();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取实体的key值</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> key;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取实体的valu值</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 设置当前实体的value值并返回被替换的值。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">		V oldValue = <span class="keyword">this</span>.value;</span><br><span class="line">		<span class="keyword">this</span>.value = value;</span><br><span class="line">		<span class="keyword">return</span> oldValue;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 判断对象o和当前实体是否相等</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		Map.Entry e = (Map.Entry) o;</span><br><span class="line">		<span class="keyword">return</span> eq(key, e.getKey()) &amp;&amp; eq(value, e.getValue());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 计算当前实体的hashcode值，根据key的hashcode和value的hashcode做异或运算。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (key == <span class="keyword">null</span> ? <span class="number">0</span> : key.hashCode())</span><br><span class="line">				^ (value == <span class="keyword">null</span> ? <span class="number">0</span> : value.hashCode());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 返回当前实体的string表示形式。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> key + <span class="string">"="</span> + value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="SimpleImmutableEntry-lt-K-V-gt"><a href="#SimpleImmutableEntry-lt-K-V-gt" class="headerlink" title="SimpleImmutableEntry&lt;K, V&gt;"></a>SimpleImmutableEntry&lt;K, V&gt;</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleImmutableEntry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7138329143949025153L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> K key;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> V value;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 初始化一个不可修改value值的键值对实体</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SimpleImmutableEntry</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.key = key;</span><br><span class="line">		<span class="keyword">this</span>.value = value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 初始化一个不可修改value值的键值对实体</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SimpleImmutableEntry</span><span class="params">(Entry&lt;? extends K, ? extends V&gt; entry)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.key = entry.getKey();</span><br><span class="line">		<span class="keyword">this</span>.value = entry.getValue();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取当前实体的key值</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> key;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取当前实体的value值</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 实体valu值不可修改，抛出异常</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 计算对象o和当前实体是否相等</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		Map.Entry e = (Map.Entry) o;</span><br><span class="line">		<span class="keyword">return</span> eq(key, e.getKey()) &amp;&amp; eq(value, e.getValue());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 计算当前实体的hashcode值，根据key的hashcode和valu的hashcode求异或运算。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (key == <span class="keyword">null</span> ? <span class="number">0</span> : key.hashCode())</span><br><span class="line">				^ (value == <span class="keyword">null</span> ? <span class="number">0</span> : value.hashCode());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 返回当前实体的String表示形式。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> key + <span class="string">"="</span> + value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li>NIL</li>
</ol>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>NIL</li>
</ol>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Collection 06 - AbstractSequentialList</title>
    <url>/2018/java-Collection-AbstractSequentialList.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;关于<em> <strong>java.util.AbstractSequentialList&lt;E&gt;</strong> </em>的部分笔记。AbstractSequentialList因其借鉴顺序访问的思想而被用于插入元素比访问元素更频繁的场景中。顺序访问思想赋予了其插入元素可以做到常量时间的优势。鉴于其是一个抽象类，在实际应用时实现其抽象方法来完成实际操作。需要本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;AbstractSequentialList提供了顺序访问List集合的一种思路和实现，其最常见的实现类即为 <a href>LinkedList</a>。和以AbstractList为代表的随机访问类相比，顺序访问会导致在访问元素时会按照从首到尾逐个遍历的方式获取目标元素，所以其访问元素需要的时间随着集合元素数量呈比例增长，但是其优点是保证了元素插入的高效率。</p>
<p>&emsp;&emsp;鉴于AbstractSequentialList已经实现了List和Collection接口的部分方法，所以如果单纯的实现一个AbstractSequentialList的话，只需要实现listIterator(int index)和size()方法即可。如果需要实现一个不可修改的List集合，那么只需要实现listIterator的hasNext()、next()、hasPrevious()和index()方法即可。</p>
<p>&emsp;&emsp;如果需要实现一个可修改的List集合，除了上述提及方法外还需要实现listIterator的set()方法。如果需要实现一个长度可变的List集合，还需要额外实现listIterator的remove()和add()方法。</p>
<p>&emsp;</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractSequentialList&lt;E&gt;</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.util.AbstractCollection&lt;E&gt;</span><br><span class="line">    --java.util.AbstractList&lt;E&gt;</span><br><span class="line">      --java.util.AbstractSequentialList&lt;E&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><div class="table-container">
<table>
<thead>
<tr>
<th>类名</th>
<th>实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>AbstractSequentialList&lt;E&gt;</td>
<td>Iterable&lt;E&gt;, Collection&lt;E&gt;, List&lt;E&gt;</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="AbstractSequentialList"><a href="#AbstractSequentialList" class="headerlink" title="AbstractSequentialList"></a>AbstractSequentialList</h2><h3 id="Constructor-Summary"><a href="#Constructor-Summary" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="protected-AbstractSequentialList"><a href="#protected-AbstractSequentialList" class="headerlink" title="protected AbstractSequentialList()"></a>protected AbstractSequentialList()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractSequentialList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;默认构造函数。采用protected修饰的原因是因为AbstractSequentialList不直接用于集合的初始化操作，而是在使用真正可用的list集合处理类时提供一些基础准备工作。所以这个方法不应该暴露到外界去，所以不能用public修饰。同样的原因，因为AbstractSequentialList不涉及到单例模式的设计，所以也不会是private，这样其子类也没办法继承到父类的无参构造方法。所以综上考虑，protected是最理想的选择。</p>
<h3 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="public-E-get-int-index"><a href="#public-E-get-int-index" class="headerlink" title="public E get(int index)"></a>public E get(int index)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> listIterator(index).next();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchElementException exc) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回index位置下标的元素。通过初始化一个遍历位置自index起的listIterator，然后借助这个listIterator的next()方法来完成元素的获取和返回。</p>
<h4 id="public-E-set-int-index-E-element"><a href="#public-E-set-int-index-E-element" class="headerlink" title="public E set(int index, E element)"></a>public E set(int index, E element)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ListIterator&lt;E&gt; e = listIterator(index);</span><br><span class="line">        E oldVal = e.next();</span><br><span class="line">        e.set(element);</span><br><span class="line">        <span class="keyword">return</span> oldVal;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchElementException exc) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;用element替换List集合中下标为index的元素，并返回被替换的元素。</p>
<h4 id="public-void-add-int-index-E-element"><a href="#public-void-add-int-index-E-element" class="headerlink" title="public void add(int index, E element)"></a>public void add(int index, E element)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        listIterator(index).add(element);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchElementException exc) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将元素element加入到List集合Index位置上。</p>
<h4 id="public-E-remove-int-index"><a href="#public-E-remove-int-index" class="headerlink" title="public E remove(int index)"></a>public E remove(int index)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ListIterator&lt;E&gt; e = listIterator(index);</span><br><span class="line">        E outCast = e.next();</span><br><span class="line">        e.remove();</span><br><span class="line">        <span class="keyword">return</span> outCast;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchElementException exc) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;移除List集合中index位置上的元素，并返回被移除的元素。</p>
<h4 id="public-boolean-addAll-int-index-Collection-lt-extends-E-gt-c"><a href="#public-boolean-addAll-int-index-Collection-lt-extends-E-gt-c" class="headerlink" title="public boolean addAll(int index, Collection&lt;? extends E&gt; c)"></a>public boolean addAll(int index, Collection&lt;? extends E&gt; c)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">        ListIterator&lt;E&gt; e1 = listIterator(index);</span><br><span class="line">        Iterator&lt;? extends E&gt; e2 = c.iterator();</span><br><span class="line">        <span class="keyword">while</span> (e2.hasNext()) &#123;</span><br><span class="line">            e1.add(e2.next());</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> modified;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchElementException exc) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将集合c中的元素加入到List集合中自index位置起的空间里。被加入到List集合的元素的前后顺序和其在c中的顺序一致。</p>
<h4 id="public-Iterator-iterator"><a href="#public-Iterator-iterator" class="headerlink" title="public Iterator\ iterator()"></a>public Iterator\<e\> iterator()</e\></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> listIterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回一个可以遍历当前List集合的迭代器。实际调用的是AbstractList中的listIterator()方法，其开始遍历位置默认为0。</p>
<h4 id="public-abstract-ListIterator-listIterator-int-index"><a href="#public-abstract-ListIterator-listIterator-int-index" class="headerlink" title="public abstract ListIterator\ listIterator(int index)"></a>public abstract ListIterator\<e\> listIterator(int index)</e\></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回一个可以遍历当前List集合的迭代器，其开始遍历位置由index指定。该方法被声明为抽象方法，需要在子类中实现该方法。</p>
<p>&emsp;</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li>NIL</li>
</ol>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>NIL<br>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Collection 09 - AbstractSet</title>
    <url>/2018/java-Collection-AbstractSet.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;关于<em> <strong>java.util.AbstractSet&lt;E&gt;</strong> </em>的部分笔记，AbstractSet是Set的默认最小化实现。在具体的使用场景中，由继承AbstractSet的具体实现类完成数据的存储和操作需求。本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;AbstractSet对Set接口做了最小规模的实现。实际上仅实现了Set接口的<strong>removeAll(Collection&lt;?&gt; c)</strong>方法。除此之外就是重写了equals(Object o)方法和hashCode()方法。由于AbstractSet继承了AbstractCollection，所以继承AbstractSet并实现Set接口的具体实现类也会包含AbstractCollection中的方法，但是要注意的是，实现类只是单纯的继承和拥有了AbstractCollection的方法，并未尝试对AbstractCollection中的方法进行覆盖。</p>
<p>&emsp;</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractSet&lt;E&gt;</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.util.AbstractCollection&lt;E&gt;</span><br><span class="line">    --java.util.AbstractSet&lt;E&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><div class="table-container">
<table>
<thead>
<tr>
<th>类名</th>
<th>实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>AbstractSet&lt;E&gt;</td>
<td>Iterable&lt;E&gt;, Collection&lt;E&gt;, Set&lt;E&gt;</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="AbstractSet"><a href="#AbstractSet" class="headerlink" title="AbstractSet"></a>AbstractSet</h2><h3 id="Constructor-Summary"><a href="#Constructor-Summary" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="protected-AbstractSet"><a href="#protected-AbstractSet" class="headerlink" title="protected AbstractSet()"></a>protected AbstractSet()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;默认构造函数。采用protected修饰的原因是因为AbstractSet不直接用于集合的初始化操作，而是在使用真正可用的Set集合处理类时提供一些基础准备工作。所以这个方法不应该暴露到外界去，所以不能用public修饰。同样的原因，因为AbstractSet不涉及到单例模式的设计，所以也不会是private，这样其子类也没办法继承到父类的无参构造方法。所以综上考虑，protected是最理想的选择。</p>
<h3 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="public-boolean-equals-Object-o"><a href="#public-boolean-equals-Object-o" class="headerlink" title="public boolean equals(Object o)"></a>public boolean equals(Object o)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Set))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Collection c = (Collection) o;</span><br><span class="line">    <span class="keyword">if</span> (c.size() != size())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> containsAll(c);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassCastException unused)   &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException unused) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;判断两个Set集合是否相等。如果对象o就是Set集合自身，那么直接返回true。如果o的类型不是Set及其子类，那么直接返回false。之后判断两个Set集合存储的元素数量是否相等以及存储的每个元素是否相等。</p>
<h4 id="public-int-hashCode"><a href="#public-int-hashCode" class="headerlink" title="public int hashCode()"></a>public int hashCode()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">    Iterator&lt;E&gt; i = iterator();</span><br><span class="line">    <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">        E obj = i.next();</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="keyword">null</span>)</span><br><span class="line">            h += obj.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回当前Set集合的散列值。Set集合的散列值的计算规则是对集合中存储的所有元素的散列值相加求和，如果存储了null元素，那么其散列值为0。</p>
<h4 id="public-boolean-removeAll-Collection-lt-gt-c"><a href="#public-boolean-removeAll-Collection-lt-gt-c" class="headerlink" title="public boolean removeAll(Collection&lt;?&gt; c)"></a>public boolean removeAll(Collection&lt;?&gt; c)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size() &gt; c.size()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;?&gt; i = c.iterator(); i.hasNext(); )</span><br><span class="line">            modified |= remove(i.next());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;?&gt; i = iterator(); i.hasNext(); ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c.contains(i.next())) &#123;</span><br><span class="line">                i.remove();</span><br><span class="line">                modified = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;移除Set集合中存储的所有集合c中的元素。</p>
<p>&emsp;</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li>NIL</li>
</ol>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>NIL</li>
</ol>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Collection 03 - ArrayList</title>
    <url>/2018/java-Collection-ArrayList.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;关于<em> <strong>java.util.ArrayList&lt;E&gt;</strong> </em>的部分笔记，ArrayList是一个数组实现的可变长度的集合类。由于其实现了RandomAccess接口，所以可以通过随机访问的方式以常量时间获取到集合内的每个元素。本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;ArrayList是一个可变长度的实现了List接口的、可以通过随机访问获取集合内元素的List集合实现。所有的操作和实现都建立在数组的基础之上，它实现了List接口声明的所有方法，且对要保存在ArrayList中的元素的类型没有任何限制，甚至可以存储null元素。ArrayList实现的size，isEmpty，get，set，iterator和listIterator的时间复杂度都是常量时间，add操作可以达到可摊还的常量时间（PS：在加入元素的过程中有可能出现因空间不足而需要执行扩容的操作），所以向集合内加入n个元素需要O(n)时间。除此之外的其他操作可以大致被视为线性时间复杂度。</p>
<p>&emsp;&emsp;每个ArrayList在初始化时都会初始化其集合容量大小。在每次加入新元素到集合中时，容量值就会自动增加。</p>
<p>&emsp;&emsp;ArrayList的实现思想类似于Vector，但是ArrayList是非线程安全的，而Vector则是线程安全的版本。如果需要在多线程环境中使用ArrayList，那么需要在使用ArrayList执行结构修改操作（结构修改包括加入或者删除一个/多个元素、显示修改底层数组的大小等）前完成多线程同步处理。一种推荐的处理方式是通过调用方法Collections.synchronizedList将ArrayList封装成一个用于多线程环境的集合实例。为了防止在未完成同步处理前就访问ArrayList，需要在初始化ArrayList就完成相关操作。具体可通过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList(...));</span><br></pre></td></tr></table></figure>
<p>完成初始化操作。还有一种思路是使用ArrayList的线程安全变本<strong>CopyOnWriteArrayList</strong> 。</p>
<p>&emsp;&emsp;ArrayList实现的iterator和listIterator是包含快速失败属性的。意味着如果当前ArrayList不是被某个特定的迭代器自身作出了结构修改，那么会直接抛出<strong>ConcurrentModificationException</strong>异常。</p>
<p>&emsp;</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ArrayList&lt;E&gt;</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.util.AbstractCollection&lt;E&gt;</span><br><span class="line">    --java.util.AbstractList&lt;E&gt;</span><br><span class="line">      --java.util.ArrayList&lt;E&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><div class="table-container">
<table>
<thead>
<tr>
<th>类名</th>
<th>实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>ArrayList&lt;E&gt;</td>
<td>Iterable&lt;E&gt;, Collection&lt;E&gt;, List&lt;E&gt;, RandomAccess, Serializable, Cloneable</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h3 id="Constructor-Summary"><a href="#Constructor-Summary" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="public-ArrayList-int-initialCapacity"><a href="#public-ArrayList-int-initialCapacity" class="headerlink" title="public ArrayList(int initialCapacity)"></a>public ArrayList(int initialCapacity)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;根据入参initialCapacity指定的长度初始化一个ArrayList空集合实例。</p>
<h4 id="public-ArrayList"><a href="#public-ArrayList" class="headerlink" title="public ArrayList()"></a>public ArrayList()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个ArrayList空集合实例，集合长度默认为0。</p>
<h4 id="public-ArrayList-Collection-lt-extends-E-gt-c"><a href="#public-ArrayList-Collection-lt-extends-E-gt-c" class="headerlink" title="public ArrayList(Collection&lt;? extends E&gt; c)"></a>public ArrayList(Collection&lt;? extends E&gt; c)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    size = elementData.length;</span><br><span class="line">    <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">    <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">        elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;根据集合c初始化一个集合实例，并将c中的内容复制到实例化后的集合实例中。初始化的实例集合中元素的位置和c一致。</p>
<p>&emsp;&emsp;<strong>size</strong>是ArrayList当前已经容纳的元素数，非ArrayList可以容纳的元素总数，ArrayList可以容纳的元素总数可以从elementData.length中得到。</p>
<h3 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="public-void-trimToSize"><a href="#public-void-trimToSize" class="headerlink" title="public void trimToSize()"></a>public void trimToSize()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">        elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;缩小ArrayList集合的容量。这是一个结构化操作，在操作之后会更新modCount的值以标记当前集合经历过结构化修改。方法调用后，list集合中的空闲位置全都会被释放回收掉，最后得到的集合会是一个装满元素、没有空闲空间的新集合实例。</p>
<h4 id="public-void-ensureCapacity-int-minCapacity"><a href="#public-void-ensureCapacity-int-minCapacity" class="headerlink" title="public void ensureCapacity(int minCapacity)"></a>public void ensureCapacity(int minCapacity)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minExpand = (elementData != EMPTY_ELEMENTDATA)</span><br><span class="line">        <span class="comment">// any size if real element table</span></span><br><span class="line">        ? <span class="number">0</span></span><br><span class="line">        <span class="comment">// larger than default for empty table. It's already supposed to be</span></span><br><span class="line">        <span class="comment">// at default size.</span></span><br><span class="line">        : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;检查当前集合是否有足够的空间容纳元素，且在空间不足的情况下执行扩容操作。这个方法被ArrayList内部没有调用，是一个暴露的方法API。在初始化ArrayList集合后，如果可以确定即将保存的元素数量，可以事先调用当前方法完成存储空间的分配，这样可以避免在加入元素的过程出现的空间再分配处理，从而提高了加入大量元素时的性能和效率。</p>
<p>&emsp;&emsp;第2 ~ 7行代码计算了一个不需要执行扩容的下界，如果当前集合已经存储了元素，那么不论minCapacity为多少，都会扩容list集合的空间大小。如果当前list集合是个空集合，那么只有在minCapacity超过了list集合的默认大小后才会执行扩容处理，否则认为当前默认空间大小可以满足元素存储要求而不会执行扩容操作。具体的扩容操作直接调用<strong>ensureExplicitCapacity(int minCapacity)</strong>方法完成。</p>
<h4 id="private-void-ensureCapacityInternal-int-minCapacity"><a href="#private-void-ensureCapacityInternal-int-minCapacity" class="headerlink" title="private void ensureCapacityInternal(int minCapacity)"></a>private void ensureCapacityInternal(int minCapacity)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE : MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;供ArrayList在加入元素时判断容量并执行扩容处理，方法被声明为私有方法，因此只会内部调用，不会对外暴露。第2 ~4行代码计算list实际需要的最小容量大小。之后调用<strong>ensureExplicitCapacity(int minCapacity)</strong>方法完成扩容操作。</p>
<p>&emsp;&emsp;因为扩容操作属于结构化修改，所以第10行代码更新了modCount的值标记ArrayList集合的更新。如果实际计算得到的最小容量大小大于当前底层存储数据的大小，那么就调用<strong>grow(int minCapacity)</strong>完成真正的扩容处理。</p>
<p>&emsp;&emsp;在执行扩容操作时，扩容标准是按照当前存储容量大小的<em> <strong>1.5</strong> </em>倍进行扩容（即第21行代码的计算过程）。如果1.5倍计算结果仍然小于minCapacity，那么直接按照minCapacity指定的大小进行扩容操纵。理论上扩容操作可以达到的最大容量为Integer.MAX_VALUE。MAX_ARRAY_SIZE的值为Integer.MAX_VALUE - 8，之所以这么做是因为一些特定的虚拟机会占用一些空间存储额外的信息，所以如果大于Integer.MAX_VALUE - 8的话可能会导致OutOfMemoryError的发生。</p>
<h4 id="public-int-size"><a href="#public-int-size" class="headerlink" title="public int size()"></a>public int size()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回当前ArrayList集合中存储的元素数量。如果当前集合中尚未存储任何元素（包括null），那么就返回true表示当前集合是个空集合。</p>
<h4 id="public-boolean-contains-Object-o"><a href="#public-boolean-contains-Object-o" class="headerlink" title="public boolean contains(Object o)"></a>public boolean contains(Object o)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;判断当前ArrayList集合中是否含有元素o。实际调用<strong>indexOf(Object o)</strong>完成判断。</p>
<h4 id="public-int-indexOf-Object-o"><a href="#public-int-indexOf-Object-o" class="headerlink" title="public int indexOf(Object o)"></a>public int indexOf(Object o)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回元素o在当前ArrayList集合中第一次出现的位置，位置值从0开始计数。如果当前集合中没有存储一个及以上元素o，那么返回-1。</p>
<h4 id="public-int-lastIndexOf-Object-o"><a href="#public-int-lastIndexOf-Object-o" class="headerlink" title="public int lastIndexOf(Object o)"></a>public int lastIndexOf(Object o)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回元素o在当前ArrayList集合中最后一次出现的位置，位置值以0结束。如果当前集合中没有存储一个及以上元素o，那么返回-1。</p>
<h4 id="public-Object-clone"><a href="#public-Object-clone" class="headerlink" title="public Object clone()"></a>public Object clone()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        ArrayList&lt;E&gt; v = (ArrayList&lt;E&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">        v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">        v.modCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">// this shouldn't happen, since we are Cloneable</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;克隆复制当前ArrayList集合自身并返回一份复制对象。执行的浅复制，通过Object类的native方法<strong>clone()</strong>完成具体的复制操作。</p>
<h4 id="public-Object-toArray"><a href="#public-Object-toArray" class="headerlink" title="public Object[] toArray()"></a>public Object[] toArray()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将当前ArrayList集合的数据元素以数组形式全部返回。复制得到的结果和当前ArrayList集合的结果集分别操作时互不影响。</p>
<h4 id="public-lt-T-gt-T-toArray-T-a"><a href="#public-lt-T-gt-T-toArray-T-a" class="headerlink" title="public &lt;T&gt; T[] toArray(T[] a)"></a>public &lt;T&gt; T[] toArray(T[] a)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">        <span class="comment">// Make a new array of a's runtime type, but my contents:</span></span><br><span class="line">        <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">    System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">        a[size] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将当前ArrayList集合的数据元素以数组形式全部保存到数组a中。如果a的长度不足以容纳集合的所有元素，那么就新分配一个空间，存储集合中所有元素并返回。如果a的长度大于集合中存储的元素总数，那么a数组中最后一个元素的下一个存储位置会被置为null，如果集合中没有存储任何null元素，那么这个操作执行完成后便可以非常方便的得到集合中存储的元素总数。</p>
<h4 id="E-elementData-int-index"><a href="#E-elementData-int-index" class="headerlink" title="E elementData(int index)"></a>E elementData(int index)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回下标index处的元素。</p>
<h4 id="public-E-get-int-index"><a href="#public-E-get-int-index" class="headerlink" title="public E get(int index)"></a>public E get(int index)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回ArrayList集合中index位置指定的数据元素。<strong>rangeCheck(int index)</strong>方法负责执行index是否到达集合尾部的边界检查。</p>
<h4 id="public-E-set-int-index-E-element"><a href="#public-E-set-int-index-E-element" class="headerlink" title="public E set(int index, E element)"></a>public E set(int index, E element)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将ArrayList集合中index位置指定的数据元素替换element，并返回替换之前index位置处的元素。</p>
<h4 id="private-void-rangeCheck-int-index"><a href="#private-void-rangeCheck-int-index" class="headerlink" title="private void rangeCheck(int index)"></a>private void rangeCheck(int index)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;边界检查。检查下标索引值index是否越过了集合尾部。</p>
<h4 id="public-boolean-add-E-e"><a href="#public-boolean-add-E-e" class="headerlink" title="public boolean add(E e)"></a>public boolean add(E e)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;向ArrayList集合中加入数据元素e。首先通过ensureCapacityInternal(int minCapacity)完成扩容检查。之后在集合尾部保存元素e，同时更新维护size的值。最后返回true表示加入操作执行成功。由于该方法改变了集合的长度，所以会修改modCount的长度标识集合被执行了结构化修改。</p>
<h4 id="public-void-add-int-index-E-element"><a href="#public-void-add-int-index-E-element" class="headerlink" title="public void add(int index, E element)"></a>public void add(int index, E element)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;向ArrayList集合中index指定的位置加入数据元素element。首先通过rangeCheckForAdd(int index)完成边界检查。接着通过ensureCapacityInternal(int minCapacity)完成扩容检查。由于该方法改变了集合的长度，所以会修改modCount的长度标识集合被执行了结构化修改。之后通过复制的方式将index位置及之后的元素向后移动释放index的存储空间，将element保存到index位置上。最后更新维护size的值。</p>
<h4 id="private-void-rangeCheckForAdd-int-index"><a href="#private-void-rangeCheckForAdd-int-index" class="headerlink" title="private void rangeCheckForAdd(int index)"></a>private void rangeCheckForAdd(int index)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">outOfBoundsMsg</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Index: "</span>+index+<span class="string">", Size: "</span>+size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;对index执行边界检查。这个方法会同时检查index与首边界和尾边界的大小关系，如果大小关系异常则向上抛出越界异常。</p>
<h4 id="public-E-remove-int-index"><a href="#public-E-remove-int-index" class="headerlink" title="public E remove(int index)"></a>public E remove(int index)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;移除ArrayList集合中index指定位置的元素，并返回被移除的元素。由于remove(int index)方法会修改ArrayList集合的数据容量，所以在方法执行过程中会修改modCount的值。由于index右侧的元素在方法执行过程中会统一向左移动，所以集合尾部最后一个位置的资源会被释放掉。</p>
<h4 id="public-boolean-remove-Object-o"><a href="#public-boolean-remove-Object-o" class="headerlink" title="public boolean remove(Object o)"></a>public boolean remove(Object o)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;移除元素o。如果ArrayList集合中含有元素o，那么在移除完成后返回true表示确实执行过移除操作，否则返回false表示当前ArrayList集合中不存在元素o。该方法只能移除集合中存储位置最靠前的元素，如果想要移除集合中存储的所有o，那么需要循环调用当前方法以完成操作。</p>
<p>&emsp;&emsp;remove方法的底层是通过调用<strong>fastRemove(int index)</strong>方法完成操作的。第20行代码计算当前index位置之后的元素数目，如果index不是指向最后一个位置的话，那么就将index位置之后的元素整体向前移动以覆盖index位置处存储的元素。由于fastRemove(int index)方法会导致size-1位置处的元素会左移一个空间位置，所以需要释放size-1位置处占用的资源。</p>
<h4 id="public-void-clear"><a href="#public-void-clear" class="headerlink" title="public void clear()"></a>public void clear()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;清空整个ArrayList集合中含有的元素。直接通过赋值为null的方式借助GC操作完成集合中元素占用资源的释放和回收。</p>
<h4 id="public-boolean-addAll-Collection-lt-extends-E-gt-c"><a href="#public-boolean-addAll-Collection-lt-extends-E-gt-c" class="headerlink" title="public boolean addAll(Collection&lt;? extends E&gt; c)"></a>public boolean addAll(Collection&lt;? extends E&gt; c)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将集合c中的元素全部加入到当前ArrayList集合中。第2 ~ 3行代码获取c中的元素数据和元素个数。第4行代码完成扩容操作（如果需要的话）。之后则将c中含有的数据复制到当前的ArrayList集合中，同时更新集合的size信息。最后返回实际的操作结果，true表示确实执行了插入操作，false表示c为空集合，没有需要加入的元素。</p>
<h4 id="public-boolean-addAll-int-index-Collection-lt-extends-E-gt-c"><a href="#public-boolean-addAll-int-index-Collection-lt-extends-E-gt-c" class="headerlink" title="public boolean addAll(int index, Collection&lt;? extends E&gt; c)"></a>public boolean addAll(int index, Collection&lt;? extends E&gt; c)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + numNew, numMoved);</span><br><span class="line"></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将集合c中的元素全部加入到当前ArrayList集合中自index起的位置上。第2行代码对index指定的范围做了边界校验。第4 ~ 5行代码获取c中的元素数据和元素个数。第5行代码完成扩容操作（如果需要的话）。</p>
<p>&emsp;&emsp;相关校验和扩容操作处理完成后，如果index指定的位置不在ArrayList集合的尾部，则需要通过数组复制的方式释放自index位置起，长度为集合c中元素总数的空间以此来容纳集合c中的所有元素。之后则将c中含有的数据复制到当前的ArrayList集合中，同时更新集合的size信息。最后返回实际的操作结果，true表示确实执行了插入操作，false表示c为空集合，没有需要加入的元素。</p>
<h4 id="protected-void-removeRange-int-fromIndex-int-toIndex"><a href="#protected-void-removeRange-int-fromIndex-int-toIndex" class="headerlink" title="protected void removeRange(int fromIndex, int toIndex)"></a>protected void removeRange(int fromIndex, int toIndex)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> numMoved = size - toIndex;</span><br><span class="line">        System.arraycopy(elementData, toIndex, elementData, fromIndex,</span><br><span class="line">                         numMoved);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear to let GC do its work</span></span><br><span class="line">        <span class="keyword">int</span> newSize = size - (toIndex-fromIndex);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = newSize; i &lt; size; i++) &#123;</span><br><span class="line">            elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size = newSize;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;移除ArrayList集合中自fromIndex位置起（包含fromIndex）到toIndex位置（不包括toIndex）的所有元素。由于removeRange(int fromIndex, int toIndex)属于结构化修改，所以操作过程中需要更新modCount的值。第3行代码需要计算出toIndex位置之后剩余的元素个数，第4 ~ 5行代码则将toIndex及之后的元素向左移动到了自fromIndex起始的位置上，这样就可以通过数据覆盖的方式将fromIndex和toIndex之间的元素清除掉。整个过程执行情况如图1所示：</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1545922468/BlogImages/java-collection/list/ArrayList-removeRange-example.png" alt></p>
<div align="center">
<div align="center">图 - 1</div>
&emsp;
</div>

<p>&emsp;&emsp;图1中toIndex及之后的元素会通过第4 ~ 5行代码的执行而移动到粉色区域。第8行代码的计算公式实际上可以拆分成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> newSize = size - toIndex + fromIndex;</span><br></pre></td></tr></table></figure>
<p>即</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> newSize = （size - toIndex）+ fromIndex;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;所以图1中红色花括号部分元素就是需要被释放空间的部分。也就是第9 ~ 11行代码执行的操作。操作流的最后会更新size的值。</p>
<h4 id="public-boolean-removeAll-Collection-lt-gt-c"><a href="#public-boolean-removeAll-Collection-lt-gt-c" class="headerlink" title="public boolean removeAll(Collection&lt;?&gt; c)"></a>public boolean removeAll(Collection&lt;?&gt; c)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;移除ArrayList集合中含有的集合c中的元素。实际调用<strong>batchRemove(Collection&lt;?&gt; c, boolean complement)</strong>方法完成操作。</p>
<h4 id="public-boolean-retainAll-Collection-lt-gt-c"><a href="#public-boolean-retainAll-Collection-lt-gt-c" class="headerlink" title="public boolean retainAll(Collection&lt;?&gt; c)"></a>public boolean retainAll(Collection&lt;?&gt; c)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> batchRemove(c, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;保留同时存在于ArrayList集合和c集合中的元素，除此之外ArrayList集合中的其他元素都会被移除掉，该方法计算的实质等同于数学领域中的两个不同集合求交集运算。实际调用<strong>batchRemove(Collection&lt;?&gt; c, boolean complement)</strong>方法完成操作。</p>
<h4 id="private-boolean-batchRemove-Collection-lt-gt-c-boolean-complement"><a href="#private-boolean-batchRemove-Collection-lt-gt-c-boolean-complement" class="headerlink" title="private boolean batchRemove(Collection&lt;?&gt; c, boolean complement)"></a>private boolean batchRemove(Collection&lt;?&gt; c, boolean complement)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line">            <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line">                elementData[w++] = elementData[r];</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// Preserve behavioral compatibility with AbstractCollection,</span></span><br><span class="line">        <span class="comment">// even if c.contains() throws.</span></span><br><span class="line">        <span class="keyword">if</span> (r != size) &#123;</span><br><span class="line">            System.arraycopy(elementData, r,</span><br><span class="line">                             elementData, w,</span><br><span class="line">                             size - r);</span><br><span class="line">            w += size - r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (w != size) &#123;</span><br><span class="line">            <span class="comment">// clear to let GC do its work</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)</span><br><span class="line">                elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">            modCount += size - w;</span><br><span class="line">            size = w;</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;批量移除或保留同时存在于ArrayList集合和c中的元素。参数complement指明了操作类型，如果值为true，那么就保留同时存在于ArrayList集合和c中的元素，反之则执行删除操作。具体执行流程如图2所示：</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1543507625/BlogImages/java-collection/list/ArrayList-batchRemove-examples2.png" alt></p>
<div align="center">
<div align="center">图 - 2</div>
&emsp;
</div>

<p>&emsp;&emsp;第5 ~ 8行代码执行的是图2中(1)的操作，当前ArrayList集合中的每个元素都会检查是否存在c中，如果complement的值为true，那么数组alpha中<strong>matched ele</strong>部分存储的是同时存在于ArrayList集合和c集合中的元素，而这些元素是需要保留下来的，中间的灰色区域的元素是已经比较过的元素，这部分元素存在于ArrayList集合但不存在c集合中，最后的<strong>unchecked elements</strong>的元素则是尚未比较的元素。如果complement的值为false，那么alpha中<strong>matched ele</strong>部分存储的则是存在于ArrayList集合中但是c集合中不含有的元素。</p>
<p>&emsp;&emsp;如果在5 ~ 8行代码执行过程出现了异常，则会出现图2中(2)的场景。数组bravo中<strong>matched ele</strong>部分存储的是满足条件的元素，中间的灰色区域的元素是已经比较过的元素，最后的<strong>unchecked element</strong>的元素则是尚未比较的元素。第12 ~ 15行代码则将r位置及之后的元素左移到自w起始位置的空间中，同时更新w的值，即图2中(3)的场景。在数组chalie中，左侧<strong>matched ele</strong>部分和中间的粉色部分构成了需要保留的元素集合，而右侧的<strong>to be null</strong>部分则是需要移除的元素用来释放占用空间。</p>
<p>&emsp;&emsp;如果第5 ~ 8行代码成功执行完毕，那么就会出现图2中(4)的场景。此时数组delta中左侧的<strong>matched ele</strong>部分存储的满足条件需要被保留下来的元素集合，右侧的<strong>to be null</strong>部分则是需要移除的元素。</p>
<p>&emsp;&emsp;不管是场景(3)还是(4)，第18 ~ 25行代码都会将右侧的<strong>to be null</strong>部分的元素释放掉。同时更新modCount和size的值。</p>
<p>&emsp;&emsp;如果w = size，那么则会出现图2中场景(5)的情况。此时集合c和ArrayList集合拥有数量一致且内容相同的元素，那么ArrayList集合则不会做出任何修改。</p>
<h4 id="private-void-writeObject-java-io-ObjectOutputStream-s"><a href="#private-void-writeObject-java-io-ObjectOutputStream-s" class="headerlink" title="private void writeObject(java.io.ObjectOutputStream s)"></a>private void writeObject(java.io.ObjectOutputStream s)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;</p>
<h4 id="private-void-readObject-java-io-ObjectInputStream-s"><a href="#private-void-readObject-java-io-ObjectInputStream-s" class="headerlink" title="private void readObject(java.io.ObjectInputStream s)"></a>private void readObject(java.io.ObjectInputStream s)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in capacity</span></span><br><span class="line">    s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;</p>
<h4 id="public-ListIterator-lt-E-gt-listIterator-int-index"><a href="#public-ListIterator-lt-E-gt-listIterator-int-index" class="headerlink" title="public ListIterator&lt;E&gt; listIterator(int index)"></a>public ListIterator&lt;E&gt; listIterator(int index)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回一个可以从index位置开始遍历的迭代器。index指定了可以通过next()方法返回的第一个元素。该迭代器可以向前遍历，提供的previous()方法会返回index - 1位置的元素。如果未指定index，那么默认从0开始遍历。ListItr的相关实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">extends</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    ListItr(<span class="keyword">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        cursor = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">int</span> i = cursor - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        cursor = i;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ArrayList.<span class="keyword">this</span>.set(lastRet, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = cursor;</span><br><span class="line">            ArrayList.<span class="keyword">this</span>.add(i, e);</span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;</p>
<h4 id="public-Iterator-lt-E-gt-iterator"><a href="#public-Iterator-lt-E-gt-iterator" class="headerlink" title="public Iterator&lt;E&gt; iterator()"></a>public Iterator&lt;E&gt; iterator()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回一个基于整个ArrayList集合进行遍历的一个迭代器。Itr的相关代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">            cursor = lastRet;</span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;</p>
<h4 id="public-List-lt-E-gt-subList-int-fromIndex-int-toIndex"><a href="#public-List-lt-E-gt-subList-int-fromIndex-int-toIndex" class="headerlink" title="public List&lt;E&gt; subList(int fromIndex, int toIndex)"></a>public List&lt;E&gt; subList(int fromIndex, int toIndex)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SubList(<span class="keyword">this</span>, <span class="number">0</span>, fromIndex, toIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">subListRangeCheck</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"fromIndex = "</span> + fromIndex);</span><br><span class="line">    <span class="keyword">if</span> (toIndex &gt; size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"toIndex = "</span> + toIndex);</span><br><span class="line">    <span class="keyword">if</span> (fromIndex &gt; toIndex)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"fromIndex("</span> + fromIndex +</span><br><span class="line">                                           <span class="string">") &gt; toIndex("</span> + toIndex + <span class="string">")"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回ArrayList集合中自fromIndex起（包含fromIndex），到toIndex（不包含toIndex）之间的子集合。ArrayList中提供的方法均可适用于subList中。同ArrayList一样，subList也是通过随机访问的方式来获取元素的。SubList的相关实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SubList</span> <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">RandomAccess</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AbstractList&lt;E&gt; parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parentOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    SubList(AbstractList&lt;E&gt; parent,</span><br><span class="line">            <span class="keyword">int</span> offset, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex) &#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        <span class="keyword">this</span>.parentOffset = fromIndex;</span><br><span class="line">        <span class="keyword">this</span>.offset = offset + fromIndex;</span><br><span class="line">        <span class="keyword">this</span>.size = toIndex - fromIndex;</span><br><span class="line">        <span class="keyword">this</span>.modCount = ArrayList.<span class="keyword">this</span>.modCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        checkForComodification();</span><br><span class="line">        E oldValue = ArrayList.<span class="keyword">this</span>.elementData(offset + index);</span><br><span class="line">        ArrayList.<span class="keyword">this</span>.elementData[offset + index] = e;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">return</span> ArrayList.<span class="keyword">this</span>.elementData(offset + index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">        checkForComodification();</span><br><span class="line">        parent.add(parentOffset + index, e);</span><br><span class="line">        <span class="keyword">this</span>.modCount = parent.modCount;</span><br><span class="line">        <span class="keyword">this</span>.size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        checkForComodification();</span><br><span class="line">        E result = parent.remove(parentOffset + index);</span><br><span class="line">        <span class="keyword">this</span>.modCount = parent.modCount;</span><br><span class="line">        <span class="keyword">this</span>.size--;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        parent.removeRange(parentOffset + fromIndex,</span><br><span class="line">                           parentOffset + toIndex);</span><br><span class="line">        <span class="keyword">this</span>.modCount = parent.modCount;</span><br><span class="line">        <span class="keyword">this</span>.size -= toIndex - fromIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addAll(<span class="keyword">this</span>.size, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">        <span class="keyword">int</span> cSize = c.size();</span><br><span class="line">        <span class="keyword">if</span> (cSize==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        checkForComodification();</span><br><span class="line">        parent.addAll(parentOffset + index, c);</span><br><span class="line">        <span class="keyword">this</span>.modCount = parent.modCount;</span><br><span class="line">        <span class="keyword">this</span>.size += cSize;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> listIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="keyword">this</span>.offset;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListIterator&lt;E&gt;() &#123;</span><br><span class="line">            <span class="keyword">int</span> cursor = index;</span><br><span class="line">            <span class="keyword">int</span> lastRet = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> expectedModCount = ArrayList.<span class="keyword">this</span>.modCount;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> cursor != SubList.<span class="keyword">this</span>.size;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                checkForComodification();</span><br><span class="line">                <span class="keyword">int</span> i = cursor;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= SubList.<span class="keyword">this</span>.size)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">                Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">                <span class="keyword">if</span> (offset + i &gt;= elementData.length)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                cursor = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> (E) elementData[offset + (lastRet = i)];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> cursor != <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                checkForComodification();</span><br><span class="line">                <span class="keyword">int</span> i = cursor - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">                Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">                <span class="keyword">if</span> (offset + i &gt;= elementData.length)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                cursor = i;</span><br><span class="line">                <span class="keyword">return</span> (E) elementData[offset + (lastRet = i)];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> cursor;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> cursor - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">                checkForComodification();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    SubList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">                    cursor = lastRet;</span><br><span class="line">                    lastRet = -<span class="number">1</span>;</span><br><span class="line">                    expectedModCount = ArrayList.<span class="keyword">this</span>.modCount;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">                checkForComodification();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ArrayList.<span class="keyword">this</span>.set(offset + lastRet, e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">                checkForComodification();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = cursor;</span><br><span class="line">                    SubList.<span class="keyword">this</span>.add(i, e);</span><br><span class="line">                    cursor = i + <span class="number">1</span>;</span><br><span class="line">                    lastRet = -<span class="number">1</span>;</span><br><span class="line">                    expectedModCount = ArrayList.<span class="keyword">this</span>.modCount;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (expectedModCount != ArrayList.<span class="keyword">this</span>.modCount)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">        subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SubList(<span class="keyword">this</span>, offset, fromIndex, toIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="keyword">this</span>.size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="keyword">this</span>.size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">outOfBoundsMsg</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Index: "</span>+index+<span class="string">", Size: "</span>+<span class="keyword">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ArrayList.<span class="keyword">this</span>.modCount != <span class="keyword">this</span>.modCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;</p>
<p>&emsp;</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li><p><strong>ArrayList中Object[]elementData为什么被transient修饰，transient的意义是什么?</strong></p>
<p>&emsp;&emsp;由于ArrayList实现了<strong>java.io.Serializable</strong>接口，所以ArrayList中的所有属性和方法 都可以通过序列化进行存储和传输操作，elementData也不例外。而transient的作用是保证被修饰的属性不会被执行序列化操作。也就是说，被transient修饰的属性的生命周期仅存在于其父对象从初始化到被GC回收的这段时间内，不会随着父对象被序列化操作持久保存。</p>
<p>&emsp;&emsp;那么，作为ArrayList中最重要的一个属性成员，为什么要阻止elementData被序列化呢？这是因为ArrayList没有对存储在内的元素限制其类型，换言之，一个ArrayList集合可以存储数量不限的null元素，如果将null元素也序列化的话，不仅没有意义，而且也会增加存储和传输的压力，所以为了避免这种情况，ArrayList重写了writeObject和readObject方法来专门对elementData执行序列化操作。所以，尽管elementData被修饰了transient，但还是可以随着ArrayList整体一起被序列化的，只是对序列化过程做了定制化处理而已。</p>
<p>&emsp;&emsp;<strong>综上，关于transient的总结如下</strong>：</p>
<ol>
<li>transient只能修饰变量，不能修饰方法和类；</li>
<li>被transient修饰的变量不会被序列化，通过被反序列化得到的对象中无法访问被transient修饰的内容。transient 修饰的变量会被设为初始值，如 int 型的是 0，对象型的是 null 。</li>
</ol>
</li>
<li><p><strong>toArray() T 和E的区别</strong></p>
<p>&emsp;&emsp;在进行类名声明时，ArrayList被声明为：<strong>public class ArrayList&lt;E&gt;</strong>，这意味着ArrayList内部的所有操作方法的对象类型都将会是<strong>E</strong>类型。但是我们希望可以通过toArray将ArrayList中的元素转换成更一般类型的元素，换言之，我们希望toArray()返回的元素类型会是E的父类型。所以如果将方法声明为E的话，这一点是无法做到的。</p>
<p>&emsp;&emsp;此外，这个方法不会有关于类型方面的编译异常。我们刚提到了toArray方法的返回类型需要时E的父类型，但是在Java语言体系中，没有关于父子类型校验的语法规则。在<a href="https://stackoverflow.com/questions/12355941/why-collection-toarrayt-doesnt-take-an-e-instead" target="_blank" rel="noopener">Why Collection.toArray(T[]) doesn’t take an E[] instead</a>问题的讨论中，提及了如下的声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">super</span> E&gt; T[] toArray(T[] a)</span><br></pre></td></tr></table></figure>
<p>但这种语法规则Java不支持，所以没有办法将异常通知提前到编译阶段。所以若toArray返回类型不是E的父类型，那么在运行期间会返回一个<strong>java.lang.ArrayStoreException</strong>异常。可参考如下demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestObj</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Long id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TestObj</span><span class="params">(Long id, String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"TestObj [id="</span> + id + <span class="string">", name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestObj1</span> <span class="keyword">extends</span> <span class="title">TestObj</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TestObj1</span><span class="params">(Long id, String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(id, name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Long id1;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Long <span class="title">getId1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId1</span><span class="params">(Long id1)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id1 = id1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;TestObj&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(testObj);</span><br><span class="line">list.add(testObj2);</span><br><span class="line"></span><br><span class="line">TestObj[] obj2 = <span class="keyword">new</span> TestObj[list.size()];</span><br><span class="line">list.toArray(obj2);</span><br><span class="line"></span><br><span class="line">TestObj1[] objs = <span class="keyword">new</span> TestObj1[list.size()];</span><br><span class="line">list.toArray(objs);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在运行过程中，第39行代码可以正常运行，而第41行代码会抛出ArrayStoreException异常。</p>
</li>
<li><p><strong>关于public ArrayList(Collection&lt;? extends E&gt; c) 中S“see 6260652”的延伸</strong></p>
<p>&emsp;&emsp;这是一个JDK的bug问题，详情可浏览<a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6260652" target="_blank" rel="noopener">(coll) Arrays.asList(x).toArray().getClass() should be Object[].class</a>。问题的大概描述是  collection.toArray()返回的结果的类型应该是java.lang.Object，但是在Arrays.asList中，实际上返回的并不是java.lang.Object，而是java.util.Arrays$ArrayList。所以如果传入的是Arrays.asList得到的c集合，那么其类型并不是java.lang.Object。所在在ArrayList(Collection&lt;? extends E&gt; c)中加入了类型的判断，如果c的类型不是java.lang.Object，那么就以java.lang.Object为基础重新构建一个elementData数组。这个问题已经在JDK9中得到了修复。</p>
</li>
<li><p><strong>modCount的存在意义</strong></p>
<p>&emsp;&emsp;modCount从字面意义上理解为修改次数。因为ArrayList是一个非线程安全的数据结构。除此之外，Arraylist中的listIterator(int index)、listIterator()、iterator()方法如果重复调用的话会生成多个迭代器，而每个迭代器都可以对ArrayList进行元素增删操作。所以modCount可以用来判断ArrayList的最近一次元素增删操作是否是由自身（ArrayList实例或者迭代器）执行的。如果不是由自身完成的，那么就会抛出异常。</p>
<p>&emsp;&emsp;通过迭代器的next、remove、previous方法遍历集合元素时，首先会检查自身维护的expectedModCount和ArrayList中的modCount值是否一致。如果一致，那么认为ArrayList最近的一次结构化修改是否自身完成的，可以继续执行后续操作。</p>
</li>
<li><p><strong>为什么选择1.5倍进行扩容</strong></p>
<p>&emsp;&emsp;在ArrayList的扩容机制里，ArrayList是按照当前容量的1.5倍进行扩容的。扩容大小的选择决定了实际应用中性能的好坏：如果单次扩容太大，会导致更明显的内存空间浪费，相反，如果扩容幅度变小，那么需要更多的次数来执行扩容，这会导致重新分配内存空间的操作变得更加频繁，从而导致性能受到影响。</p>
<p>&emsp;&emsp;鉴于此，Java设计人员需要在保证集合空间满足实际需求的情况下同时尽可能的减少内存重分配的次数。至于为什么最后决定采用1.5倍扩容，可能他们经过各种分析论证和性能测试之后认为1.5倍是最能满足要求的结果了。根据找到的一些资料表明如果扩容倍数在1.5倍时，内存浪费最多为33%，而2.5 被最多会浪费 60%，3.5 倍则会浪费 71…所以，1.5倍可能是最合适的结果。</p>
</li>
<li><p><strong>ArrayList实现writeObject和readObject的意义</strong></p>
<p>&emsp;&emsp;在(1)中提到了被transient关键字修饰的elementData是无法被序列化的，所以ArrayList自己实现了writeObject和readObject方法用来对elementData执行序列化和反序列操作。那么在执行序列化的过程中就会使用ArrayList自己实现的writeObject和readObject方法来完成序列化和反序列操作的。ArrayList通过writeObject把elementData里的元素写入到输出流ObjectOutputStream )中，通过readObject从输入流（ObjectInputStream ）读取到被序列化的数据并反序列化之后存储到elementData。</p>
<p>&emsp;&emsp;但是，writeObject和readObject方法都被声明为私有方法，且在ArrayList内部没有任何地方调用了该方法。实际上，这两个方法是通过反射的方式出现在了ObjectOutputStream和ObjectInputStream的方法writeObject()和readObject()调用栈中。</p>
</li>
<li><p><strong>length、length()和size()的区别</strong></p>
<p>&emsp;&emsp;length属性常出现在数组中，表示给一个数组分配的空间大小；length()常出现在字符串中，表示一个字符串的长度，某些情况下空格也会被计算在内；size()常出现在集合中，表示集合中存储的元素个数。</p>
</li>
</ol>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>James Gosling等. The Java Language Specification 7th Edtion[M]. Boston:Addison-Wesley.</li>
<li>Oracle Java Bug Database. <a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6260652" target="_blank" rel="noopener">(coll) Arrays.asList(x).toArray().getClass() should be Object[].class</a> [E]</li>
<li>Stack Overflow. <a href="https://stackoverflow.com/questions/910374/why-does-java-have-transient-fields" target="_blank" rel="noopener">Why does Java have transient fields?</a> [E]</li>
<li>程序媛想事儿(Alexia). <a href="http://www.cnblogs.com/lanxuezaipiao/p/3369962.html" target="_blank" rel="noopener">Java transient关键字使用小记</a> [E]</li>
<li>Stack Overflow. [<a href="https://stackoverflow.com/questions/3336291/logic-used-in-ensurecapacity-method-in-arraylist" target="_blank" rel="noopener">Logic used in ensureCapacity method in ArrayList</a> [E]</li>
<li>chenssy. <a href="http://wiki.jikexueyuan.com/project/java-enhancement/java-twentyone.html" target="_blank" rel="noopener">ArrayList</a> [E]</li>
<li>Aleksey Shipilëv. <a href="https://shipilev.net/blog/2016/arrays-wisdom-ancients/" target="_blank" rel="noopener">Arrays of Wisdom of the Ancients</a> [E]</li>
<li>小米干饭. <a href="https://www.cnblogs.com/xiaomiganfan/p/5362732.html" target="_blank" rel="noopener">为什么 Java ArrayList.toArray(T[]) 方法的参数类型是 T 而不是 E ?</a> [E]</li>
<li>Stack Overflow. <a href="https://stackoverflow.com/questions/12355941/why-collection-toarrayt-doesnt-take-an-e-instead" target="_blank" rel="noopener">Why Collection.toArray(T[]) doesn’t take an E[] instead</a> [E]</li>
<li>Stack Overflow. <a href="https://stackoverflow.com/questions/15422161/java-list-t-t-toarrayt-a-implementation" target="_blank" rel="noopener">Java List  T[] toArray(T[] a) implementation</a> [E]</li>
<li>Stack Overflow. <a href="https://stackoverflow.com/questions/13106567/why-t-for-toarray-hides-e-of-collectione" target="_blank" rel="noopener">Why  for toArray hides  of Collection?</a> [E]</li>
<li>像一只狗. <a href="https://juejin.im/post/5ab548f75188257ddb0f8fa2#heading-25" target="_blank" rel="noopener">搞懂 Java ArrayList 源码</a> [E]</li>
<li>魏福成. <a href="https://blog.csdn.net/u012926924/article/details/50452411" target="_blank" rel="noopener">modCount到底是干什么的呢</a> [E]</li>
<li>Hollis. <a href="https://www.hollischuang.com/archives/1140" target="_blank" rel="noopener">深入分析Java的序列化与反序列化</a> [E]</li>
</ol>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Map 07 - ConcurrentHashMap</title>
    <url>/2018/java-Collection-ConcurrentHashMap.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;关于<em> <strong>java.util.concurrent.ConcurrentHashMap&lt;K, V&gt;</strong> </em>的部分笔记，ConcurrentHashMap支持多个线程同一时刻访问集合内部的不同元素的特性，是HashMap的另一个线程安全版本（另一个是Hashtable）。本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;ConcurrentHashMap是一个支持并发访问的map集合，和Hashtable一样，都是HashMap的线程安全版本。但是和Hashtable不一样的是，ConcurrentHashMap可以允许多个线程在同一时刻对map集合中的多个键值对进行操作，而Hashtable则因为当前线程会锁定整个集合导致同一时刻只能有一个线程可以访问Hashtable集合。</p>
<p>&emsp;&emsp;ConcurrentHashMap的实现思想是将整个map集合拆分成了多个子集合，每个子集合由一个<a href> Segment</a>实例进行维护。线程访问时会对某个特定的segment实例进行锁定，其他的segment实例继续保持自由状态，这样就实现了多个线程同时访问ConcurrentHashMap集合中不同元素的特性。但是需要注意的是，如果多个线程访问的是同一个segment实例内部的键值对实例，那么由于同一时刻只有一个线程会保存对该segment实例的锁定，所以依旧会出现线程等待的现象。</p>
<p>&emsp;&emsp;每个segment实例内部是一个HashEntry数组，数组的每个节点维护了一个链表集合，该集合存储和维护了键值对映射实体。</p>
<p>&emsp;&emsp;ConcurrentHashMap的底层存储结构如图1所示：</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1545100740/BlogImages/java-collection/map/ConcurrentHashMap-demo-example.png" alt></p>
<div align="center">
<div align="center">图 - 1</div>
&emsp;
</div>

<p>&emsp;</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ConcurrentHashMap&lt;E&gt;</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.util.AbstractMap&lt;K,V&gt;</span><br><span class="line">    --java.util.concurrent.ConcurrentHashMap&lt;K,V&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><div class="table-container">
<table>
<thead>
<tr>
<th>类名</th>
<th>实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>ConcurrentHashMap&lt;E&gt;</td>
<td>Serializable, ConcurrentMap<k,v>,Map&lt;K,V&gt;</k,v></td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="Constructor-Summary"><a href="#Constructor-Summary" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="public-ConcurrentHashMap-int-initialCapacity-float-loadFactor-int-concurrencyLevel"><a href="#public-ConcurrentHashMap-int-initialCapacity-float-loadFactor-int-concurrencyLevel" class="headerlink" title="public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)"></a>public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">    <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">    <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;</span><br><span class="line">        ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">    <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">    <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">    <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">        cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// create segments and segments[0]</span></span><br><span class="line">    Segment&lt;K,V&gt; s0 =</span><br><span class="line">        <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</span><br><span class="line">                         (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">    <span class="keyword">this</span>.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个空ConcurrentHashMap集合，集合的初始容量和加载因子由initialCapacity和loadFactor确认，当前map集合可以支持的操作线程数上限由concurrencyLevel确定。</p>
<p>&emsp;&emsp;第4 ~ 5行代码对传入的参数做基本校验。如果concurrencyLevel大于最大值(MAX_SEGMENTS = 1 &lt;&lt; 16)，那么就用最大值指定线程数。第9 ~ 14行代码计算大于concurrencyLevel的最小的2次幂结果，该结果会作为当前concurrencyLevel进行分组的依据，也就是说，最终map中会存在ssize个segment分组。</p>
<p>&emsp;&emsp;第17 ~ 18行代码会确认最终的map集合容量。第19行代码计算map集合中每个segment分组中容纳的键值对数量。第20 ~ 21行代码会确认最终的每个segment分组的键值对数量。第22 ~ 24行代码根据计算得到的c计算最终的segment容量。</p>
<p>&emsp;&emsp;第26 ~ 28行代码初始化一个segment实体，该实体以当前map集合中segment分组的第一个元素存在。第29行代码会完成当前map集合的segment数组的初始化操作，最后map集合初始化完成。</p>
<h4 id="public-ConcurrentHashMap-int-initialCapacity-float-loadFactor"><a href="#public-ConcurrentHashMap-int-initialCapacity-float-loadFactor" class="headerlink" title="public ConcurrentHashMap(int initialCapacity, float loadFactor)"></a>public ConcurrentHashMap(int initialCapacity, float loadFactor)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个空ConcurrentHashMap集合，集合的初始容量和加载因子由initialCapacity和loadFactor确认，当前map集合可以支持的操作线程数上限默认16个。底层调用<strong>ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)</strong>完成初始化操作。</p>
<h4 id="public-ConcurrentHashMap-int-initialCapacity"><a href="#public-ConcurrentHashMap-int-initialCapacity" class="headerlink" title="public ConcurrentHashMap(int initialCapacity)"></a>public ConcurrentHashMap(int initialCapacity)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个空ConcurrentHashMap集合，集合的初始容量和加载因子由initialCapacity确认，当前map集合可以支持的操作线程数上限默认16个，加载因子默认为0.75。底层调用<strong>ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)</strong>完成初始化操作。</p>
<h4 id="public-ConcurrentHashMap"><a href="#public-ConcurrentHashMap" class="headerlink" title="public ConcurrentHashMap()"></a>public ConcurrentHashMap()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个空ConcurrentHashMap集合，集合的初始容量默认为16，当前map集合可以支持的操作线程数上限默认16个，加载因子默认为0.75。底层调用<strong>ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)</strong>完成初始化操作。</p>
<h4 id="public-ConcurrentHashMap-Map-lt-extends-K-extends-V-gt-m"><a href="#public-ConcurrentHashMap-Map-lt-extends-K-extends-V-gt-m" class="headerlink" title="public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m)"></a>public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Math.max((<span class="keyword">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>,</span><br><span class="line">                  DEFAULT_INITIAL_CAPACITY),</span><br><span class="line">         DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个空ConcurrentHashMap集合，集合的初始容量由m集合存储的键值对数量和默认值的大小关系决定，当前map集合可以支持的操作线程数上限默认16个，加载因子默认为0.75。底层调用<strong>ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)</strong>完成初始化操作。最后通过调用方法<strong>putAll(Map&lt;? extends K, ? extends V&gt; m)</strong>将m集合中的键值对保存到初始化的集合中。</p>
<h3 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="public-boolean-isEmpty"><a href="#public-boolean-isEmpty" class="headerlink" title="public boolean isEmpty()"></a>public boolean isEmpty()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Sum per-segment modCounts to avoid mis-reporting when</span></span><br><span class="line"><span class="comment">     * elements are concurrently added and removed in one segment</span></span><br><span class="line"><span class="comment">     * while checking another, in which case the table was never</span></span><br><span class="line"><span class="comment">     * actually empty at any point. (The sum ensures accuracy up</span></span><br><span class="line"><span class="comment">     * through at least 1&lt;&lt;31 per-segment modifications before</span></span><br><span class="line"><span class="comment">     * recheck.)  Methods size() and containsValue() use similar</span></span><br><span class="line"><span class="comment">     * constructions for stability checks.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">        Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">        <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seg.count != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            sum += seg.modCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum != <span class="number">0L</span>) &#123; <span class="comment">// recheck unless no modifications</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">            Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">            <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (seg.count != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                sum -= seg.modCount;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum != <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;判断当前map集合是否为空。借鉴了double-check的思想，如果遇到一个不为空的segment实体，那么直接返回false。否则根据seg.modCount的和差结果判断在该方法执行过程中是否存在其他线程对当前map做了写入和删除操作，以便最终确认当时的map集合状态。</p>
<h4 id="static-final-Segment-segmentAt-Segment-ss-int-j"><a href="#static-final-Segment-segmentAt-Segment-ss-int-j" class="headerlink" title="static final  Segment segmentAt(Segment[] ss, int j)"></a>static final <k,v> Segment<k,v> segmentAt(Segment<k,v>[] ss, int j)</k,v></k,v></k,v></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Segment&lt;K,V&gt; <span class="title">segmentAt</span><span class="params">(Segment&lt;K,V&gt;[] ss, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> u = (j &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="keyword">return</span> ss == <span class="keyword">null</span> ? <span class="keyword">null</span> :</span><br><span class="line">    (Segment&lt;K,V&gt;) UNSAFE.getObjectVolatile(ss, u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;获取当前map集合中segment数组中下标 <strong>j</strong> 处的segment实体。</p>
<h4 id="public-int-size"><a href="#public-int-size" class="headerlink" title="public int size()"></a>public int size()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Try a few times to get accurate count. On failure due to</span></span><br><span class="line">    <span class="comment">// continuous async changes in table, resort to locking.</span></span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">    <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line">    <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn't retry</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">            &#125;</span><br><span class="line">            sum = <span class="number">0L</span>;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            overflow = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sum += seg.modCount;</span><br><span class="line">                    <span class="keyword">int</span> c = seg.count;</span><br><span class="line">                    <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                        overflow = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum == last)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            last = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                segmentAt(segments, j).unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;获取当前map集合存储的键值对数量。统计的思想是重复统计和判断：先在不对segment加锁的情况下连续两次计算求和，如果结果一致，那么返回计算结果。如果结果不一致，那么在对segment加锁的情况下再求和并返回统计结果。如果统计过程中对segment加了锁，那么需要在方法结束时释放锁。</p>
<h4 id="public-V-get-Object-key"><a href="#public-V-get-Object-key" class="headerlink" title="public V get(Object key)"></a>public V get(Object key)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">int</span> h = hash(key);</span><br><span class="line">    <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (tab = s.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">             (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从当前map集合中取出可以匹配key的键值对映射实体，如果没有找到对应的实体，返回null。</p>
<p>&emsp;&emsp;第4行代码获取当前key的hashcode值，并根据hashcode的高位计算出该key位于哪个segment集合中。如果可以找到对应的segment对象，那么再从根据key的hashcode计算在当前segment中下标并取得该下标位置的链表集合。根据key的hashcode调用equals方法判断是否存在对应的映射实体：如果存在就返回映射的value值，否则返回null。</p>
<h4 id="private-int-hash-Object-k"><a href="#private-int-hash-Object-k" class="headerlink" title="private int hash(Object k)"></a>private int hash(Object k)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">0</span> != h) &amp;&amp; (k <span class="keyword">instanceof</span> String)) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spread bits to regularize both segment and index locations,</span></span><br><span class="line">    <span class="comment">// using variant of single-word Wang/Jenkins hash.</span></span><br><span class="line">    h += (h &lt;&lt;  <span class="number">15</span>) ^ <span class="number">0xffffcd7d</span>;</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">10</span>);</span><br><span class="line">    h += (h &lt;&lt;   <span class="number">3</span>);</span><br><span class="line">    h ^= (h &gt;&gt;&gt;  <span class="number">6</span>);</span><br><span class="line">    h += (h &lt;&lt;   <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;计算hashcode值。对原生的hashcode值（默认实现得到的hashcode）做了扰动处理，保证任意一位的变化都能产生不同。</p>
<h4 id="public-boolean-containsKey-Object-key"><a href="#public-boolean-containsKey-Object-key" class="headerlink" title="public boolean containsKey(Object key)"></a>public boolean containsKey(Object key)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; <span class="comment">// same as get() except no need for volatile value read</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">int</span> h = hash(key);</span><br><span class="line">    <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (tab = s.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">             (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;判断当前map集合中是否存在匹配key的映射，如果存在返回true，否则返回false。</p>
<h4 id="public-boolean-containsValue-Object-value"><a href="#public-boolean-containsValue-Object-value" class="headerlink" title="public boolean containsValue(Object value)"></a>public boolean containsValue(Object value)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Same idea as size()</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">long</span> last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> hashSum = <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">                Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                <span class="keyword">if</span> (seg != <span class="keyword">null</span> &amp;&amp; (tab = seg.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; tab.length; i++) &#123;</span><br><span class="line">                        HashEntry&lt;K,V&gt; e;</span><br><span class="line">                        <span class="keyword">for</span> (e = entryAt(tab, i); e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            V v = e.value;</span><br><span class="line">                            <span class="keyword">if</span> (v != <span class="keyword">null</span> &amp;&amp; value.equals(v)) &#123;</span><br><span class="line">                                found = <span class="keyword">true</span>;</span><br><span class="line">                                <span class="keyword">break</span> outer;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    sum += seg.modCount;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (retries &gt; <span class="number">0</span> &amp;&amp; sum == last)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            last = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                segmentAt(segments, j).unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;判断当前map集合中是否存在可以匹配value的键值对实体。</p>
<h4 id="public-boolean-contains-Object-value"><a href="#public-boolean-contains-Object-value" class="headerlink" title="public boolean contains(Object value)"></a>public boolean contains(Object value)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> containsValue(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;判断当前map集合中是否存在可以匹配value的键值对实体。</p>
<h4 id="public-V-put-K-key-V-value"><a href="#public-V-put-K-key-V-value" class="headerlink" title="public V put(K key, V value)"></a>public V put(K key, V value)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将key=value加入到当前map集合中。</p>
<p>&emsp;&emsp;第6 ~ 7行代码计算key的hashcode并根据hashcode计算其在segment数组中的下标位置。如果该下标位置尚未存储一个segment实体，那么就调用<strong>ensureSegment(int k)</strong>初始化一个segment实体并加入到segment数组中，否则加入到对应的segment实体的内部数组结构中。</p>
<h4 id="private-Segment-lt-K-V-gt-ensureSegment-int-k"><a href="#private-Segment-lt-K-V-gt-ensureSegment-int-k" class="headerlink" title="private Segment&lt;K,V&gt; ensureSegment(int k)"></a>private Segment&lt;K,V&gt; ensureSegment(int k)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> Segment&lt;K,V&gt; <span class="title">ensureSegment</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">long</span> u = (k &lt;&lt; SSHIFT) + SBASE; <span class="comment">// raw offset</span></span><br><span class="line">    Segment&lt;K,V&gt; seg;</span><br><span class="line">    <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>]; <span class="comment">// use segment 0 as prototype</span></span><br><span class="line">        <span class="keyword">int</span> cap = proto.table.length;</span><br><span class="line">        <span class="keyword">float</span> lf = proto.loadFactor;</span><br><span class="line">        <span class="keyword">int</span> threshold = (<span class="keyword">int</span>)(cap * lf);</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap];</span><br><span class="line">        <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">            == <span class="keyword">null</span>) &#123; <span class="comment">// recheck</span></span><br><span class="line">            Segment&lt;K,V&gt; s = <span class="keyword">new</span> Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">            <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="keyword">null</span>, seg = s))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> seg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;创建并插入一个segment元素。</p>
<p>&emsp;&emsp;入参k是经过hash计算之后的结果，根据k计算出在当前map集合中对应的偏移量以及在该位置上的segment分组。如果分组为空，那么从segment数组的第一个segment元素里得到需要创建的segment分组的容量，加载因子和扩容阈值等信息。再次查询当前map集合，确认确实需要创建一个新的segment实体，然后通过new实例化一个segment实体，再次确认是否需要创建一个新的segment实体，如果需要，那么将当前新初始化的segment实体加入到当前map的segment数组中。最后返回创建的segment实体。</p>
<h4 id="public-void-putAll-Map-lt-extends-K-extends-V-gt-m"><a href="#public-void-putAll-Map-lt-extends-K-extends-V-gt-m" class="headerlink" title="public void putAll(Map&lt;? extends K, ? extends V&gt; m)"></a>public void putAll(Map&lt;? extends K, ? extends V&gt; m)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())</span><br><span class="line">        put(e.getKey(), e.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将m集合中的键值对映射加入到当前map集合中。遍历m集合的每个键值对实体，调用<strong>put(K key, V value)</strong>方法完成所有操作。</p>
<h4 id="public-V-remove-Object-key"><a href="#public-V-remove-Object-key" class="headerlink" title="public V remove(Object key)"></a>public V remove(Object key)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    Segment&lt;K,V&gt; s = segmentForHash(hash);</span><br><span class="line">    <span class="keyword">return</span> s == <span class="keyword">null</span> ? <span class="keyword">null</span> : s.remove(key, hash, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从当前map集合中删除可以匹配key的键值对映射。如果确实存在可以匹配key的键值对，那么就删除并返回被阐述的键值对实体，否则返回null。</p>
<h4 id="public-boolean-remove-Object-key-Object-value"><a href="#public-boolean-remove-Object-key-Object-value" class="headerlink" title="public boolean remove(Object key, Object value)"></a>public boolean remove(Object key, Object value)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="keyword">null</span> &amp;&amp; (s = segmentForHash(hash)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        s.remove(key, hash, value) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从当前map集合中删除可以匹配key和value的键值对映射。如果确实存在可以匹配的键值对，那么就删除并返回true，否则返回false。</p>
<h4 id="private-Segment-lt-K-V-gt-segmentForHash-int-h"><a href="#private-Segment-lt-K-V-gt-segmentForHash-int-h" class="headerlink" title="private Segment&lt;K,V&gt; segmentForHash(int h)"></a>private Segment&lt;K,V&gt; segmentForHash(int h)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> Segment&lt;K,V&gt; <span class="title">segmentForHash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="keyword">return</span> (Segment&lt;K,V&gt;) UNSAFE.getObjectVolatile(segments, u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;根据hash结果计算segment数组的下标并返回该下标位置处的segment对象实体，如果不存在就返回null。</p>
<h4 id="static-final-lt-K-V-gt-HashEntry-lt-K-V-gt-entryForHash-Segment-lt-K-V-gt-seg-int-h"><a href="#static-final-lt-K-V-gt-HashEntry-lt-K-V-gt-entryForHash-Segment-lt-K-V-gt-seg-int-h" class="headerlink" title="static final &lt;K,V&gt; HashEntry&lt;K,V&gt; entryForHash(Segment&lt;K,V&gt; seg, int h)"></a>static final &lt;K,V&gt; HashEntry&lt;K,V&gt; entryForHash(Segment&lt;K,V&gt; seg, int h)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">HashEntry&lt;K,V&gt; <span class="title">entryForHash</span><span class="params">(Segment&lt;K,V&gt; seg, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">return</span> (seg == <span class="keyword">null</span> || (tab = seg.table) == <span class="keyword">null</span>) ? <span class="keyword">null</span> :</span><br><span class="line">    (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">        (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;根据hash结果计算指定segment中的hashEntry数组下标并返回该下标位置处的键值对实体集合对象，如果不存在就返回null。</p>
<h4 id="public-boolean-replace-K-key-V-oldValue-V-newValue"><a href="#public-boolean-replace-K-key-V-oldValue-V-newValue" class="headerlink" title="public boolean replace(K key, V oldValue, V newValue)"></a>public boolean replace(K key, V oldValue, V newValue)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">if</span> (oldValue == <span class="keyword">null</span> || newValue == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Segment&lt;K,V&gt; s = segmentForHash(hash);</span><br><span class="line">    <span class="keyword">return</span> s != <span class="keyword">null</span> &amp;&amp; s.replace(key, hash, oldValue, newValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;用newValue替换键值对key=value实体的value值。如果oldValue和newValue都为空，那么抛出空指针异常。根据key计算hashcode值并找到该hashcode值所处的segment实体。如果成功更新了值就返回true，否则返回false。</p>
<h4 id="public-V-replace-K-key-V-value"><a href="#public-V-replace-K-key-V-value" class="headerlink" title="public V replace(K key, V value)"></a>public V replace(K key, V value)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">replace</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Segment&lt;K,V&gt; s = segmentForHash(hash);</span><br><span class="line">    <span class="keyword">return</span> s == <span class="keyword">null</span> ? <span class="keyword">null</span> : s.replace(key, hash, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;用value替换可以匹配key的键值对实体的value值。如果value为空，那么抛出空指针异常。根据key计算hashcode值并找到该hashcode值所处的segment实体。如果成功更新了值就更新之前的value。</p>
<h4 id="public-void-clear"><a href="#public-void-clear" class="headerlink" title="public void clear()"></a>public void clear()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">        Segment&lt;K,V&gt; s = segmentAt(segments, j);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">            s.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;清空当前map集合。</p>
<h4 id="public-Set-lt-K-gt-keySet"><a href="#public-Set-lt-K-gt-keySet" class="headerlink" title="public Set&lt;K&gt; keySet()"></a>public Set&lt;K&gt; keySet()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Set&lt;K&gt; ks = keySet;</span><br><span class="line">    <span class="keyword">return</span> (ks != <span class="keyword">null</span>) ? ks : (keySet = <span class="keyword">new</span> KeySet());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回一个当前map集合的key值的set集合。KeySet的实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ConcurrentHashMap.<span class="keyword">this</span>.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ConcurrentHashMap.<span class="keyword">this</span>.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ConcurrentHashMap.<span class="keyword">this</span>.containsKey(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ConcurrentHashMap.<span class="keyword">this</span>.remove(o) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ConcurrentHashMap.<span class="keyword">this</span>.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;依赖的迭代器KeyIterator的实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">K</span>&gt;, <span class="title">Enumeration</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">next</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> <span class="keyword">super</span>.nextEntry().key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">nextElement</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">super</span>.nextEntry().key; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="public-Collection-lt-V-gt-values"><a href="#public-Collection-lt-V-gt-values" class="headerlink" title="public Collection&lt;V&gt; values()"></a>public Collection&lt;V&gt; values()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Collection&lt;V&gt; vs = values;</span><br><span class="line">    <span class="keyword">return</span> (vs != <span class="keyword">null</span>) ? vs : (values = <span class="keyword">new</span> Values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回一个当前map集合的value值的collection集合。Values的实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Values</span> <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;V&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ValueIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ConcurrentHashMap.<span class="keyword">this</span>.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ConcurrentHashMap.<span class="keyword">this</span>.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ConcurrentHashMap.<span class="keyword">this</span>.containsValue(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ConcurrentHashMap.<span class="keyword">this</span>.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;依赖的迭代器ValueIterator实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">V</span>&gt;, <span class="title">Enumeration</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">next</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> <span class="keyword">super</span>.nextEntry().value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">nextElement</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">super</span>.nextEntry().value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="public-Set-lt-Map-Entry-lt-K-V-gt-gt-entrySet"><a href="#public-Set-lt-Map-Entry-lt-K-V-gt-gt-entrySet" class="headerlink" title="public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()"></a>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet;</span><br><span class="line">    <span class="keyword">return</span> (es != <span class="keyword">null</span>) ? es : (entrySet = <span class="keyword">new</span> EntrySet());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回一个当前map集合的键值对实体的set集合。EntrySet的实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EntryIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">        V v = ConcurrentHashMap.<span class="keyword">this</span>.get(e.getKey());</span><br><span class="line">        <span class="keyword">return</span> v != <span class="keyword">null</span> &amp;&amp; v.equals(e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">        <span class="keyword">return</span> ConcurrentHashMap.<span class="keyword">this</span>.remove(e.getKey(), e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ConcurrentHashMap.<span class="keyword">this</span>.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ConcurrentHashMap.<span class="keyword">this</span>.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ConcurrentHashMap.<span class="keyword">this</span>.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;依赖的EntryIterator实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; e = <span class="keyword">super</span>.nextEntry();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WriteThroughEntry(e.key, e.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="private-void-writeObject-java-io-ObjectOutputStream-s"><a href="#private-void-writeObject-java-io-ObjectOutputStream-s" class="headerlink" title="private void writeObject(java.io.ObjectOutputStream s)"></a>private void writeObject(java.io.ObjectOutputStream s)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// force all segments for serialization compatibility</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; segments.length; ++k)</span><br><span class="line">        ensureSegment(k);</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; segments.length; ++k) &#123;</span><br><span class="line">        Segment&lt;K,V&gt; seg = segmentAt(segments, k);</span><br><span class="line">        seg.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt;[] tab = seg.table;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                HashEntry&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">for</span> (e = entryAt(tab, i); e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                    s.writeObject(e.key);</span><br><span class="line">                    s.writeObject(e.value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            seg.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s.writeObject(<span class="keyword">null</span>);</span><br><span class="line">    s.writeObject(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;序列化ConcurrentHashMap时使用的自定义实现方法。</p>
<p>&emsp;&emsp;第2 ~ 3行代码负责检查当前ConcurrentHashMap的底层segment数组是否存在为空的位置，如果存在，那么就实例化一个空对象并存储到对应的下标位置上，避免在反序列化时因null引起的二义性和不确定性。</p>
<p>&emsp;&emsp;第8 ~ 23行代码依次遍历底层的segment数组，获的锁并将其内部的每个键值对按照先key后value的顺序写入到流中，最后释放占用的锁。</p>
<p>&emsp;&emsp;最后又向流里写入了两个null表示当前ConcurrentHashMap的流写入过程结束。</p>
<h4 id="private-void-readObject-java-io-ObjectInputStream-s"><a href="#private-void-readObject-java-io-ObjectInputStream-s" class="headerlink" title="private void readObject(java.io.ObjectInputStream s)"></a>private void readObject(java.io.ObjectInputStream s)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// Don't call defaultReadObject()</span></span><br><span class="line">    ObjectInputStream.GetField oisFields = s.readFields();</span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] oisSegments = (Segment&lt;K,V&gt;[])oisFields.get(<span class="string">"segments"</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> ssize = oisSegments.length;</span><br><span class="line">    <span class="keyword">if</span> (ssize &lt; <span class="number">1</span> || ssize &gt; MAX_SEGMENTS</span><br><span class="line">        || (ssize &amp; (ssize-<span class="number">1</span>)) != <span class="number">0</span> )  <span class="comment">// ssize not power of two</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> java.io.InvalidObjectException(<span class="string">"Bad number of segments:"</span></span><br><span class="line">                                                 + ssize);</span><br><span class="line">    <span class="keyword">int</span> sshift = <span class="number">0</span>, ssizeTmp = ssize;</span><br><span class="line">    <span class="keyword">while</span> (ssizeTmp &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        ++sshift;</span><br><span class="line">        ssizeTmp &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    UNSAFE.putIntVolatile(<span class="keyword">this</span>, SEGSHIFT_OFFSET, <span class="number">32</span> - sshift);</span><br><span class="line">    UNSAFE.putIntVolatile(<span class="keyword">this</span>, SEGMASK_OFFSET, ssize - <span class="number">1</span>);</span><br><span class="line">    UNSAFE.putObjectVolatile(<span class="keyword">this</span>, SEGMENTS_OFFSET, oisSegments);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set hashMask</span></span><br><span class="line">    UNSAFE.putIntVolatile(<span class="keyword">this</span>, HASHSEED_OFFSET, randomHashSeed(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-initialize segments to be minimally sized, and let grow.</span></span><br><span class="line">    <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; segments.length; ++k) &#123;</span><br><span class="line">        Segment&lt;K,V&gt; seg = segments[k];</span><br><span class="line">        <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">            seg.threshold = (<span class="keyword">int</span>)(cap * seg.loadFactor);</span><br><span class="line">            seg.table = (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[cap];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read the keys and values, and put the mappings in the table</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        K key = (K) s.readObject();</span><br><span class="line">        V value = (V) s.readObject();</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;反序列化ConcurrentHashMap时使用的自定义实现方法。</p>
<p>&emsp;&emsp;第5行代码从流中得到ConcurrentHashMap的所有被序列化了的字段内容，并在第6行代码执行完后得到segments的数据内容。第8 ~ 17行代码根据流计算ConcurrentHashMap中segment数组的长度，以及其他的参数值。第18 ~ 23行代码完成相关字段的赋值操作。</p>
<p>&emsp;&emsp;第27 ~ 34行会初始化一个segment数组，这个过程得到的是一个仅包含segment实例的数组，每个segment实例内部的hashEntry数组都是空的。第37 ~ 43行代码则将键值对映射存储到对应的segment实例的HashEntry数组内。</p>
<h2 id="HashIterator"><a href="#HashIterator" class="headerlink" title="HashIterator"></a>HashIterator</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nextSegmentIndex;</span><br><span class="line">    <span class="keyword">int</span> nextTableIndex;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] currentTable;</span><br><span class="line">    HashEntry&lt;K, V&gt; nextEntry;</span><br><span class="line">    HashEntry&lt;K, V&gt; lastReturned;</span><br><span class="line"></span><br><span class="line">    HashIterator() &#123;</span><br><span class="line">        nextSegmentIndex = segments.length - <span class="number">1</span>;</span><br><span class="line">        nextTableIndex = -<span class="number">1</span>;</span><br><span class="line">        advance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取遍历操作执行的第一个节点，顺序是按照从尾到首的顺序遍历的。</span></span><br><span class="line"><span class="comment">     * 循环遍历，如果nextTableIndex可以指示到某个segment实例中的hashEntry数组的某个位置，</span></span><br><span class="line"><span class="comment">     * 那么取得该位置的元素，如果元素不为空，跳出循环并结束方法，否则向前遍历hashEntry数组的前一个</span></span><br><span class="line"><span class="comment">     * 位置，直到找到一个不为null的元素。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">advance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nextTableIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((nextEntry = entryAt(currentTable, nextTableIndex--)) != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nextSegmentIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                Segment&lt;K,V&gt; seg = segmentAt(segments, nextSegmentIndex--);</span><br><span class="line">                <span class="keyword">if</span> (seg != <span class="keyword">null</span> &amp;&amp; (currentTable = seg.table) != <span class="keyword">null</span>)</span><br><span class="line">                    nextTableIndex = currentTable.length - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历执行。</span></span><br><span class="line"><span class="comment">     * 该方法通常情况是遍历某个segment实例中的HashEntry数组上某个下标位置的链表集合的，</span></span><br><span class="line"><span class="comment">     * 如果(nextEntry = e.next) == null那么认为当前下标位置的链表集合已经遍历完全需要遍历</span></span><br><span class="line"><span class="comment">     * 下一个下标位置上的链表集合，那么就调用advance()方法取得下个不为空的链表集合并继续遍历</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> HashEntry&lt;K,V&gt; <span class="title">nextEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; e = nextEntry;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        lastReturned = e; <span class="comment">// cannot assign until after null check</span></span><br><span class="line">        <span class="keyword">if</span> ((nextEntry = e.next) == <span class="keyword">null</span>)</span><br><span class="line">            advance();</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否可以继续遍历，true表示可以继续遍历，false表示已经遍历完全没有新的元素可供遍历</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextEntry != <span class="keyword">null</span>; &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否可以继续遍历，true表示可以继续遍历，false表示已经遍历完全没有新的元素可供遍历</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextEntry != <span class="keyword">null</span>; &#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除当前遍历的元素。</span></span><br><span class="line"><span class="comment">     * 直接调用ConcurrentHashMap的remove(Object key)方法根据key完成删除操作即可。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        ConcurrentHashMap.<span class="keyword">this</span>.remove(lastReturned.key);</span><br><span class="line">        lastReturned = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Segment实例内部用来遍历键值对实例的迭代器。</p>
<p>&emsp;</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li>NIL</li>
</ol>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>TopGun_Viper. <a href="https://www.jianshu.com/p/fadc5bc01e23" target="_blank" rel="noopener">juc系列-ConcurrentHashMap</a> [E]</li>
<li>AbeJeffrey. <a href="https://my.oschina.net/7001/blog/896587#h3_16" target="_blank" rel="noopener">ConcurrentHashMap实现原理和源码解读</a> [E]</li>
</ol>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java集合</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Map 03 - HashMap</title>
    <url>/2018/java-Collection-HashMap.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;关于<em> <strong>java.util.HashMap&lt;K, V&gt;</strong> </em>的部分笔记，HashMap是一个遍历顺序无序，不允许key重复的存储键值对映射的集合实现类。底层依赖了一个数组集合，数组中的每个元素维护了具有需要存储在相同下标位置的键值对实体链表结构。本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;HashMap是Map接口的实现类，提供了接口声明的所有方法的具体实现。HashMap允许存储key为null、value为null的元素。HashMap可以被视为等同于散列表（hash table），但是不同的是，散列表是线程安全的，主要方法都被synchronized关键字做了修饰，而HashMap是非线程安全的。Hashmap不保证元素遍历的顺序。</p>
<p>&emsp;&emsp;HashMap执行get()和put()操作时可以保证常量时间的性能开销，如果需要遍历map集合，时间开销与map数组容量和存储的键值对数量之和成比例。</p>
<p>&emsp;&emsp;HashMap中有两个参数会影响map的操作性能：initial capacity和load factor。initial capacity决定了map集合中桶（键值对实体数组）的大小，而load factor决定了当桶填充到什么程度时会执行数组扩容处理。如果执行了扩容操作，那么需要将当前map集合的键值对实体重新计算hashcode值并分配在扩容后数组中的位置。默认的加载因子是0.75，这个值保证了map的操作性能可以在时间和空间利用方面达到一个理想的平衡。</p>
<p>&emsp;&emsp;如果在向map集合中插入元素前可以估计出插入的元素数量，可以提前完成集合空间分配，避免在加入过程中频繁重新分配空间导致性能降低。</p>
<p>&emsp;&emsp;Hashmap是一个非线程安全的实现类。所以如果需要在多线程环境中使用hashmap，需要付诸额外的操作来保证多线程环境下的线程安全特性。一个常用的执行方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map m = Collections.synchronizedMap(<span class="keyword">new</span> HashMap(...));</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;HashMap同样支持快速失败检查，但是并不保证可以一定捕捉到快速失败检查。</p>
<p>&emsp;&emsp;HashMap底层数据结构如图1所示：</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1544683504/BlogImages/java-collection/map/Map-HashMap-underlying-data-structure-example.png" alt></p>
<div align="center">
<div align="center">图 - 1</div>
&emsp;
</div>

<p>&emsp;</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HashMap&lt;E&gt;</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.util.AbstractMap&lt;K,V&gt;</span><br><span class="line">    --java.util.HashMap&lt;K,V&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><div class="table-container">
<table>
<thead>
<tr>
<th>类名</th>
<th>实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>HashMap&lt;E&gt;</td>
<td>Serializable, Cloneable,Map&lt;K,V&gt;</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="Constructor-Summary"><a href="#Constructor-Summary" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="public-HashMap-int-initialCapacity-float-loadFactor"><a href="#public-HashMap-int-initialCapacity-float-loadFactor" class="headerlink" title="public HashMap(int initialCapacity, float loadFactor)"></a>public HashMap(int initialCapacity, float loadFactor)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个空HashMap集合，集合的初始容量和加载因子由initialCapacity和loadFactor确认。</p>
<p>&emsp;&emsp;第2 ~ 6行代码检查initialCapacity参数是否有效并确定最后的initialCapacity值，initialCapacity的最大值是MAXIMUM_CAPACITY（1&lt;&lt; 30或者$2^{30}$)。第7 ~ 9行代码则用来检查loadFactor的有效性。</p>
<p>&emsp;&emsp;最后会调用一个init()方法。该方法在HashMap中是个方法体为空的方法，主要是给子类调用的，可以让子类在集合创建后，插入元素前执行一些想要的操作。</p>
<h4 id="public-HashMap-int-initialCapacity"><a href="#public-HashMap-int-initialCapacity" class="headerlink" title="public HashMap(int initialCapacity)"></a>public HashMap(int initialCapacity)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个空HashMap集合，集合的初始容量由initialCapacity和确认，加载因子默认为0.75。调用构造器方法<strong>HashMap(int initialCapacity, float loadFactor)</strong>完成初始化操作。</p>
<h4 id="public-HashMap"><a href="#public-HashMap" class="headerlink" title="public HashMap()"></a>public HashMap()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个空HashMap集合，集合的初始容量默认为16，加载因子默认为0.75。调用构造器方法<strong>HashMap(int initialCapacity, float loadFactor)</strong>完成初始化操作。</p>
<h4 id="ublic-HashMap-Map-lt-extends-K-extends-V-gt-m"><a href="#ublic-HashMap-Map-lt-extends-K-extends-V-gt-m" class="headerlink" title="ublic HashMap(Map&lt;? extends K, ? extends V&gt; m)"></a>ublic HashMap(Map&lt;? extends K, ? extends V&gt; m)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Math.max((<span class="keyword">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>,</span><br><span class="line">                  DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);</span><br><span class="line">    inflateTable(threshold);</span><br><span class="line"></span><br><span class="line">    putAllForCreate(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个空HashMap集合，并将m中的键值对保存到初始化的map中。在初始化过程中，集合的容量大小由m存储的键值对数量决定，保证空map集合可以将m中的键值对全部存储下来，且默认加载因子是0.75。初始化完成后通过<strong>inflateTable(int toSize)</strong>方法完成map集合底层存储数据结构的初始化操作。最后通过调用方法<strong>putAllForCreate(Map&lt;? extends K, ? extends V&gt; m)</strong>将m集合中的键值对保存到初始化的集合中。</p>
<h3 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="void-init"><a href="#void-init" class="headerlink" title="void init()"></a>void init()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;空方法，留给子类发挥。</p>
<h4 id="private-void-inflateTable-int-toSize"><a href="#private-void-inflateTable-int-toSize" class="headerlink" title="private void inflateTable(int toSize)"></a>private void inflateTable(int toSize)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Find a power of 2 &gt;= toSize</span></span><br><span class="line">    <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</span><br><span class="line"></span><br><span class="line">    threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">    initHashSeedAsNeeded(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;完成map底层存储结构初始化。首先根据传入的toSize寻找一个大于等于toSize的最小2次幂结果。第5行代码确定最终的初始空间容量并在第6行代码中初始化一个存储空间结构 — Entry<k,v>[] table。最后根据容量初始化一个散列掩码（hashing mask value）以完成底层存储结构初始化过程。</k,v></p>
<h4 id="private-static-int-roundUpToPowerOf2-int-number"><a href="#private-static-int-roundUpToPowerOf2-int-number" class="headerlink" title="private static int roundUpToPowerOf2(int number)"></a>private static int roundUpToPowerOf2(int number)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">roundUpToPowerOf2</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert number &gt;= 0 : "number must be non-negative";</span></span><br><span class="line">    <span class="keyword">return</span> number &gt;= MAXIMUM_CAPACITY</span><br><span class="line">        ? MAXIMUM_CAPACITY</span><br><span class="line">        : (number &gt; <span class="number">1</span>) ? Integer.highestOneBit((number - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;计算求得一个大于等于number的最小2次幂结果。如果number比最大容量还大，那么就返回最大容量；如果number = 1，那么直接返回1，否则返回大于number的最小2次幂结果。在计算过程：</p>
<p>&emsp;&emsp;&emsp;&emsp;<script type="math/tex">Integer.highestOneBit((number - 1) << 1)</script> </p>
<p>中，number -1 是为了保证当number自身为2次幂时可以取到自身而不是大于自身的最小2次幂结果。因为方法实现的返回大于等于number的最小2次幂结果。所以number -1保证了这个条件，然后计算(number - 1) &lt;&lt; 1)过程，并通过Integer.highestOneBit()返回一个满足条件的数字。</p>
<h4 id="final-boolean-initHashSeedAsNeeded-int-capacity"><a href="#final-boolean-initHashSeedAsNeeded-int-capacity" class="headerlink" title="final boolean initHashSeedAsNeeded(int capacity)"></a>final boolean initHashSeedAsNeeded(int capacity)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">initHashSeedAsNeeded</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> currentAltHashing = hashSeed != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">        (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">    <span class="keyword">boolean</span> switching = currentAltHashing ^ useAltHashing;</span><br><span class="line">    <span class="keyword">if</span> (switching) &#123;</span><br><span class="line">        hashSeed = useAltHashing ? sun.misc.Hashing.randomHashSeed(<span class="keyword">this</span>) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> switching;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个散列掩码（hashing mask value）。只有在实际需要的时候才会初始化这个值，也就是延迟初始化。在初始化时hashSeed的默认值为0。在我们尚未给hashmap赋值时，sun.misc.VM.isBooted()得到的是true，<strong>ALTERNATIVE_HASHING_THRESHOLD</strong>的值为Integer.MAX_VALUE = 2147483647 [0x7fffffff]。所以useAltHashing的值为false。第5行代码执行得到false。</p>
<p>&emsp;&emsp;该方法用来计算一个hashSeed，hashSeed不为0的时候，对 String 类型的key 采用sun.misc.Hashing.stringHash32的 hash算法；对非 String 类型的 key，多一次和hashSeed的异或，这样可以一定程度上减少碰撞的概率。但是由于在产生hashSeed的过程中调用了Romdum.nextInt()方法，而该方法内部使用的AtomicLong，其操作类型是CAS(Compare And Swap)，所以多线程环境中性能无法满足要求，所以在JDK 7u40之后被移除，且在JDK 8中也不再使用该字段。</p>
<h4 id="private-void-putAllForCreate-Map-lt-extends-K-extends-V-gt-m"><a href="#private-void-putAllForCreate-Map-lt-extends-K-extends-V-gt-m" class="headerlink" title="private void putAllForCreate(Map&lt;? extends K, ? extends V&gt; m)"></a>private void putAllForCreate(Map&lt;? extends K, ? extends V&gt; m)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putAllForCreate</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())</span><br><span class="line">        putForCreate(e.getKey(), e.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将m集合中的键值对保存到当前map集合中。调用的是putForCreate(K key, V value)方法。</p>
<h4 id="private-void-putForCreate-K-key-V-value"><a href="#private-void-putForCreate-K-key-V-value" class="headerlink" title="private void putForCreate(K key, V value)"></a>private void putForCreate(K key, V value)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putForCreate</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = <span class="keyword">null</span> == key ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Look for preexisting entry for key.  This will never happen for</span></span><br><span class="line"><span class="comment">     * clone or deserialize.  It will only happen for construction if the</span></span><br><span class="line"><span class="comment">     * input Map is a sorted map whose ordering is inconsistent w/ equals.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将key-value键值对映射存储到当前map集合中。在构造器和伪构造器方法（clone，readObject）中替换put方法完成键值对插入操作。该方法不会对map集合做扩容处理，检查修改状态等。而且该方法调用createEntry，而不是addEntry完成操作。</p>
<p>&emsp;&emsp;第2行代码根据key完成hashCode值计算。之后根据indexFor()方法返回该hashcode在散列表中的下标位置。</p>
<p>&emsp;&emsp;第10 ~ 17行代码遍历当前map集合，如果当前map集合中存在和参数key相同的键值对映射，那么就替换键值对的valu值，否则调用<strong>createEntry(int hash, K key, V value, int bucketIndex)</strong>将键值对加入到当前map集合中。</p>
<h4 id="final-int-hash-Object-k"><a href="#final-int-hash-Object-k" class="headerlink" title="final int hash(Object k)"></a>final int hash(Object k)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;一种补充的计算hashcode的方法。计算得到的随机hashSeed，来降低冲突发生的几率，如果hashSeed不等于0，且key是String字符串，那么通过方法sun.misc.Hashing.stringHash32()完成hashcode计算。否则</p>
<p>&emsp;&emsp;这个方法的目的是对key的hashcode进行扰动计算，防止不同hashcode的高位不同但低位相同导致的hash冲突，尽量做到key的hashcode任何一位的变化都能对最终结果产生影响。</p>
<h4 id="static-int-indexFor-int-h-int-length"><a href="#static-int-indexFor-int-h-int-length" class="headerlink" title="static int indexFor(int h, int length)"></a>static int indexFor(int h, int length)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";</span></span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将hashcode转换成散列表中的下标。利用&amp;做取模运算得到hashcode在散列表中的下标。</p>
<h4 id="void-createEntry-int-hash-K-key-V-value-int-bucketIndex"><a href="#void-createEntry-int-hash-K-key-V-value-int-bucketIndex" class="headerlink" title="void createEntry(int hash, K key, V value, int bucketIndex)"></a>void createEntry(int hash, K key, V value, int bucketIndex)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;创建一个键值对映射。table[buckedIndex]维护的是一个Entry结构的链表，得到这个链表结构，同时第3行代码会在第bucketIndex位置上创建一个新的对象实体，该对象实体的next节点是当前Entry结构的首部元素节点，最后同步size值，该值维护了当前map集合中存储的键值对数量。操作示意图如图2所示：</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1544615810/BlogImages/java-collection/map/Map-HashMap-createEntry-example.png" alt></p>
<div align="center">
<div align="center">图 - 2</div>
&emsp;
</div>


<p>&emsp;&emsp;Alpha为createEntry方法执行前map集合的状态，Bravo为createEntry方法执行后的场景，如果根据key计算hashcode得到数组下标bucketIndex位置尚未存储元素，那么新创建的键值对实体会是该下标位置的第一个元素，如图2Bravo里的键值对“A11=123”。如果数组下标bucketIndex位置已经存储了元素，那么第2代码和第三行代码中的<strong>new Entry&lt;&gt;(hash, key, value, e)</strong>部分执行的是Bravo阶段中步骤（1）的结果，新创建了一个键值对实体“B11=12”，且将键值对“B11=12”的next节点指向了键值对实体”B12=123“。第3行代码执行完后，Bravo阶段中步骤（2）也就执行完成了，新创建的键值对实体“B11=12”成为下标位置N-3处的链表结构的首部节点。</p>
<h4 id="public-V-put-K-key-V-value"><a href="#public-V-put-K-key-V-value" class="headerlink" title="public V put(K key, V value)"></a>public V put(K key, V value)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将传入的key-value映射保存到当前map集合中。如果当前map集合中已经存在了key对应的键值对映射，那么原有映射的value值会被传入的value替换。</p>
<p>&emsp;&emsp;如果当前map集合为空，那么调用<strong>inflateTable(int toSize)</strong>方法完成map底层数组初始化操作。</p>
<p>&emsp;&emsp;如果key为null，那么调用<strong>putForNullKey(V value)</strong>加入一个key为null的键值对映射。</p>
<p>&emsp;&emsp;计算key的hashcode值和在底层数组中的下标位置。取得该下标位置的映射实体对象，如果对象为空，那么调用<strong>addEntry(int hash, K key, V value, int bucketIndex)</strong>完成键值对添加。否则执行第9 ~ 17行代码替换已存在键值对映射的value值并返回被替换的值。因为put操作属于结构化修改，所以更新modCount的值。</p>
<h4 id="private-V-putForNullKey-V-value"><a href="#private-V-putForNullKey-V-value" class="headerlink" title="private V putForNullKey(V value)"></a>private V putForNullKey(V value)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;向当前map集合中存储一个key为null的键值对映射。由于key为null时其hashcode为0，所以其在数组中的下标为0。所以取得下标为0的键值对实体，如果实体存在，直接替换下标为0的实体的value值，并返回被替换的值。否则调用<strong>addEntry(int hash, K key, V value, int bucketIndex)</strong>完成键值对添加。</p>
<h4 id="void-addEntry-int-hash-K-key-V-value-int-bucketIndex"><a href="#void-addEntry-int-hash-K-key-V-value-int-bucketIndex" class="headerlink" title="void addEntry(int hash, K key, V value, int bucketIndex)"></a>void addEntry(int hash, K key, V value, int bucketIndex)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;向当前map集合中加入一个键值对映射。</p>
<p>&emsp;&emsp;如果当前map存储的键值对数量达到了扩容阈值限制(capacity*load factor)，且计算得到的bucketIndex下标位置处已经被占用，那么首先执行扩容处理。扩容规则是按照当前容量的两倍进行扩容。扩容完成后重新计算key的hashcode值和在数组中的下标位置。</p>
<p>&emsp;&emsp;通过<strong>createEntry(int hash, K key, V value, int bucketIndex)</strong>完成键值对的创建和保存。</p>
<h4 id="public-void-putAll-Map-lt-extends-K-extends-V-gt-m"><a href="#public-void-putAll-Map-lt-extends-K-extends-V-gt-m" class="headerlink" title="public void putAll(Map&lt;? extends K, ? extends V&gt; m)"></a>public void putAll(Map&lt;? extends K, ? extends V&gt; m)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numKeysToBeAdded = m.size();</span><br><span class="line">    <span class="keyword">if</span> (numKeysToBeAdded == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable((<span class="keyword">int</span>) Math.max(numKeysToBeAdded * loadFactor, threshold));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Expand the map if the map if the number of mappings to be added</span></span><br><span class="line"><span class="comment">     * is greater than or equal to threshold.  This is conservative; the</span></span><br><span class="line"><span class="comment">     * obvious condition is (m.size() + size) &gt;= threshold, but this</span></span><br><span class="line"><span class="comment">     * condition could result in a map with twice the appropriate capacity,</span></span><br><span class="line"><span class="comment">     * if the keys to be added overlap with the keys already in this map.</span></span><br><span class="line"><span class="comment">     * By using the conservative calculation, we subject ourself</span></span><br><span class="line"><span class="comment">     * to at most one extra resize.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (numKeysToBeAdded &gt; threshold) &#123;</span><br><span class="line">        <span class="keyword">int</span> targetCapacity = (<span class="keyword">int</span>)(numKeysToBeAdded / loadFactor + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (targetCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            targetCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = table.length;</span><br><span class="line">        <span class="keyword">while</span> (newCapacity &lt; targetCapacity)</span><br><span class="line">            newCapacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity &gt; table.length)</span><br><span class="line">            resize(newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())</span><br><span class="line">        put(e.getKey(), e.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将集合m中的所有键值对映射都存储到当前map集合中。</p>
<p>&emsp;&emsp;如果m集合为空，那么不做任何处理直接返回。如果当前map集合为空，那么先完成初始化操作。如果存储m集合中的键值对需要的空间超过了当前map集合的扩容限制阈值threshold，那么第20行代码会计算存储m集合需要的空间大小，第21 ~ 22行代码计算最终确定的目标空间大小，第23 ~ 25行代码以当前map空间的两倍逐次扩容直至满足目标空间大小的要求。第26 ~ 27行代码如果需要的空间超过了当前map集合的数组物理空间大小，那么就执行扩容处理。</p>
<p>&emsp;&emsp;扩容完成后，遍历集合m，将m中的每个键值对映射加入到当前map集合中。</p>
<h4 id="void-resize-int-newCapacity"><a href="#void-resize-int-newCapacity" class="headerlink" title="void resize(int newCapacity)"></a>void resize(int newCapacity)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;扩容当前map集合。扩容之后重新计算集合中已有键值对映射的hashcode和下标值并完成键值对存储位置的更新。如果当前map集合的容量已经达到了最大容量限制（$2^{30}  $），那么不再扩容，并返回扩容限制阈值。</p>
<p>&emsp;&emsp;初始化一个新的数组，调用<strong>transfer(Entry[] newTable, boolean rehash)</strong>将当前map集合中的键值对都迁移到扩容后的新数组中，最后计算更新扩容限制阈值threshold。</p>
<h4 id="void-transfer-Entry-newTable-boolean-rehash"><a href="#void-transfer-Entry-newTable-boolean-rehash" class="headerlink" title="void transfer(Entry[] newTable, boolean rehash)"></a>void transfer(Entry[] newTable, boolean rehash)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将当前map集合中的键值对映射从旧数组迁移到新数组中。</p>
<p>&emsp;&emsp;遍历旧数组中的每个键值对实体，如果需要重新计算hashcode值，那么调用<strong>hash(Object k)</strong>重新计算hashcode值。之后重新计算每个键值对在新数组中的下标位置。第10行代码会将每个键值对的后继节点统一置为null，表示每个链表只会有一个元素。第11行代码将键值对实体存储到新数组中对应下标位置上。操作过程如图3所示：</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1544618617/BlogImages/java-collection/map/Map-HashMap-transfer-example.png" alt></p>
<div align="center">
<div align="center">图 - 3</div>
&emsp;
</div>


<p>&emsp;&emsp;遍历旧数组table的每个键值对映射实体，首先得到某个下标位置链表结构的首部节点和首部节点的后继节点，并决定是否需要重新计算hashcode值。之后根据hashcode和新数组容量计算出当前节点在新数组的下标位置，这里有两种情况需要考虑，一种是新数组的下标位置为空，尚未存储元素，另外一种是新数组的下标位置已经有键值对实体存储了。</p>
<p>&emsp;&emsp;如果是前一种情况，第10行代码执行后，在图3中是步骤（1）的情况，第11行代码执行后新数组下标位置的链表首部元素就是当前节点，即步骤（2）。之后将next指针指示的节点赋值给当前节点循环计算直至到达链表尾部。</p>
<p>&emsp;&emsp;如果是后一种情况，第10行代码执行过程中，首先经历步骤（4.1），该过程会将现有新数组下标位置的首部元素指针从数组上断开，继而经历步骤（4.2），将当前遍历节点的后继指针指向链表首部元素。第11行代码执行后会经历步骤（5），当前元素会被加入到新数组下标位置链表的首部。之后将next指针指向的元素赋值给当前遍历节点循环遍历直至链表遍历结束。</p>
<h4 id="public-V-remove-Object-key"><a href="#public-V-remove-Object-key" class="headerlink" title="public V remove(Object key)"></a>public V remove(Object key)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = removeEntryForKey(key);</span><br><span class="line">    <span class="keyword">return</span> (e == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;删除当前map集合中和入参key匹配的键值对映射，并返回被删除的value值。底层调用<strong>removeEntryForKey(Object key)</strong>方法完成操作。</p>
<h4 id="final-Entry-lt-K-V-gt-removeEntryForKey-Object-key"><a href="#final-Entry-lt-K-V-gt-removeEntryForKey-Object-key" class="headerlink" title="final Entry&lt;K,V&gt; removeEntryForKey(Object key)"></a>final Entry&lt;K,V&gt; removeEntryForKey(Object key)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">    Entry&lt;K,V&gt; e = prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">if</span> (prev == e)</span><br><span class="line">                table[i] = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                prev.next = next;</span><br><span class="line">            e.recordRemoval(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = e;</span><br><span class="line">        e = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;删除当前map集合中和入参key匹配的键值对映射，并返回被删除的键值对实体。如果当前map集合为空，那么直接返回null。</p>
<p>&emsp;&emsp;根据key计算出key对应的hashcode和在数组中的下标值。实际流程如图4所示：</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1544624282/BlogImages/java-collection/map/Map-HashMap-removeEntryForKey-example.png" alt></p>
<div align="center">
<div align="center">图 - 4</div>
&emsp;
</div>


<p>&emsp;&emsp;第5 ~ 9行代码计算当前入参key的hashcode值以及根据hashcode值计算匹配key的键值对在数组中的下标位置。取得该下标处链表结构的首部节点，开始遍历，找到hashcode值一致且key相等节点。如果该节点正好是链表的第一个节点，那么执行第17 ~ 18行代码后图3中键值对实体“B12=123”会被移除链表并返回。如果该节点是链表中的某个节点，那么执行第17 ~ 18行代码后图3中键值对实体“B13=123”会被移除链表并返回。</p>
<p>&emsp;&emsp;如果没有找到匹配的key，那么返回null。</p>
<h4 id="final-Entry-lt-K-V-gt-removeMapping-Object-o"><a href="#final-Entry-lt-K-V-gt-removeMapping-Object-o" class="headerlink" title="final Entry&lt;K,V&gt; removeMapping(Object o)"></a>final Entry&lt;K,V&gt; removeMapping(Object o)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeMapping</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span> || !(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o;</span><br><span class="line">    Object key = entry.getKey();</span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">    Entry&lt;K,V&gt; e = prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; e.equals(entry)) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">if</span> (prev == e)</span><br><span class="line">                table[i] = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                prev.next = next;</span><br><span class="line">            e.recordRemoval(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = e;</span><br><span class="line">        e = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从当前集合中删除实体o（o被期望为一个键值对实体对象）。第5行代码将对象o转成了一个键值对实体，并计算出该键值对key的hashcode值以及其在当前map集合中的下标位置，然后根据下标找到该下标位置处的链表结构，找到与o的key匹配的键值对实体（比较整个entry实体的hashcode值），并删除。最后返回被删除的键值对实体对象。</p>
<h4 id="public-void-clear"><a href="#public-void-clear" class="headerlink" title="public void clear()"></a>public void clear()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    Arrays.fill(table, <span class="keyword">null</span>);</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;清空整个数组实现清空map集合的功能。</p>
<h4 id="public-V-get-Object-key"><a href="#public-V-get-Object-key" class="headerlink" title="public V get(Object key)"></a>public V get(Object key)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;获取map集合中key对应的value值，如果没有对应映射，那么返回null。如果key为null，那么调用<strong>getForNullKey()</strong>方法得到null对应的键值对映射的value信息。否则调用<strong>getEntry(Object key)</strong>完成查找。最后返回结果给方法调用方。</p>
<h4 id="private-V-getForNullKey"><a href="#private-V-getForNullKey" class="headerlink" title="private V getForNullKey()"></a>private V getForNullKey()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">getForNullKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;map集合中key为null的元素只有一个，且其hashcode为0，所以在散列表中的下标为0。所以第5 ~ 8行代码会直接取下标为0的元素实体，并返回。</p>
<h4 id="public-boolean-containsKey-Object-key"><a href="#public-boolean-containsKey-Object-key" class="headerlink" title="public boolean containsKey(Object key)"></a>public boolean containsKey(Object key)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getEntry(key) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;判断当前map集合中是否含有key对应的键值对映射，如果有，那么返回true。否则返回false。</p>
<h4 id="public-boolean-containsValue-Object-value"><a href="#public-boolean-containsValue-Object-value" class="headerlink" title="public boolean containsValue(Object value)"></a>public boolean containsValue(Object value)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> containsNullValue();</span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length ; i++)</span><br><span class="line">        <span class="keyword">for</span> (Entry e = tab[i] ; e != <span class="keyword">null</span> ; e = e.next)</span><br><span class="line">            <span class="keyword">if</span> (value.equals(e.value))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;判断当前map集合中是否含有入参value匹配的键值对实体。如果有返回true，否则返回false。</p>
<p>&emsp;&emsp;如果value为null，那么调用<strong>containsNullValue()</strong>方法完成操作并返回结果。否则第6 ~ 10行代码中外层遍历底层数组中的每个位置的链表集合，里层遍历每个链表集合中的每个键值对实体，检查是否有匹配value的键值对实体对象，如果有返回true，否则返回false。</p>
<h4 id="private-boolean-containsNullValue"><a href="#private-boolean-containsNullValue" class="headerlink" title="private boolean containsNullValue()"></a>private boolean containsNullValue()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">containsNullValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length ; i++)</span><br><span class="line">        <span class="keyword">for</span> (Entry e = tab[i] ; e != <span class="keyword">null</span> ; e = e.next)</span><br><span class="line">            <span class="keyword">if</span> (e.value == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;判断当前map集合中是否含有value为null的键值对实体。如果有返回true，否则返回false。</p>
<p>&emsp;&emsp;第3 ~ 6行代码中外层遍历底层数组中的每个位置的链表集合，里层遍历每个链表集合中的每个键值对实体，检查是否有value为null的键值对实体对象，如果有返回true，否则返回false。</p>
<h4 id="final-Entry-lt-K-V-gt-getEntry-Object-key"><a href="#final-Entry-lt-K-V-gt-getEntry-Object-key" class="headerlink" title="final Entry&lt;K,V&gt; getEntry(Object key)"></a>final Entry&lt;K,V&gt; getEntry(Object key)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回key对应的键值对映射对象实体。如果当前map集合为空，那么直接返回null。调用<strong>hash(Object k)</strong>计算key的hashcode。第7行代码根据计算得到的hashcode值得到底层数组中对应下标位置处的链表集合，取出存储的value值并返回。</p>
<h4 id="public-int-size"><a href="#public-int-size" class="headerlink" title="public int size()"></a>public int size()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回当前map集合中存储的键值对数量。</p>
<h4 id="public-boolean-isEmpty"><a href="#public-boolean-isEmpty" class="headerlink" title="public boolean isEmpty()"></a>public boolean isEmpty()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;判断当前map集合是否为空。</p>
<h4 id="public-Object-clone"><a href="#public-Object-clone" class="headerlink" title="public Object clone()"></a>public Object clone()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HashMap&lt;K,V&gt; result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = (HashMap&lt;K,V&gt;)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">// assert false;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result.table != EMPTY_TABLE) &#123;</span><br><span class="line">        result.inflateTable(Math.min(</span><br><span class="line">            (<span class="keyword">int</span>) Math.min(</span><br><span class="line">                size * Math.min(<span class="number">1</span> / loadFactor, <span class="number">4.0f</span>),</span><br><span class="line">                <span class="comment">// we have limits...</span></span><br><span class="line">                HashMap.MAXIMUM_CAPACITY),</span><br><span class="line">            table.length));</span><br><span class="line">    &#125;</span><br><span class="line">    result.entrySet = <span class="keyword">null</span>;</span><br><span class="line">    result.modCount = <span class="number">0</span>;</span><br><span class="line">    result.size = <span class="number">0</span>;</span><br><span class="line">    result.init();</span><br><span class="line">    result.putAllForCreate(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;克隆复制一个当前map集合副本并返回。该副本是当前map集合的浅度复制对象。</p>
<h4 id="Iterator-lt-K-gt-newKeyIterator"><a href="#Iterator-lt-K-gt-newKeyIterator" class="headerlink" title="Iterator&lt;K&gt; newKeyIterator()"></a>Iterator&lt;K&gt; newKeyIterator()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Iterator&lt;K&gt; <span class="title">newKeyIterator</span><span class="params">()</span>   </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextEntry().getKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回一个基于当前map集合的key的迭代器。</p>
<h4 id="Iterator-lt-V-gt-newValueIterator"><a href="#Iterator-lt-V-gt-newValueIterator" class="headerlink" title="Iterator&lt;V&gt; newValueIterator()"></a>Iterator&lt;V&gt; newValueIterator()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Iterator&lt;V&gt; <span class="title">newValueIterator</span><span class="params">()</span>   </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ValueIterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextEntry().value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回一个基于当前map集合的value的迭代器。</p>
<h4 id="Iterator-lt-Map-Entry-lt-K-V-gt-gt-newEntryIterator"><a href="#Iterator-lt-Map-Entry-lt-K-V-gt-gt-newEntryIterator" class="headerlink" title="Iterator&lt;Map.Entry&lt;K,V&gt;&gt; newEntryIterator()"></a>Iterator&lt;Map.Entry&lt;K,V&gt;&gt; newEntryIterator()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;K,V&gt;&gt; newEntryIterator()   &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EntryIterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextEntry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回一个基于当前map集合的键值对的迭代器。</p>
<h4 id="public-Set-lt-K-gt-keySet"><a href="#public-Set-lt-K-gt-keySet" class="headerlink" title="public Set&lt;K&gt; keySet()"></a>public Set&lt;K&gt; keySet()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Set&lt;K&gt; ks = keySet;</span><br><span class="line">    <span class="keyword">return</span> (ks != <span class="keyword">null</span> ? ks : (keySet = <span class="keyword">new</span> KeySet()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回当前map集合包含的所有key的一个Set形式集合。对这个集合做的修改会同步出现在当前map集合中，反之亦然。KeySet的实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> newKeyIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> containsKey(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HashMap.<span class="keyword">this</span>.removeEntryForKey(o) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashMap.<span class="keyword">this</span>.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="public-Collection-lt-V-gt-values"><a href="#public-Collection-lt-V-gt-values" class="headerlink" title="public Collection&lt;V&gt; values()"></a>public Collection&lt;V&gt; values()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Collection&lt;V&gt; vs = values;</span><br><span class="line">    <span class="keyword">return</span> (vs != <span class="keyword">null</span> ? vs : (values = <span class="keyword">new</span> Values()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回当前map集合中包含的所有value的一个Collection形式集合。对这个集合做的修改会同步出现在当前map集合中，反之亦然。Values的实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Values</span> <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;V&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> newValueIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> containsValue(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashMap.<span class="keyword">this</span>.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="public-Set-lt-Map-Entry-lt-K-V-gt-gt-entrySet"><a href="#public-Set-lt-Map-Entry-lt-K-V-gt-gt-entrySet" class="headerlink" title="public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()"></a>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">    <span class="keyword">return</span> entrySet0();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet0() &#123;</span><br><span class="line">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet;</span><br><span class="line">    <span class="keyword">return</span> es != <span class="keyword">null</span> ? es : (entrySet = <span class="keyword">new</span> EntrySet());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回当前map集合中包含的所有键值对实体的Set表示形式。对这个集合做的修改会同步出现在当前map集合中，反之亦然。EntrySet的实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> newEntryIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry&lt;K,V&gt; e = (Map.Entry&lt;K,V&gt;) o;</span><br><span class="line">        Entry&lt;K,V&gt; candidate = getEntry(e.getKey());</span><br><span class="line">        <span class="keyword">return</span> candidate != <span class="keyword">null</span> &amp;&amp; candidate.equals(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> removeMapping(o) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashMap.<span class="keyword">this</span>.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="private-void-writeObject-java-io-ObjectOutputStream-s"><a href="#private-void-writeObject-java-io-ObjectOutputStream-s" class="headerlink" title="private void writeObject(java.io.ObjectOutputStream s)"></a>private void writeObject(java.io.ObjectOutputStream s)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Write out the threshold, loadfactor, and any hidden stuff</span></span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out number of buckets</span></span><br><span class="line">    <span class="keyword">if</span> (table==EMPTY_TABLE) &#123;</span><br><span class="line">        s.writeInt(roundUpToPowerOf2(threshold));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s.writeInt(table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out size (number of Mappings)</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out keys and values (alternating)</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;K,V&gt; e : entrySet0()) &#123;</span><br><span class="line">            s.writeObject(e.getKey());</span><br><span class="line">            s.writeObject(e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;hashmap自定义序列化操作。</p>
<h4 id="private-void-readObject-java-io-ObjectInputStream-s"><a href="#private-void-readObject-java-io-ObjectInputStream-s" class="headerlink" title="private void readObject(java.io.ObjectInputStream s)"></a>private void readObject(java.io.ObjectInputStream s)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                         loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set other fields that need values</span></span><br><span class="line">    table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in number of buckets</span></span><br><span class="line">    s.readInt(); <span class="comment">// ignored.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read number of mappings</span></span><br><span class="line">    <span class="keyword">int</span> mappings = s.readInt();</span><br><span class="line">    <span class="keyword">if</span> (mappings &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Illegal mappings count: "</span> +</span><br><span class="line">                                         mappings);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// capacity chosen by number of mappings and desired load (if &gt;= 0.25)</span></span><br><span class="line">    <span class="keyword">int</span> capacity = (<span class="keyword">int</span>) Math.min(</span><br><span class="line">        mappings * Math.min(<span class="number">1</span> / loadFactor, <span class="number">4.0f</span>),</span><br><span class="line">        <span class="comment">// we have limits...</span></span><br><span class="line">        HashMap.MAXIMUM_CAPACITY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// allocate the bucket array;</span></span><br><span class="line">    <span class="keyword">if</span> (mappings &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        inflateTable(capacity);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        threshold = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init();  <span class="comment">// Give subclass a chance to do its thing.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">        K key = (K) s.readObject();</span><br><span class="line">        V value = (V) s.readObject();</span><br><span class="line">        putForCreate(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;hashmap自定义反序列操作。</p>
<h4 id="int-capacity"><a href="#int-capacity" class="headerlink" title="int  capacity()"></a>int  capacity()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>   <span class="title">capacity</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> table.length; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="float-loadFactor"><a href="#float-loadFactor" class="headerlink" title="float loadFactor()"></a>float loadFactor()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">loadFactor</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> loadFactor;   &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="Entry-lt-K-V-gt"><a href="#Entry-lt-K-V-gt" class="headerlink" title="Entry&lt;K,V&gt;"></a>Entry&lt;K,V&gt;</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="keyword">int</span> hash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates new entry.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry e = (Map.Entry)o;</span><br><span class="line">        Object k1 = getKey();</span><br><span class="line">        Object k2 = e.getKey();</span><br><span class="line">        <span class="keyword">if</span> (k1 == k2 || (k1 != <span class="keyword">null</span> &amp;&amp; k1.equals(k2))) &#123;</span><br><span class="line">            Object v1 = getValue();</span><br><span class="line">            Object v2 = e.getValue();</span><br><span class="line">            <span class="keyword">if</span> (v1 == v2 || (v1 != <span class="keyword">null</span> &amp;&amp; v1.equals(v2)))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getKey() + <span class="string">"="</span> + getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is invoked whenever the value in an entry is</span></span><br><span class="line"><span class="comment">     * overwritten by an invocation of put(k,v) for a key k that's already</span></span><br><span class="line"><span class="comment">     * in the HashMap.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is invoked whenever the entry is</span></span><br><span class="line"><span class="comment">     * removed from the table.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recordRemoval</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Entry<k,v>是HashMap集合的内部类，实现了Map.Entry&lt;K,V&gt;接口。实际上map集合内部的存储结构就是一个Entry<k,v>形式的数组，数组中的每个元素都是一个Entry<k,v>实体。</k,v></k,v></k,v></p>
<p>&emsp;&emsp;Entry<k,v>中包含了四个字段：value（map集合中键值对的值内容），key（map集合中键值对的键内容），next（当前entry节点的下一个节点）和hash（map集合中键值对的键的hashcode值）。</k,v></p>
<p>&emsp;&emsp;实体自身的hashcode计算方式是将当前实体的key的hashcode和value的hashcode求异或运算得到结果。</p>
<p>&emsp;&emsp;比较两个实体是否相等，首先判断两个实体的类型是否一致，其次分别判断两个实体的key和value是否都相等。</p>
<p>&emsp;</p>
<h2 id="HashIterator-lt-E-gt"><a href="#HashIterator-lt-E-gt" class="headerlink" title="HashIterator&lt;E&gt;"></a>HashIterator&lt;E&gt;</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; next;        <span class="comment">// next entry to return</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount;   <span class="comment">// For fast-fail</span></span><br><span class="line">    <span class="keyword">int</span> index;              <span class="comment">// current slot</span></span><br><span class="line">    Entry&lt;K,V&gt; current;     <span class="comment">// current entry</span></span><br><span class="line"></span><br><span class="line">    HashIterator() &#123;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">            Entry[] t = table;</span><br><span class="line">            <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>)</span><br><span class="line">                ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">nextEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        Entry&lt;K,V&gt; e = next;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((next = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Entry[] t = table;</span><br><span class="line">            <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>)</span><br><span class="line">                ;</span><br><span class="line">        &#125;</span><br><span class="line">        current = e;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (current == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        Object k = current.key;</span><br><span class="line">        current = <span class="keyword">null</span>;</span><br><span class="line">        HashMap.<span class="keyword">this</span>.removeEntryForKey(k);</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;HashIterator是基于当前map集合的键值对实体的一个迭代器实现。构造函数HashIterator()会定位到当前map集合中第一个不为null的键值对实体上。</p>
<p>&emsp;&emsp;根据next是否为null来判断是否可以继续向后遍历。</p>
<p>&emsp;&emsp;在nextEntry()方法中，执行逻辑如图5所示：</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1544669150/BlogImages/java-collection/map/Map-HashMap-HashIterator-nextEntry-example.png" alt></p>
<div align="center">
<div align="center">图 - 5</div>
&emsp;
</div>

<p>&emsp;&emsp;在完成HashIterator初始化完成之后，next指针会指向当前数组中第一个非空的键值对实体对象。如果当前指向处理的键值对实体的后继节点为空，那么就继续向后遍历数组，直到找到下一个非空的键值对实体链表结构并将next指针指向该链表的首部节点。得到当前处理的键值对实体对象节点并返回该对象。</p>
<p>&emsp;&emsp;借助remove()方法完成删除当前节点的操作。取得当前键值对实体对象中的key值信息，调用HashMap的removeEntryForKey()方法将该节点删除，同时更新expectedModCount。</p>
<p>&emsp;</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li><p><strong>为什么要把数组的Size设置为2的N次方</strong></p>
<ol>
<li>indexFor利用&amp;做取模运算计算散列表下标值，a &amp; b中要求b的二进制位全部由1构成，所以需要散列表长度为$ 2^n $ 。此外，利用位操作实现取模运算比算术取模运算效率非常好，所以这么做可以提高运行效率；</li>
<li>不同的hash值发生碰撞的概率相对来说比较小，可以让键值对实体在数组中均匀分布；</li>
</ol>
</li>
<li><p><strong>加载因子对map集合查找效率的影响</strong></p>
<ol>
<li>加载因子越大，填满的数组元素越多，分配的内存空间空闲小，链表长度增加，查找效率变低；</li>
<li>加载因子越小，填满的数组元素越少，分配的内存空间空闲多，链表长度减少，查找效率变高；</li>
</ol>
<p>因为在addEntry()方法中，由两个因素决定是否需要进行扩容操作：(size &gt;= threshold) 和 (null != table[bucketIndex])。即使(null != table[bucketIndex])条件满足了，由于扩容限制阈值太大导致前一个条件size &gt;= threshold一直无法满足，因此无法执行扩容操作，只能在链表首部不停的追加元素，导致链表长度变大。</p>
</li>
</ol>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>ChiuCheng. <a href="https://segmentfault.com/a/1190000015798586" target="_blank" rel="noopener">深入理解HashMap(二): 关键源码逐行分析之hash算法</a> [E]</li>
<li>csfreebird. <a href="https://blog.csdn.net/csfreebird/article/details/7355282" target="_blank" rel="noopener">Java HashMap 分析之三:放入元素</a> [E]</li>
<li>Yikun. <a href="http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">Java HashMap工作原理及实现</a> [E]</li>
<li>ImportNew. <a href="http://www.importnew.com/7099.html" target="_blank" rel="noopener">HashMap的工作原理</a> [E]</li>
<li>Liujiacai. <a href="https://liujiacai.net/blog/2015/09/03/java-hashmap/" target="_blank" rel="noopener">Java HashMap 源码解析</a> [E]</li>
<li>Stack Overflow. <a href="https://stackoverflow.com/questions/9335169/understanding-strange-java-hash-function" target="_blank" rel="noopener">Understanding strange Java hash function</a> [E]</li>
<li>Stack Overflow. <a href="https://stackoverflow.com/questions/14453163/can-anybody-explain-how-java-design-hashmaps-hash-function" target="_blank" rel="noopener">Can anybody explain how java design HashMap’s hash() function?</a> [E]</li>
<li>Hollis. <a href="https://www.hollischuang.com/archives/2091" target="_blank" rel="noopener">全网把Map中的hash()分析的最透彻的文章，别无二家</a> [E]</li>
<li>Carson_Ho. <a href="https://juejin.im/post/5aa87415f265da23a4048041" target="_blank" rel="noopener">Java：这是一份详细&amp;全面的HashMap 1.7 源码分析</a> [E]</li>
<li>zhihu. <a href="https://www.zhihu.com/question/20733617" target="_blank" rel="noopener">JDK 源码中 HashMap 的 hash 方法原理是什么？</a> [E]</li>
<li>miaoLoveCode. <a href="https://www.jianshu.com/p/a11b9c1002f1" target="_blank" rel="noopener">Java中的HashMap</a> [E]</li>
</ol>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Map 04 - LinkedHashMap</title>
    <url>/2018/java-Collection-LinkedHashMap.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;关于<em> <strong>java.util.LinkedHashMap&lt;K, V&gt;</strong> </em>的部分笔记，LinkedHashMap是HashMap的扩展，底层依赖数组+双向链表的形式完成了元素的存储和查找，并且该实现返回的元素是有序的。本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;LinkedHashMap是一个可预先确定键值对遍历顺序的map集合实现。直接继承于HashMap，但是和HashMap不同的是，LinkedHashMap底层多了一个双向链表来链接所有的键值对实体对象。于是乎， LinkedHashMap的元素迭代顺序是由双向链表决定和维护的，而双向链表的顺序也反映了键值对被加入集合时的顺序，所以也可以理解成元素的插入顺序。如果向LinkedHashMap集合中插入一个已经存在的键值对，那么其在集合中的顺序不会因此而改变。</p>
<p>&emsp;&emsp;LinkedHashMap提供了一个特殊的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedHashMap(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> accessOrder)</span><br></pre></td></tr></table></figure>
<p>该方法决定了元素的遍历顺序，因此该构造方法可以被用于LRU算法中。如果accessOrder被定义为true，那么在迭代时将不会按照插入顺序来遍历访问，而是按照访问顺序来遍历迭代。访问顺序的特点是最近访问的元素会最后被遍历到。这个构造方法在LRU相关实现中有用，就LinkedHashMap本身而言，用途不是特别大。</p>
<p>&emsp;&emsp;LinkedHashMap提供的<strong>removeEldestEntry(Entry eldest)</strong>方法可以被子类覆盖，以便更好的实现移除最旧的键值对实体。除此之外，LinkedHashMap提供并实现了Map接口声明的所有方法，也允许null的加入。和HashMap一样，LinkedHashMap保证了插入，是否存在判断和移除操作可以在常量时间内完成。</p>
<p>&emsp;&emsp;和HashMap一样，LinkedHashMap的性能影响因子也是两个参数：initialCapacity和loadFactor。但是initialCapacity对LinkedHashMap的查询/遍历性能影响小于HashMap，因为LinkedHashMap底层存在一个双向链表，该双向链表链接了map集合中的所有元素，所以迭代器在遍历时不会与数组进行交互而是直接遍历双向链表中的键值对实体，所以initialCapacity对LinkedHashMap无影响。</p>
<p>&emsp;&emsp;LinkedHashMap是一个非线程安全的实现类。所以如果需要在多线程环境中使用LinkedHashMap，需要付诸额外的操作来保证多线程环境下的线程安全特性。一个常用的执行方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map m = Collections.synchronizedMap(<span class="keyword">new</span> LinkedHashMap(...));</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;LinkedHashMap同样支持快速失败检查，但是并不保证可以一定捕捉到快速失败检查。</p>
<p>&emsp;&emsp;LinkedHashMap的底层数据结构关系如图1所示：</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1544702029/BlogImages/java-collection/map/Map-LinkedHashMap-underlying-data-structure-example.png" alt></p>
<div align="center">
<div align="center">图 - 1</div>
&emsp;
</div>

<p>&emsp;</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LinkedHashMap&lt;E&gt;</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.util.AbstractMap&lt;K,V&gt;</span><br><span class="line">    --java.util.HashMap&lt;K,V&gt;</span><br><span class="line">      --java.util.LinkedHashMap&lt;K,V&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><div class="table-container">
<table>
<thead>
<tr>
<th>类名</th>
<th>实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>LinkedHashMap&lt;E&gt;</td>
<td>Serializable, Cloneable,Map&lt;K,V&gt;</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><h3 id="Constructor-Summary"><a href="#Constructor-Summary" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="public-LinkedHashMap-int-initialCapacity-float-loadFactor"><a href="#public-LinkedHashMap-int-initialCapacity-float-loadFactor" class="headerlink" title="public LinkedHashMap(int initialCapacity, float loadFactor)"></a>public LinkedHashMap(int initialCapacity, float loadFactor)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个空HashMap集合，集合的初始容量和加载因子由initialCapacity和loadFactor确认。调用父类HashMap的同名构造方法完成初始化操作。通过当前构造方法得到的map集合按照键值对实体插入顺序进行访问。</p>
<h4 id="public-LinkedHashMap-int-initialCapacity"><a href="#public-LinkedHashMap-int-initialCapacity" class="headerlink" title="public LinkedHashMap(int initialCapacity)"></a>public LinkedHashMap(int initialCapacity)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity);</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个空HashMap集合，集合的初始容量由initialCapacity和确认，加载因子默认为0.75。调用父类HashMap的同名构造方法完成初始化操作。通过当前构造方法得到的map集合按照键值对实体插入顺序进行访问。</p>
<h4 id="public-LinkedHashMap"><a href="#public-LinkedHashMap" class="headerlink" title="public LinkedHashMap()"></a>public LinkedHashMap()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个空HashMap集合，集合的初始容量默认为16，加载因子默认为0.75。调用父类HashMap的同名构造方法完成初始化操作。通过当前构造方法得到的map集合按照键值对实体插入顺序进行访问。</p>
<h4 id="public-LinkedHashMap-Map-lt-extends-K-extends-V-gt-m"><a href="#public-LinkedHashMap-Map-lt-extends-K-extends-V-gt-m" class="headerlink" title="public LinkedHashMap(Map&lt;? extends K, ? extends V&gt; m)"></a>public LinkedHashMap(Map&lt;? extends K, ? extends V&gt; m)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(m);</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个空HashMap集合，并将m中的键值对保存到初始化的map中。在初始化过程中，集合的容量大小由m存储的键值对数量决定，保证空map集合可以将m中的键值对全部存储下来，且默认加载因子是0.75。调用父类HashMap的同名构造方法完成初始化操作。通过当前构造方法得到的map集合按照键值对实体插入顺序进行访问。</p>
<h4 id="public-LinkedHashMap-int-initialCapacity-float-loadFactor-boolean-accessOrder"><a href="#public-LinkedHashMap-int-initialCapacity-float-loadFactor-boolean-accessOrder" class="headerlink" title="public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)"></a>public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, </span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个空HashMap集合，集合的初始容量和加载因子由initialCapacity和loadFactor确认。调用父类HashMap的同名构造方法完成初始化操作。调用该构造方法返回的LinkedHashMap实例会按照访问顺序而不是插入顺序来完成键值对实体元素的迭代。</p>
<h3 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="void-init"><a href="#void-init" class="headerlink" title="void init()"></a>void init()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    header = <span class="keyword">new</span> Entry&lt;&gt;(-<span class="number">1</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    header.before = header.after = header;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在构造方法或者clone、readObject等方法执行过程中调用，用来完成LinkedHashMap底层双向链表的初始化操作。</p>
<p>&emsp;&emsp;该方法执行过程中会首先实例化一个双向链表的头部节点，然后将头部节点的前驱和后继节点都指向自身。</p>
<h4 id="void-transfer-HashMap-Entry-newTable-boolean-rehash"><a href="#void-transfer-HashMap-Entry-newTable-boolean-rehash" class="headerlink" title="void transfer(HashMap.Entry[] newTable, boolean rehash)"></a>void transfer(HashMap.Entry[] newTable, boolean rehash)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(HashMap.Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = header.after; e != header; e = e.after) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rehash)</span><br><span class="line">            e.hash = (e.key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">        <span class="keyword">int</span> index = indexFor(e.hash, newCapacity);</span><br><span class="line">        e.next = newTable[index];</span><br><span class="line">        newTable[index] = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;完成键值对实体从旧数组到新数组的迁移。</p>
<p>&emsp;&emsp;整个过程相对来说还是比较简单的。具体流程如下：</p>
<ol>
<li>从头部节点开始遍历，取得一个键值对实体对象，根据其hash值计算在新数组中的下标位置（如果有必要的话重新计算hash）；</li>
<li>如果该下标位置尚未指向链表集合，那么该节点就是该下标位置的第一个节点；</li>
<li>否则将该节点加入到该下标位置的链表集合的头部位置上。</li>
</ol>
<p>&emsp;&emsp;对所有节点执行上述流程，直至头部节点header的前驱节点也被加入到了新数组中的某个位置，此时认为旧数组上的所有元素都被加入到了新数组上，执行结束返回。</p>
<h4 id="public-boolean-containsValue-Object-value"><a href="#public-boolean-containsValue-Object-value" class="headerlink" title="public boolean containsValue(Object value)"></a>public boolean containsValue(Object value)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Overridden to take advantage of faster iterator</span></span><br><span class="line">    <span class="keyword">if</span> (value==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry e = header.after; e != header; e = e.after)</span><br><span class="line">            <span class="keyword">if</span> (e.value==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry e = header.after; e != header; e = e.after)</span><br><span class="line">            <span class="keyword">if</span> (value.equals(e.value))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果当前map集合中存在匹配value的键值对实体，那么返回true，否则返回false。</p>
<p>&emsp;&emsp;从header节点指向的第一个节点开始遍历，根据value是否为null执行不同的判断条件查找可以和value吻合的键值对实体。</p>
<h4 id="public-V-get-Object-key"><a href="#public-V-get-Object-key" class="headerlink" title="public V get(Object key)"></a>public V get(Object key)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)getEntry(key);</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回当前map集合中匹配key的键值对实体，如果未找到可以匹配的对象，那么返回null。</p>
<p>&emsp;&emsp;如果可以找到匹配的键值对实体，那么会把该键值对实体移到双向链表的结尾位置（也就是header节点的前驱节点位置上）。</p>
<h4 id="public-void-clear"><a href="#public-void-clear" class="headerlink" title="public void clear()"></a>public void clear()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.clear();</span><br><span class="line">    header.before = header.after = header;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;清空当前map集合，同时将header指针初始化。</p>
<h4 id="Iterator-lt-K-gt-newKeyIterator"><a href="#Iterator-lt-K-gt-newKeyIterator" class="headerlink" title="Iterator&lt;K&gt; newKeyIterator()"></a>Iterator&lt;K&gt; newKeyIterator()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Iterator&lt;K&gt; <span class="title">newKeyIterator</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator();   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">LinkedHashIterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextEntry().getKey(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;构建一个遍历当前map集合中key的迭代器。KeyIterator基于LinkedHashMap.LinkedHashIterator&lt;V&gt;实现。</p>
<h4 id="Iterator-lt-V-gt-newValueIterator"><a href="#Iterator-lt-V-gt-newValueIterator" class="headerlink" title="Iterator&lt;V&gt; newValueIterator()"></a>Iterator&lt;V&gt; newValueIterator()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Iterator&lt;V&gt; <span class="title">newValueIterator</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ValueIterator(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIterator</span> <span class="keyword">extends</span> <span class="title">LinkedHashIterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextEntry().value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;构建一个遍历当前map集合中value的迭代器。ValueIterator基于LinkedHashMap.LinkedHashIterator&lt;V&gt;实现。</p>
<h4 id="Iterator-lt-Map-Entry-lt-K-V-gt-gt-newEntryIterator"><a href="#Iterator-lt-Map-Entry-lt-K-V-gt-gt-newEntryIterator" class="headerlink" title="Iterator&lt;Map.Entry&lt;K,V&gt;&gt; newEntryIterator()"></a>Iterator&lt;Map.Entry&lt;K,V&gt;&gt; newEntryIterator()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;K,V&gt;&gt; newEntryIterator() &#123; <span class="keyword">return</span> <span class="keyword">new</span> EntryIterator(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">LinkedHashIterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextEntry(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;构建一个遍历当前map集合中键值对的迭代器。EntryIterator基于LinkedHashMap.LinkedHashIterator&lt;V&gt;实现。</p>
<h4 id="void-addEntry-int-hash-K-key-V-value-int-bucketIndex"><a href="#void-addEntry-int-hash-K-key-V-value-int-bucketIndex" class="headerlink" title="void addEntry(int hash, K key, V value, int bucketIndex)"></a>void addEntry(int hash, K key, V value, int bucketIndex)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.addEntry(hash, key, value, bucketIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove eldest entry if instructed</span></span><br><span class="line">    Entry&lt;K,V&gt; eldest = header.after;</span><br><span class="line">    <span class="keyword">if</span> (removeEldestEntry(eldest)) &#123;</span><br><span class="line">        removeEntryForKey(eldest.key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;构建一个键值对实体并加入到map集合中对应下标位置上的链表集合中。调用的是HashMap同名方法。在执行过程中，如果空间不足会调用<strong>resize(int newCapacity)</strong>进行扩容，扩容完成后将旧数组上的键值对实体迁移到新数组上时，调用的是LinkedHashMap覆盖的transfer(HashMap.Entry[] newTable, boolean rehash)方法。最后加入键值对实体时，调用LinkedHashMap覆盖的createEntry(int hash, K key, V value, int bucketIndex)方法完成操作。</p>
<p>&emsp;&emsp;在将该键值对接入双向链表的过程中，该键值对会被加入到双向链表的尾部节点（即header的前驱节点）。</p>
<p>&emsp;&emsp;最后删除当前map集合中存在时间最久的键值对实体，由于LinkedHashMap实现类中的方法removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)直接返回false，所以第7行代码不会真正执行。</p>
<h4 id="void-createEntry-int-hash-K-key-V-value-int-bucketIndex"><a href="#void-createEntry-int-hash-K-key-V-value-int-bucketIndex" class="headerlink" title="void createEntry(int hash, K key, V value, int bucketIndex)"></a>void createEntry(int hash, K key, V value, int bucketIndex)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    HashMap.Entry&lt;K,V&gt; old = table[bucketIndex];</span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, old);</span><br><span class="line">    table[bucketIndex] = e;</span><br><span class="line">    e.addBefore(header);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;创建一个键值对实体并将该实体加入到当前map集合中。第2 ~4行代码将实体加入到当前map集合中底层数组对应下标位置上的链表集合中。第5行代码将当前新创建的节点加入到双向链表的尾部位置。</p>
<h4 id="protected-boolean-removeEldestEntry-Map-Entry-lt-K-V-gt-eldest"><a href="#protected-boolean-removeEldestEntry-Map-Entry-lt-K-V-gt-eldest" class="headerlink" title="protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)"></a>protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果当前map集合需要移除存在时间最久远的键值对实体就返回true，否则返回false。该方法被put或者putAll调用，用来在加入元素的过程中删除存在时间最久的元素。在LinkedHashMap中，该方法简单的返回false表示不会删除当前集合的双向链表中的尾部元素节点。</p>
<p>&emsp;</p>
<h2 id="Entry-lt-K-V-gt"><a href="#Entry-lt-K-V-gt" class="headerlink" title="Entry&lt;K,V&gt;"></a>Entry&lt;K,V&gt;</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// These fields comprise the doubly linked list used for iteration.</span></span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line"></span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, HashMap.Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes this entry from the linked list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        before.after = after;</span><br><span class="line">        after.before = before;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts this entry before the specified existing entry in the list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addBefore</span><span class="params">(Entry&lt;K,V&gt; existingEntry)</span> </span>&#123;</span><br><span class="line">        after  = existingEntry;</span><br><span class="line">        before = existingEntry.before;</span><br><span class="line">        before.after = <span class="keyword">this</span>;</span><br><span class="line">        after.before = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is invoked by the superclass whenever the value</span></span><br><span class="line"><span class="comment">     * of a pre-existing entry is read by Map.get or modified by Map.set.</span></span><br><span class="line"><span class="comment">     * If the enclosing Map is access-ordered, it moves the entry</span></span><br><span class="line"><span class="comment">     * to the end of the list; otherwise, it does nothing.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">        LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;</span><br><span class="line">        <span class="keyword">if</span> (lm.accessOrder) &#123;</span><br><span class="line">            lm.modCount++;</span><br><span class="line">            remove();</span><br><span class="line">            addBefore(lm.header);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recordRemoval</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">        remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;LinkedHashMap中的内部静态类Entry在继承了HashMap.Entry内容的基础上多了两个字段—Entry<k,v> before和Entry<k,v>  after。这两个字段是LinkedHashMap底层双向链表结构实现的基础。具体结构如图2所示：</k,v></k,v></p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1544701064/BlogImages/java-collection/map/Map-LinkedHashMap-Entry-example.png" alt></p>
<div align="center">
<div align="center">图 - 2</div>
&emsp;
</div>

<p>&emsp;&emsp;LinkedHashMap.Entry的构造方法直接调用其父类的同名方法完成键值对实体实例化操作。</p>
<p>&emsp;&emsp;通过调用<strong>remove()</strong>方法可以将当前键值对节点从map集合的双向链表中移除，实现思想主要参考了双向链表关于节点移除的操作思想。</p>
<p>&emsp;&emsp;<strong>addBefore(Entry&lt;K,V&gt; existingEntry)</strong>方法用来将当前键值对节点加入到existingEntry节点之前。</p>
<p>&emsp;&emsp;<strong>recordAccess(HashMap&lt;K,V&gt; m)</strong>方法会在键值对实体加入map集合或者通过LinkedHashMap.get(Object key)方法访问某个键值对实体时调用。如果当前LinkedHashMap的访问顺序不是插入顺序，那么该方法会将被插入的（或者被访问的）键值对实体对象从当前位置删除并移动到双向链表的尾部位置（也就是header的前驱）。如果当前map集合的访问顺序是插入顺序，那么不做任何处理。</p>
<p>&emsp;&emsp;在通过key或键值对自身从map集合中删除某个键值对实体时，会调用<strong>recordRemoval(HashMap<k,v>m)</k,v></strong>方法，该方法会将被删除键值对实体与其前驱、后继节点的关系断开，保证双向链表的连接性。</p>
<p>&emsp;</p>
<h2 id="LinkedHashIterator-lt-E-gt"><a href="#LinkedHashIterator-lt-E-gt" class="headerlink" title="LinkedHashIterator&lt;E&gt;"></a>LinkedHashIterator&lt;E&gt;</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashIterator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; nextEntry    = header.after;</span><br><span class="line">    Entry&lt;K,V&gt; lastReturned = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The modCount value that the iterator believes that the backing</span></span><br><span class="line"><span class="comment">     * List should have.  If this expectation is violated, the iterator</span></span><br><span class="line"><span class="comment">     * has detected concurrent modification.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextEntry != header;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line"></span><br><span class="line">        LinkedHashMap.<span class="keyword">this</span>.remove(lastReturned.key);</span><br><span class="line">        lastReturned = <span class="keyword">null</span>;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Entry&lt;K,V&gt; <span class="title">nextEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        <span class="keyword">if</span> (nextEntry == header)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">        Entry&lt;K,V&gt; e = lastReturned = nextEntry;</span><br><span class="line">        nextEntry = e.after;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;LinkedHashIterator是基于当前map集合的键值对实体的一个迭代器实现。该迭代器任何时候都会从header节点的后继节点开始迭代访问。</p>
<p>&emsp;&emsp;判断是否可以继续向后遍历通过判断下一个节点是否等于header来判定，如果等于表示无法继续向后遍历。</p>
<p>&emsp;</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li><p><strong>LinkedHashMap实现LRU算法场景</strong></p>
<p>&emsp;&emsp;实现一个LinkedHashMap的子类，子类中需要有方法指定一个当前集合中可以容纳的元素上限值，覆盖重新实现方法<strong>removeEldestEntry(Map.Entry<k,v> eldest) </k,v></strong>，实现思路如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> size() &gt; MAX_ENTRIES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;若当前集合容量大于上限，则返回true。在方法<strong>addEntry(int hash, K key, V value, int bucketIndex)</strong>中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.addEntry(hash, key, value, bucketIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove eldest entry if instructed</span></span><br><span class="line">    Entry&lt;K,V&gt; eldest = header.after;</span><br><span class="line">    <span class="keyword">if</span> (removeEldestEntry(eldest)) &#123;</span><br><span class="line">        removeEntryForKey(eldest.key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;第6行代码执行覆盖以后的removeEldestEntry(Map.Entry eldest)方法，如果返回true，那么就删除当前集合中双向链表的首部节点以保证元素数量满足要求（默认双向链表中长时间未被访问的元素位置越靠前）。</p>
</li>
</ol>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>NIL</li>
</ol>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Collection 10 - HashSet</title>
    <url>/2018/java-Collection-HashSet.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;关于<em> <strong>java.util.HashSet&lt;E&gt;</strong> </em>的部分笔记。HashSet集合是一个不会存储重复元素、遍历元素顺序无法保证的集合实现。本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;HashSet是一个以HashMap为底层数据结构的集合实现类，该实现类实现了Set接口中规定的集合处理方法API，而且允许存储null元素。HashSet集合具有集合内元素唯一，且无序的特点。由于底层数据结构依赖于散列表，所以HashSet的add(E e)、remove(Object o)、contains(Object o)、size()等方法可以实现常量时间的操作性能。</p>
<p>&emsp;&emsp;HashSet是一个非线程安全的实现。如果需要在多线程环境使用HashSet进行操作，那么要么使用线程安全的实现类，要么对HashSet集合做一些额外的处理来保证HashSet集合可以满足多线程环境中的使用需求。常见的一种实现方式是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set s = Collections.synchronizedSet(<span class="keyword">new</span> HashSet(...));</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;同样，HashSet集合返回的迭代器也含有快速失败检查，如果在遍历当前HashSet集合的过程中对集合做了结构化修改，那么就会抛出<strong>ConcurrentModificationException</strong>。同样的，HashSet集合也无法保证可以捕捉到所有的并发修改操作。</p>
<p>&emsp;</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HashSet&lt;E&gt;</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.util.AbstractCollection&lt;E&gt;</span><br><span class="line">    --java.util.AbstractSet&lt;E&gt;</span><br><span class="line">      --java.util.HashSet&lt;E&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><div class="table-container">
<table>
<thead>
<tr>
<th>类名</th>
<th>实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>HashSet&lt;E&gt;</td>
<td>Iterable&lt;E&gt;, Collection&lt;E&gt;, Set&lt;E&gt;, Serializable, Cloneable</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><h3 id="Constructor-Summary"><a href="#Constructor-Summary" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="public-HashSet"><a href="#public-HashSet" class="headerlink" title="public HashSet()"></a>public HashSet()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个空的set集合。底层依赖的hashmap的初始容量为16，加载因子是0.75。</p>
<h4 id="public-HashSet-Collection-lt-extends-E-gt-c"><a href="#public-HashSet-Collection-lt-extends-E-gt-c" class="headerlink" title="public HashSet(Collection&lt;? extends E&gt; c)"></a>public HashSet(Collection&lt;? extends E&gt; c)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个空set集合，并将集合c中的内容存储到set集合中。底层hashmap的初始容量由集合c中存储的元素数量决定。之后调用的<strong>addAll(Collection&lt;? extends E&gt; c)</strong>方法为AbstractCollection中实现的方法，内部调用了HashSet覆盖的父类方法<strong>add(E e)</strong>。</p>
<h4 id="public-HashSet-int-initialCapacity-float-loadFactor"><a href="#public-HashSet-int-initialCapacity-float-loadFactor" class="headerlink" title="public HashSet(int initialCapacity, float loadFactor)"></a>public HashSet(int initialCapacity, float loadFactor)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个空的set集合。底层依赖的hashmap的初始容量为initialCapacity，加载因子值是loadFactor。</p>
<h4 id="public-HashSet-int-initialCapacity"><a href="#public-HashSet-int-initialCapacity" class="headerlink" title="public HashSet(int initialCapacity)"></a>public HashSet(int initialCapacity)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个空的set集合。底层依赖的hashmap的初始容量为initialCapacity，加载因子值是默认的0.75。</p>
<h4 id="HashSet-int-initialCapacity-float-loadFactor-boolean-dummy"><a href="#HashSet-int-initialCapacity-float-loadFactor-boolean-dummy" class="headerlink" title="HashSet(int initialCapacity, float loadFactor, boolean dummy)"></a>HashSet(int initialCapacity, float loadFactor, boolean dummy)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个空的set集合。底层依赖的hashmap的初始容量为initialCapacity，加载因子值是loadFactor。这个构造方法中多了一个参数dummy，这个参数除了区别构造方法之外没有其他用处，但是该构造方法返回了一个LinkedHashMap，在LinkedHashSet&lt;E&gt;中使用该构造方法来实现一个基于链表的Set集合。</p>
<h3 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="public-Iterator-lt-E-gt-iterator"><a href="#public-Iterator-lt-E-gt-iterator" class="headerlink" title="public Iterator&lt;E&gt; iterator()"></a>public Iterator&lt;E&gt; iterator()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.keySet().iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回一个可以遍历当前HashSet集合的迭代器。该迭代器在遍历元素时不保证元素遍历的先后顺序。底层实际调用的是map中keySet集合的迭代器。</p>
<h4 id="public-int-size"><a href="#public-int-size" class="headerlink" title="public int size()"></a>public int size()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回当前HashSet集合存储的元素数量。底层实际调用的是map的size()方法完成操作。</p>
<h4 id="public-boolean-isEmpty"><a href="#public-boolean-isEmpty" class="headerlink" title="public boolean isEmpty()"></a>public boolean isEmpty()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;判断当前HashSet集合是否为空。如果为空返回true，否则返回false。底层实际调用的是map的isEmpty()方法完成操作。</p>
<h4 id="public-boolean-contains-Object-o"><a href="#public-boolean-contains-Object-o" class="headerlink" title="public boolean contains(Object o)"></a>public boolean contains(Object o)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;判断当前HashSet集合中是否含有元素o。如果存在返回true，否则返回false。底层实际调用的是map的containsKey(Object key)方法完成操作。</p>
<h4 id="public-boolean-add-E-e"><a href="#public-boolean-add-E-e" class="headerlink" title="public boolean add(E e)"></a>public boolean add(E e)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将元素e加入到当前HashSet集合中。如果元素e是第一次被加入到集合中，那么由于map的<strong>put(E key, Object value)</strong>方法会返回该key在加入之前的value值，所以会返回null，所以第一次加入元素e时当前方法会返回true。如果非第一次加入，那么map的put(E key, Object value)会返回一个非null对象，所以当前方法会返回false。</p>
<h4 id="public-boolean-remove-Object-o"><a href="#public-boolean-remove-Object-o" class="headerlink" title="public boolean remove(Object o)"></a>public boolean remove(Object o)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将元素o从当前HashSet集合中删除。由于在向map集合中存储元素时，key为当前HashSet集合存储的元素自身，value是一个初始化的Object对象，所以在调用map的<strong>remove(Object key)</strong>方法会返回该key在加入之前的value值，所以第一次删除元素时返回true。如果当前元素o被多次调用了<strong>remove(Object o)</strong>方法，那么第二次及之后就返回false。</p>
<h4 id="public-void-clear"><a href="#public-void-clear" class="headerlink" title="public void clear()"></a>public void clear()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;清空HashSet集合的所有元素。底层实际调用的是map的clear()方法完成操作。</p>
<h4 id="public-Object-clone"><a href="#public-Object-clone" class="headerlink" title="public Object clone()"></a>public Object clone()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">        newSet.map = (HashMap&lt;E, Object&gt;) map.clone();</span><br><span class="line">        <span class="keyword">return</span> newSet;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;克隆复制一个HashSet集合对象。该过程分两步进行，首先复制一个HashSet集合对象自身，接着复制HashSet集合底层的map结构，最后返回复制得到的对象。</p>
<h4 id="private-void-writeObject-java-io-ObjectOutputStream-s"><a href="#private-void-writeObject-java-io-ObjectOutputStream-s" class="headerlink" title="private void writeObject(java.io.ObjectOutputStream s)"></a>private void writeObject(java.io.ObjectOutputStream s)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Write out any hidden serialization magic</span></span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out HashMap capacity and load factor</span></span><br><span class="line">    s.writeInt(map.capacity());</span><br><span class="line">    s.writeFloat(map.loadFactor());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out size</span></span><br><span class="line">    s.writeInt(map.size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (E e : map.keySet())</span><br><span class="line">        s.writeObject(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将当前HashSet执行序列化操作并写入到流中。自定义方法，在执行序列化过程时会采用HashSet自己实现的过程来完成序列化操作。</p>
<h4 id="private-void-readObject-java-io-ObjectInputStream-s"><a href="#private-void-readObject-java-io-ObjectInputStream-s" class="headerlink" title="private void readObject(java.io.ObjectInputStream s)"></a>private void readObject(java.io.ObjectInputStream s)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// Read in any hidden serialization magic</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in HashMap capacity and load factor and create backing HashMap</span></span><br><span class="line">    <span class="keyword">int</span> capacity = s.readInt();</span><br><span class="line">    <span class="keyword">float</span> loadFactor = s.readFloat();</span><br><span class="line">    map = (((HashSet)<span class="keyword">this</span>) <span class="keyword">instanceof</span> LinkedHashSet ?</span><br><span class="line">           <span class="keyword">new</span> LinkedHashMap&lt;E,Object&gt;(capacity, loadFactor) :</span><br><span class="line">           <span class="keyword">new</span> HashMap&lt;E,Object&gt;(capacity, loadFactor));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in size</span></span><br><span class="line">    <span class="keyword">int</span> size = s.readInt();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        E e = (E) s.readObject();</span><br><span class="line">        map.put(e, PRESENT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从流中取出序列化的数据内容并反序列化成内存中的一个HashSet对象。自定义方法，在执行反序列的过程时会用HashSet自己实现的过程来完成反序列过程。</p>
<p>&emsp;</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li>NIL</li>
</ol>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>NIL</li>
</ol>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Collection 11 - LinkedHashSet</title>
    <url>/2018/java-Collection-LinkedHashSet.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;关于<em> <strong>java.util.LinkedHashSet&lt;E&gt;</strong> </em>的部分笔记。LinkedHashSet集合了散列表（hash table）和链表的特点于一身，解决了HashSet无法保证元素遍历顺序的问题，具有元素不重复，顺序固定的特点。本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;LinkedHashSet是基于散列表（hash table）和双向链表结构的Set实现类。和HashSet不同的是， LinkedHashSet保证了集合内元素的迭代顺序。该顺序是由双向链表来维护的，所以在集合元素遍历时，默认会按照元素被加入集合的顺序遍历并返回。<br>&emsp;&emsp;LinkedHashSet相对于HashSet保证了遍历顺序，同时也避免了随元素增多而导致的耗时增加（像TreeSet那样）。</p>
<p>&emsp;&emsp;LinkedHashSet提供了Set集合的所有方法，并且允许集合内存储null元素。和HashSet一样， LinkedHashSet对add(E e)、contains(Object o)、remove(Object o)的操作都是常量时间。在迭代集合时，<br>LinkedHashSet的耗时相对于HashSet好很多，因为LinkedHashSet需要的时间规模和其存储的元素总数成比例，而HashSet的时间规模和其存储的元素总数和其底层的HashMap的容量之和成比例。</p>
<p>&emsp;&emsp;LinkedHashSet也不是线程安全的，如果需要在多线程环境下使用LinkedHashSet，那么需要额外的处理来保证其线程安全。一种常用的方式是如下所示的处理方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set s = Collections.synchronizedSet(<span class="keyword">new</span> LinkedHashSet(...));</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;同样，LinkedHashSet集合返回的迭代器也含有快速失败检查，如果在遍历当前LinkedHashSet集合的过程中对集合做了结构化修改，那么就会抛出<strong>ConcurrentModificationException</strong>。同样的，LinkedHashSet集合也无法保证可以捕捉到所有的并发修改操作。</p>
<p>&emsp;&emsp;代码层面，LinkedHashSet只重新设计了构造方法，其他方法全部继承于HashSet。也就是说， LinkedHashSet的底层数据结构是一个LinkedHashMap，而HashSet的底层数据结构是一个HashMap，除此之外，LinkedHashSet在代码设计上和HashSet完全一致。</p>
<p>&emsp;</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LinkedHashSet&lt;E&gt;</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.util.AbstractCollection&lt;E&gt;</span><br><span class="line">    --java.util.AbstractSet&lt;E&gt;</span><br><span class="line">      --java.util.HashSet&lt;E&gt;</span><br><span class="line">        --java.util.LinkedHashSet&lt;E&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><div class="table-container">
<table>
<thead>
<tr>
<th>类名</th>
<th>实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>LinkedHashSet&lt;E&gt;</td>
<td>Iterable&lt;E&gt;, Collection&lt;E&gt;, Set&lt;E&gt;, Serializable, Cloneable</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><h3 id="Constructor-Summary"><a href="#Constructor-Summary" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="public-LinkedHashSet-int-initialCapacity-float-loadFactor"><a href="#public-LinkedHashSet-int-initialCapacity-float-loadFactor" class="headerlink" title="public LinkedHashSet(int initialCapacity, float loadFactor)"></a>public LinkedHashSet(int initialCapacity, float loadFactor)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;根据入参initialCapacity和加载因子loadFactor初始化一个LinkedHashSet集合。实际上是初始化了一个底层依赖的LinkedHashMap实例。</p>
<h4 id="public-LinkedHashSet-int-initialCapacity"><a href="#public-LinkedHashSet-int-initialCapacity" class="headerlink" title="public LinkedHashSet(int initialCapacity)"></a>public LinkedHashSet(int initialCapacity)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;根据入参initialCapacity初始化一个LinkedHashSet集合。实际上是初始化了一个底层依赖的LinkedHashMap实例，初始化LinkedHashMap的加载因子默认为0.75。</p>
<h4 id="public-LinkedHashSet"><a href="#public-LinkedHashSet" class="headerlink" title="public LinkedHashSet()"></a>public LinkedHashSet()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="number">16</span>, .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个LinkedHashSet集合。初始化LinkedHashMap的加载因子默认为0.75，初始容量为16。</p>
<h4 id="public-LinkedHashSet-Collection-lt-extends-E-gt-c"><a href="#public-LinkedHashSet-Collection-lt-extends-E-gt-c" class="headerlink" title="public LinkedHashSet(Collection&lt;? extends E&gt; c)"></a>public LinkedHashSet(Collection&lt;? extends E&gt; c)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(Math.max(<span class="number">2</span>*c.size(), <span class="number">11</span>), .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个LinkedHashSet集合，并将集合c中的元素全部加入到LinkedHashSet集合中。初始化LinkedHashMap的加载因子默认为0.75，初始容量为16。在初始化完成过程中通过AbstractCollection实现类的方法addAll(Collection&lt;? extends E&gt; c)完成元素加入操作。</p>
<h3 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h3><p>&emsp;&emsp;<strong>操作方法全部继承自HashSet，自身无方法实现和声明。</strong></p>
<p>&emsp;</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li>NIL</li>
</ol>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>NIL</li>
</ol>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Map 05 - Hashtable</title>
    <url>/2018/java-Collection-Hashtable.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;关于<em> <strong>java.util.Hashtable&lt;K, V&gt;</strong> </em>的部分笔记，Hashtable是一个不允许key和value为null的集合实现。和HashMap的功能和应用场景大致相同，但是Hashtable是一个线程安全的实现，可以用于多线程环境中。本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;Hashtable是一个存储key=value映射的实现类，对键值对的要求是key和value均不能为空。为了可能正确有效的存储和检索Hashtable里的键值对实体，key所属的类型必须要实现hashcode()和equals()方法。</p>
<p>&emsp;&emsp;Hashtable中有两个参数会影响散列表的操作性能：initialCapacity和loadFactor。initialCapacity决定了散列表中桶（存储键值对实体的数组）的大小，而loadFactor决定了当桶填充到什么程度时会执行数组扩容处理。如果执行了扩容操作，那么需要将当前散列表的键值对实体重新计算hashcode值并分配在扩容后数组中的位置。默认的加载因子是0.75，这个值保证了散列表的操作性能可以在时间和空间利用方面达到一个理想的平衡。</p>
<p>&emsp;&emsp;如果在元素插入前就可以估计到元素的数量，那么可以提前指定散列表的空间大小，这样可以在插入过程中避免频繁的重新分配空间而导致性能下降。</p>
<p>&emsp;&emsp;Hashtable的迭代器实现了Enumeration和Iterator两个接口，可以根据应用场景决定采用枚举或者迭代器的方式完成键值对实体的遍历。如果采用Iterator进行遍历，那么Hashtable在移除元素的过程中也会执行快速失败检查。</p>
<p>&emsp;&emsp;Hashtable是一个线程安全的实现类，如果需要在多线程环境中使用键值对映射实现，那么可以考虑采用Hashtable来完成需求。如果不需要考虑多线程场景，那么可以用HashMap来完成需求以提高性能。</p>
<p>&emsp;</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Hashtable&lt;K,V&gt;</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.util.Dictionary&lt;K,V&gt;</span><br><span class="line">    --java.util.Hashtable&lt;K,V&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><div class="table-container">
<table>
<thead>
<tr>
<th>类名</th>
<th>实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>LinkedHashMap&lt;E&gt;</td>
<td>Serializable, Cloneable,Map&lt;K,V&gt;</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h2><h3 id="Constructor-Summary"><a href="#Constructor-Summary" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="public-Hashtable-int-initialCapacity-float-loadFactor"><a href="#public-Hashtable-int-initialCapacity-float-loadFactor" class="headerlink" title="public Hashtable(int initialCapacity, float loadFactor)"></a>public Hashtable(int initialCapacity, float loadFactor)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Load: "</span>+loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity==<span class="number">0</span>)</span><br><span class="line">        initialCapacity = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    table = <span class="keyword">new</span> Entry[initialCapacity];</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">    initHashSeedAsNeeded(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个空Hashtable集合，集合的初始容量和加载因子由initialCapacity和loadFactor确认。如果initialCapacity的值为0，那么指定initialCapacity为1。</p>
<p>初始化底层存储结构table，根据initialCapacity和loadFactor确定扩容限制阈值，最后调用<strong>initHashSeedAsNeeded(int capacity)</strong>方法初始化散列掩码完成初始化操作。</p>
<h4 id="public-Hashtable-int-initialCapacity"><a href="#public-Hashtable-int-initialCapacity" class="headerlink" title="public Hashtable(int initialCapacity)"></a>public Hashtable(int initialCapacity)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="number">0.75f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个空Hashtable集合，集合的初始容量由initialCapacity和确认，加载因子默认为0.75。调用构造方法<strong>Hashtable(int initialCapacity, float loadFactor)</strong>完成初始化操作。</p>
<h4 id="public-Hashtable"><a href="#public-Hashtable" class="headerlink" title="public Hashtable()"></a>public Hashtable()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个空Hashtable集合，集合的初始容量默认为11，加载因子默认为0.75。调用构造方法<strong>Hashtable(int initialCapacity, float loadFactor)</strong>完成初始化操作。</p>
<h4 id="public-Hashtable-Map-lt-extends-K-extends-V-gt-t"><a href="#public-Hashtable-Map-lt-extends-K-extends-V-gt-t" class="headerlink" title="public Hashtable(Map&lt;? extends K, ? extends V&gt; t)"></a>public Hashtable(Map&lt;? extends K, ? extends V&gt; t)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(Map&lt;? extends K, ? extends V&gt; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Math.max(<span class="number">2</span>*t.size(), <span class="number">11</span>), <span class="number">0.75f</span>);</span><br><span class="line">    putAll(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个空Hashtable集合，并将t中的键值对保存到初始化的散列表中。在初始化过程中，集合的容量大小由t存储的键值对数量决定，保证空map集合可以将m中的键值对全部存储下来，且默认加载因子是0.75。调用构造方法<strong>Hashtable(int initialCapacity, float loadFactor)</strong>完成初始化操作。</p>
<p>&emsp;&emsp;初始化操作完成后，调用<strong>putAll(Map&lt;? extends K, ? extends V&gt; t)</strong>将集合t中的键值对保存到当前散列表中。</p>
<h3 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="public-synchronized-int-size"><a href="#public-synchronized-int-size" class="headerlink" title="public synchronized int size()"></a>public synchronized int size()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回当前散列表中的含有的key的数量。synchronized保证了该方法在多线程环境下同一时刻只有一个线程可以访问该方法，满足了多线程环境下的线程安全。</p>
<h4 id="public-synchronized-boolean-isEmpty"><a href="#public-synchronized-boolean-isEmpty" class="headerlink" title="public synchronized boolean isEmpty()"></a>public synchronized boolean isEmpty()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;判断当前散列表中是否为空，如果为空返回true，否则返回false。synchronized保证了该方法在多线程环境下同一时刻只有一个线程可以访问该方法，满足了多线程环境下的线程安全。</p>
<h4 id="public-synchronized-Enumeration-lt-K-gt-keys"><a href="#public-synchronized-Enumeration-lt-K-gt-keys" class="headerlink" title="public synchronized Enumeration&lt;K&gt; keys()"></a>public synchronized Enumeration&lt;K&gt; keys()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Enumeration&lt;K&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.&lt;K&gt;getEnumeration(KEYS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回当前散列表中存储的所有key的一个枚举形式。synchronized保证了该方法在多线程环境下同一时刻只有一个线程可以访问该方法，满足了多线程环境下的线程安全。</p>
<h4 id="public-synchronized-Enumeration-lt-K-gt-elements"><a href="#public-synchronized-Enumeration-lt-K-gt-elements" class="headerlink" title="public synchronized Enumeration&lt;K&gt; elements()"></a>public synchronized Enumeration&lt;K&gt; elements()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Enumeration&lt;V&gt; <span class="title">elements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.&lt;V&gt;getEnumeration(VALUES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回当前散列表中存储的所有value的一个枚举形式。synchronized保证了该方法在多线程环境下同一时刻只有一个线程可以访问该方法，满足了多线程环境下的线程安全。</p>
<h4 id="private-lt-T-gt-Enumeration-lt-T-gt-getEnumeration-int-type"><a href="#private-lt-T-gt-Enumeration-lt-T-gt-getEnumeration-int-type" class="headerlink" title="private &lt;T&gt; Enumeration&lt;T&gt; getEnumeration(int type)"></a>private &lt;T&gt; Enumeration&lt;T&gt; getEnumeration(int type)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Enumeration&lt;T&gt; <span class="title">getEnumeration</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyEnumeration();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Enumerator&lt;&gt;(type, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回一个枚举对象。如果当前散列表为空，那么返回一个空的枚举实例。否则初始化一个枚举器实例。</p>
<h4 id="public-synchronized-boolean-contains-Object-value"><a href="#public-synchronized-boolean-contains-Object-value" class="headerlink" title="public synchronized boolean contains(Object value)"></a>public synchronized boolean contains(Object value)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry tab[] = table;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tab.length ; i-- &gt; <span class="number">0</span> ;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[i] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.value.equals(value)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;判断当前散列表中是否存在匹配value的键值对映射。synchronized保证了该方法在多线程环境下同一时刻只有一个线程可以访问该方法，满足了多线程环境下的线程安全。该方法的执行性能比<strong>containsKey(Object key)</strong>差，这是需要注意的地方。</p>
<h4 id="public-boolean-containsValue-Object-value"><a href="#public-boolean-containsValue-Object-value" class="headerlink" title="public boolean containsValue(Object value)"></a>public boolean containsValue(Object value)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> contains(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;判断当前散列表中是否存在匹配的value的key存在，如果存在返回true，否则返回false。直接调用方法contains(Object value)实现功能。</p>
<h4 id="public-synchronized-boolean-containsKey-Object-key"><a href="#public-synchronized-boolean-containsKey-Object-key" class="headerlink" title="public synchronized boolean containsKey(Object key)"></a>public synchronized boolean containsKey(Object key)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;判断当前散列表中是否存在匹配key的键值对映射。如果存在返回true，否则返回false。synchronized保证了该方法在多线程环境下同一时刻只有一个线程可以访问该方法，满足了多线程环境下的线程安全。</p>
<p>&emsp;&emsp;首先计算key的hashcode，然后根据hashcode和当前散列表长度计算该对象可能位于的数组下标位置值。取得该下标位置的链表集合，遍历该集合找出key值相等元素，返回true。如果没找到，返回false。</p>
<h4 id="public-synchronized-V-get-Object-key"><a href="#public-synchronized-V-get-Object-key" class="headerlink" title="public synchronized V get(Object key)"></a>public synchronized V get(Object key)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从当前散列表集合中根据key找到可以匹配的键值对映射，如果存在返回键值对的value值，否则返回null。synchronized保证了该方法在多线程环境下同一时刻只有一个线程可以访问该方法，满足了多线程环境下的线程安全。</p>
<p>&emsp;&emsp;首先计算key的hashcode，并根据hashcode计算该映射在散列表中可能的下标位置。取得该下标位置的链表集合，遍历该集合找出key值相等的元素，返回对应的value值，否则返回null。</p>
<h4 id="protected-void-rehash"><a href="#protected-void-rehash" class="headerlink" title="protected void rehash()"></a>protected void rehash()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = table.length;</span><br><span class="line">    Entry&lt;K,V&gt;[] oldMap = table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAX_ARRAY_SIZE)</span><br><span class="line">            <span class="comment">// Keep running with MAX_ARRAY_SIZE buckets</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        newCapacity = MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    Entry&lt;K,V&gt;[] newMap = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">boolean</span> rehash = initHashSeedAsNeeded(newCapacity);</span><br><span class="line"></span><br><span class="line">    table = newMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = oldCapacity ; i-- &gt; <span class="number">0</span> ;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; old = oldMap[i] ; old != <span class="keyword">null</span> ; ) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = old;</span><br><span class="line">            old = old.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> index = (e.hash &amp; <span class="number">0x7FFFFFFF</span>) % newCapacity;</span><br><span class="line">            e.next = newMap[index];</span><br><span class="line">            newMap[index] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;当前散列表需要扩容处理，且将键值对映射保存到扩容后的数组中。</p>
<p>&emsp;&emsp;第6 ~ 12行代码计算扩容后需要的数组长度，并在第13行代码中完成新数组的初始化和空间分配。第16行代码计算新的扩容限制阈值以及是否需要重新计算hashcode值。</p>
<p>&emsp;&emsp;第21 ~ 33行代码遍历旧数组的每个节点上的链表集合以及集合里的每个元素，如果需要重新计算hashcode的话那么就调用hash(Object k)方法完成hashcode的计算，之后根据hashcode和新数组容量确定元素在新数组中的下标位置，最后将该元素加入到该下标位置的链表集合中。</p>
<h4 id="public-synchronized-V-put-K-key-V-value"><a href="#public-synchronized-V-put-K-key-V-value" class="headerlink" title="public synchronized V put(K key, V value)"></a>public synchronized V put(K key, V value)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Make sure the value is not null</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">    Entry tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            V old = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (count &gt;= threshold) &#123;</span><br><span class="line">        <span class="comment">// Rehash the table if the threshold is exceeded</span></span><br><span class="line">        rehash();</span><br><span class="line"></span><br><span class="line">        tab = table;</span><br><span class="line">        hash = hash(key);</span><br><span class="line">        index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Creates the new entry.</span></span><br><span class="line">    Entry&lt;K,V&gt; e = tab[index];</span><br><span class="line">    tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将键值对加入到当前散列表集合中。synchronized保证了该方法在多线程环境下同一时刻只有一个线程可以访问该方法，满足了多线程环境下的线程安全。</p>
<p>&emsp;&emsp;该方法不允许value为null，所以如果传入的value为null，那么抛出空指针异常。第9 ~ 10行代码计算key的hashcode值和该键值对在散列表中的下标位置。第11 ~ 17行代码中如果该下标位置的链表集合中存在key值相同的键值对映射，那么用value替换原有的值并返回被替换的值。</p>
<p>&emsp;&emsp;如果当前散列表容量超过了扩容限制阈值，那么调用rehash()方法完成扩容以及键值对实体迁移操作，并计算key的hashcode值以及当前key=value在新数组中的下标位置。最后创建一个新的Entry节点并加入到该下标位置的链表集合的首部节点上，并更新count值。</p>
<h4 id="public-synchronized-void-putAll-Map-lt-extends-K-extends-V-gt-t"><a href="#public-synchronized-void-putAll-Map-lt-extends-K-extends-V-gt-t" class="headerlink" title="public synchronized void putAll(Map&lt;? extends K, ? extends V&gt; t)"></a>public synchronized void putAll(Map&lt;? extends K, ? extends V&gt; t)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : t.entrySet())</span><br><span class="line">        put(e.getKey(), e.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将t中的所有键值对映射都加入到当前散列表中。synchronized保证了该方法在多线程环境下同一时刻只有一个线程可以访问该方法，满足了多线程环境下的线程安全。底层调用put(K key, V value)完成操作。</p>
<h4 id="public-synchronized-V-remove-Object-key"><a href="#public-synchronized-V-remove-Object-key" class="headerlink" title="public synchronized V remove(Object key)"></a>public synchronized V remove(Object key)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index], prev = <span class="keyword">null</span> ; e != <span class="keyword">null</span> ; prev = e, e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                prev.next = e.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tab[index] = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从当前散列表中删除可以匹配key的键值对映射。synchronized保证了该方法在多线程环境下同一时刻只有一个线程可以访问该方法，满足了多线程环境下的线程安全。</p>
<p>&emsp;&emsp;根据key计算对应的hashcode值，以及该key在散列表中的下标位置，得到该下标位置的链表集合，遍历集合中的每个键值对映射实体。如果hashcode一致且key一致，如果prev != null，那么说明匹配的键值对实体不是链表的首部节点，那么直接移除该节点。反之，则将链表首部节点的后继节点指向下标位置实体。最后返回被删除的键值对映射的value值。</p>
<h4 id="public-synchronized-void-clear"><a href="#public-synchronized-void-clear" class="headerlink" title="public synchronized void clear()"></a>public synchronized void clear()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry tab[] = table;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = tab.length; --index &gt;= <span class="number">0</span>; )</span><br><span class="line">        tab[index] = <span class="keyword">null</span>;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;清空当前散列表。synchronized保证了该方法在多线程环境下同一时刻只有一个线程可以访问该方法，满足了多线程环境下的线程安全。</p>
<h4 id="public-synchronized-Object-clone"><a href="#public-synchronized-Object-clone" class="headerlink" title="public synchronized Object clone()"></a>public synchronized Object clone()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Hashtable&lt;K,V&gt; t = (Hashtable&lt;K,V&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">        t.table = <span class="keyword">new</span> Entry[table.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = table.length ; i-- &gt; <span class="number">0</span> ; ) &#123;</span><br><span class="line">            t.table[i] = (table[i] != <span class="keyword">null</span>) ? (Entry&lt;K,V&gt;) table[i].clone() : <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        t.keySet = <span class="keyword">null</span>;</span><br><span class="line">        t.entrySet = <span class="keyword">null</span>;</span><br><span class="line">        t.values = <span class="keyword">null</span>;</span><br><span class="line">        t.modCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">// this shouldn't happen, since we are Cloneable</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将当前散列表克隆一份并返回复制对象。</p>
<h4 id="public-synchronized-String-toString"><a href="#public-synchronized-String-toString" class="headerlink" title="public synchronized String toString()"></a>public synchronized String toString()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (max == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;&#125;"</span>;</span><br><span class="line"></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    Iterator&lt;Map.Entry&lt;K,V&gt;&gt; it = entrySet().iterator();</span><br><span class="line"></span><br><span class="line">    sb.append(<span class="string">'&#123;'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">        Map.Entry&lt;K,V&gt; e = it.next();</span><br><span class="line">        K key = e.getKey();</span><br><span class="line">        V value = e.getValue();</span><br><span class="line">        sb.append(key   == <span class="keyword">this</span> ? <span class="string">"(this Map)"</span> : key.toString());</span><br><span class="line">        sb.append(<span class="string">'='</span>);</span><br><span class="line">        sb.append(value == <span class="keyword">this</span> ? <span class="string">"(this Map)"</span> : value.toString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i == max)</span><br><span class="line">            <span class="keyword">return</span> sb.append(<span class="string">'&#125;'</span>).toString();</span><br><span class="line">        sb.append(<span class="string">", "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回当前散列表的String形式表示。</p>
<h4 id="public-Set-lt-K-gt-keySet"><a href="#public-Set-lt-K-gt-keySet" class="headerlink" title="public Set&lt;K&gt; keySet()"></a>public Set&lt;K&gt; keySet()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (keySet == <span class="keyword">null</span>)</span><br><span class="line">        keySet = Collections.synchronizedSet(<span class="keyword">new</span> KeySet(), <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> keySet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getIterator(KEYS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> containsKey(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Hashtable.<span class="keyword">this</span>.remove(o) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Hashtable.<span class="keyword">this</span>.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回当前散列表中存储的所有键值对映射的key的set集合。返回的是一个线程安全的集合实例。</p>
<h4 id="private-lt-T-gt-Iterator-lt-T-gt-getIterator-int-type"><a href="#private-lt-T-gt-Iterator-lt-T-gt-getIterator-int-type" class="headerlink" title="private &lt;T&gt; Iterator&lt;T&gt; getIterator(int type)"></a>private &lt;T&gt; Iterator&lt;T&gt; getIterator(int type)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Iterator&lt;T&gt; <span class="title">getIterator</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyIterator();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Enumerator&lt;&gt;(type, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;根据类型返回迭代器。</p>
<h4 id="public-Set-lt-Map-Entry-lt-K-V-gt-gt-entrySet"><a href="#public-Set-lt-Map-Entry-lt-K-V-gt-gt-entrySet" class="headerlink" title="public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()"></a>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">    <span class="keyword">if</span> (entrySet==<span class="keyword">null</span>)</span><br><span class="line">        entrySet = Collections.synchronizedSet(<span class="keyword">new</span> EntrySet(), <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> entrySet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> getIterator(ENTRIES);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Map.Entry&lt;K,V&gt; o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry entry = (Map.Entry)o;</span><br><span class="line">        Object key = entry.getKey();</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Entry e = tab[index]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">            <span class="keyword">if</span> (e.hash==hash &amp;&amp; e.equals(entry))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o;</span><br><span class="line">        K key = entry.getKey();</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index], prev = <span class="keyword">null</span>; e != <span class="keyword">null</span>;</span><br><span class="line">             prev = e, e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash==hash &amp;&amp; e.equals(entry)) &#123;</span><br><span class="line">                modCount++;</span><br><span class="line">                <span class="keyword">if</span> (prev != <span class="keyword">null</span>)</span><br><span class="line">                    prev.next = e.next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    tab[index] = e.next;</span><br><span class="line"></span><br><span class="line">                count--;</span><br><span class="line">                e.value = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Hashtable.<span class="keyword">this</span>.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回当前散列表中存储的所有键值对映射的set集合。返回的是一个线程安全的集合实例。</p>
<h4 id="public-Collection-lt-V-gt-values"><a href="#public-Collection-lt-V-gt-values" class="headerlink" title="public Collection&lt;V&gt; values()"></a>public Collection&lt;V&gt; values()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (values==<span class="keyword">null</span>)</span><br><span class="line">        values = Collections.synchronizedCollection(<span class="keyword">new</span> ValueCollection(), <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueCollection</span> <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;V&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getIterator(VALUES);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> containsValue(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Hashtable.<span class="keyword">this</span>.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回当前散列表中存储的所有键值对映射的value的Collection集合。返回的是一个线程安全的集合实例。</p>
<h4 id="public-synchronized-boolean-equals-Object-o"><a href="#public-synchronized-boolean-equals-Object-o" class="headerlink" title="public synchronized boolean equals(Object o)"></a>public synchronized boolean equals(Object o)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Map&lt;K,V&gt; t = (Map&lt;K,V&gt;) o;</span><br><span class="line">    <span class="keyword">if</span> (t.size() != size())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!(t.get(key)==<span class="keyword">null</span> &amp;&amp; t.containsKey(key)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!value.equals(t.get(key)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassCastException unused)   &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException unused) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;判断当前散列表和对象o是否相等。如果o是当前散列表自身，那么返回true。如果o不是一个map实现，那么直接返回false。如果o存储的键值对映射数量和当前散列表的数量不一致，直接返回false。</p>
<p>&emsp;&emsp;遍历当前散列表中的每一个键值对映射实体，如果存在value不一致的映射，那么直接返回false。</p>
<h4 id="public-synchronized-int-hashCode"><a href="#public-synchronized-int-hashCode" class="headerlink" title="public synchronized int hashCode()"></a>public synchronized int hashCode()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span> || loadFactor &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> h;  <span class="comment">// Returns zero</span></span><br><span class="line"></span><br><span class="line">    loadFactor = -loadFactor;  <span class="comment">// Mark hashCode computation in progress</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; entry : tab)</span><br><span class="line">        <span class="keyword">while</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">            h += entry.hashCode();</span><br><span class="line">            entry = entry.next;</span><br><span class="line">        &#125;</span><br><span class="line">    loadFactor = -loadFactor;  <span class="comment">// Mark hashCode computation complete</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回当前散列表的hashcode值。计算的是散列表中每个键值对的hashcode之和。</p>
<h4 id="private-void-writeObject-java-io-ObjectOutputStream-s"><a href="#private-void-writeObject-java-io-ObjectOutputStream-s" class="headerlink" title="private void writeObject(java.io.ObjectOutputStream s)"></a>private void writeObject(java.io.ObjectOutputStream s)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Entry&lt;K, V&gt; entryStack = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// Write out the length, threshold, loadfactor</span></span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out length, count of elements</span></span><br><span class="line">        s.writeInt(table.length);</span><br><span class="line">        s.writeInt(count);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Stack copies of the entries in the table</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; table.length; index++) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; entry = table[index];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">                entryStack =</span><br><span class="line">                    <span class="keyword">new</span> Entry&lt;&gt;(<span class="number">0</span>, entry.key, entry.value, entryStack);</span><br><span class="line">                entry = entry.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out the key/value objects from the stacked entries</span></span><br><span class="line">    <span class="keyword">while</span> (entryStack != <span class="keyword">null</span>) &#123;</span><br><span class="line">        s.writeObject(entryStack.key);</span><br><span class="line">        s.writeObject(entryStack.value);</span><br><span class="line">        entryStack = entryStack.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Hashtable的自定义序列化实现过程。</p>
<p>&emsp;&emsp;第7行代码将Hashtable的threshold和loadFactor写入到流中，第10 ~ 11行代码将当前数组的长度和Hashtable容纳的键值对数量写入到流中。第14 ~ 22行代码取得当前集合中所有的键值对映射实体。最后遍历该集合，按照先key后value的顺序将键值对映射写入到流中。</p>
<h4 id="private-void-readObject-java-io-ObjectInputStream-s"><a href="#private-void-readObject-java-io-ObjectInputStream-s" class="headerlink" title="private void readObject(java.io.ObjectInputStream s)"></a>private void readObject(java.io.ObjectInputStream s)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// Read in the length, threshold, and loadfactor</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read the original length of the array and number of elements</span></span><br><span class="line">    <span class="keyword">int</span> origlength = s.readInt();</span><br><span class="line">    <span class="keyword">int</span> elements = s.readInt();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute new size with a bit of room 5% to grow but</span></span><br><span class="line">    <span class="comment">// no larger than the original size.  Make the length</span></span><br><span class="line">    <span class="comment">// odd if it's large enough, this helps distribute the entries.</span></span><br><span class="line">    <span class="comment">// Guard against the length ending up zero, that's not valid.</span></span><br><span class="line">    <span class="keyword">int</span> length = (<span class="keyword">int</span>)(elements * loadFactor) + (elements / <span class="number">20</span>) + <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (length &gt; elements &amp;&amp; (length &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">        length--;</span><br><span class="line">    <span class="keyword">if</span> (origlength &gt; <span class="number">0</span> &amp;&amp; length &gt; origlength)</span><br><span class="line">        length = origlength;</span><br><span class="line"></span><br><span class="line">    Entry&lt;K,V&gt;[] newTable = <span class="keyword">new</span> Entry[length];</span><br><span class="line">    threshold = (<span class="keyword">int</span>) Math.min(length * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    initHashSeedAsNeeded(length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read the number of elements and then all the key/value objects</span></span><br><span class="line">    <span class="keyword">for</span> (; elements &gt; <span class="number">0</span>; elements--) &#123;</span><br><span class="line">        K key = (K)s.readObject();</span><br><span class="line">        V value = (V)s.readObject();</span><br><span class="line">        <span class="comment">// synch could be eliminated for performance</span></span><br><span class="line">        reconstitutionPut(newTable, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Hashtable的自定义反序列实现过程。</p>
<h4 id="private-void-reconstitutionPut-Entry-tab-K-key-V-value"><a href="#private-void-reconstitutionPut-Entry-tab-K-key-V-value" class="headerlink" title="private void reconstitutionPut(Entry[] tab, K key, V value)"></a>private void reconstitutionPut(Entry<k,v>[] tab, K key, V value)</k,v></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reconstitutionPut</span><span class="params">(Entry&lt;K,V&gt;[] tab, K key, V value)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> StreamCorruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> java.io.StreamCorruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">    <span class="comment">// This should not happen in deserialized version.</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.io.StreamCorruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Creates the new entry.</span></span><br><span class="line">    Entry&lt;K,V&gt; e = tab[index];</span><br><span class="line">    tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;重新构建反序列得到的键值对实体数据。由于Hashtable不允许key重复，所以不存在key相同的两个及以上的键值对实体。所以如果发生了这种情况，那么就抛出异常。</p>
<p>&emsp;</p>
<h2 id="Entry-lt-K-V-gt"><a href="#Entry-lt-K-V-gt" class="headerlink" title="Entry&lt;K,V&gt;"></a>Entry&lt;K,V&gt;</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Entry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Entry&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key =  key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value,</span><br><span class="line">                           (next==<span class="keyword">null</span> ? <span class="keyword">null</span> : (Entry&lt;K,V&gt;) next.clone()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Map.Entry Ops</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">        V oldValue = <span class="keyword">this</span>.value;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry)o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> key.equals(e.getKey()) &amp;&amp; value.equals(e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Objects.hashCode(key) ^ Objects.hashCode(value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key.toString()+<span class="string">"="</span>+value.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Entry<k,v>是Hashtable集合的内部类，实现了Map.Entry&lt;K,V&gt;接口。实际上散列表内部的存储结构就是一个Entry<k,v>形式的数组，数组中的每个元素都是一个Entry<k,v>实体。</k,v></k,v></k,v></p>
<p>&emsp;&emsp;Entry<k,v>中包含了四个字段：value（map集合中键值对的值内容），key（map集合中键值对的键内容），next（当前entry节点的下一个节点）和hash（map集合中键值对的键的hashcode值）。</k,v></p>
<p>&emsp;&emsp;实体自身的hashcode计算方式是将当前实体的key的hashcode和value的hashcode求异或运算得到结果。</p>
<p>&emsp;&emsp;比较两个实体是否相等，首先判断两个实体的类型是否一致，其次分别判断两个实体的key和value是否都相等。</p>
<p>&emsp;</p>
<h2 id="Enumerator-lt-T-gt"><a href="#Enumerator-lt-T-gt" class="headerlink" title="Enumerator&lt;T&gt;"></a>Enumerator&lt;T&gt;</h2><p>&emsp;&emsp;Enumerator是Hashtable内部类，用来完成散列表内键值对实体的遍历。Enumerator实现了Enumeration和Iterator两个接口声明的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Enumerator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Enumeration</span>&lt;<span class="title">T</span>&gt;, <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    Entry[] table = Hashtable.<span class="keyword">this</span>.table;</span><br><span class="line">    <span class="keyword">int</span> index = table.length;</span><br><span class="line">    Entry&lt;K,V&gt; entry = <span class="keyword">null</span>;</span><br><span class="line">    Entry&lt;K,V&gt; lastReturned = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来标记当前Enumerator实例是以Iterator还是Enumeration的身份进行遍历。</span></span><br><span class="line"><span class="comment">     * true为Iterator。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">boolean</span> iterator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化一个Enumerator实例。</span></span><br><span class="line"><span class="comment">     * type的值决定了遍历的基础：KEYS = 0; VALUES = 1; ENTRIES = 2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Enumerator(<span class="keyword">int</span> type, <span class="keyword">boolean</span> iterator) &#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.iterator = iterator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否可以继续向后遍历。</span></span><br><span class="line"><span class="comment">     * 遍历Hashtable的底层数组，看能否找到一个非空的Entry实体，如果找到返回true，否则返回</span></span><br><span class="line"><span class="comment">     * false。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = entry;</span><br><span class="line">        <span class="keyword">int</span> i = index;</span><br><span class="line">        Entry[] t = table;</span><br><span class="line">        <span class="comment">/* Use locals for faster loop iteration */</span></span><br><span class="line">        <span class="keyword">while</span> (e == <span class="keyword">null</span> &amp;&amp; i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            e = t[--i];</span><br><span class="line">        &#125;</span><br><span class="line">        entry = e;</span><br><span class="line">        index = i;</span><br><span class="line">        <span class="keyword">return</span> e != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历获取下一个元素。</span></span><br><span class="line"><span class="comment">     * 在初始化Enumerator时传入的字段type会在这个方法中决定遍历后返回的内容是什么。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">nextElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; et = entry;</span><br><span class="line">        <span class="keyword">int</span> i = index;</span><br><span class="line">        Entry[] t = table;</span><br><span class="line">        <span class="comment">/* Use locals for faster loop iteration */</span></span><br><span class="line">        <span class="keyword">while</span> (et == <span class="keyword">null</span> &amp;&amp; i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            et = t[--i];</span><br><span class="line">        &#125;</span><br><span class="line">        entry = et;</span><br><span class="line">        index = i;</span><br><span class="line">        <span class="keyword">if</span> (et != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = lastReturned = entry;</span><br><span class="line">            entry = e.next;</span><br><span class="line">            <span class="keyword">return</span> type == KEYS ? (T)e.key : (type == VALUES ? (T)e.value : (T)e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"Hashtable Enumerator"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterator methods</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hasMoreElements();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        <span class="keyword">return</span> nextElement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除一个元素。</span></span><br><span class="line"><span class="comment">     * 该操作只支持Iterator。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!iterator)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Hashtable Enumerator"</span>);</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span>(Hashtable.<span class="keyword">this</span>) &#123;</span><br><span class="line">            Entry[] tab = Hashtable.<span class="keyword">this</span>.table;</span><br><span class="line">            <span class="keyword">int</span> index = (lastReturned.hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index], prev = <span class="keyword">null</span>; e != <span class="keyword">null</span>;</span><br><span class="line">                 prev = e, e = e.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e == lastReturned) &#123;</span><br><span class="line">                    modCount++;</span><br><span class="line">                    expectedModCount++;</span><br><span class="line">                    <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">                        tab[index] = e.next;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        prev.next = e.next;</span><br><span class="line">                    count--;</span><br><span class="line">                    lastReturned = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li>NIL</li>
</ol>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>NIL</li>
</ol>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Collection 07 - LinkedList</title>
    <url>/2018/java-Collection-LinkedList.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;关于<em> <strong>java.util.LinkedList&lt;E&gt;</strong> </em>的部分笔记，LinkedList是一个非线程安全的List集合实现类。因为其采用了双向链表作为底层存储数据结构而具有了可以以常量时间插入数据的性能，但是因为底层数据结构的限制导致其只能顺序访问元素。鉴于此，LinkedList适用于元素插入频繁，而元素遍历查找相对次要的场景中。本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;LinkedList是一个以双向链表为基础的List集合，其综合了List集合和Deque队列的优势和特点实现了一个顺序访问的集合实现类。因为LinkedList的底层依赖了链表数据结构，所以在元素访问时都是按照链表的方式从首元素依次遍历直至到达目标元素。此外，鉴于其依赖的链表实现，所以在元素插入时可以达到常量时间的操作性能。</p>
<p>&emsp;&emsp;需要注意的是，LinkedList是一个非线程安全的集合实现。如果需要在多线程环境中使用LinkedList完成需求，那么需要添加另外处理来保证多线程环境下的线程安全，一种可以实现要求的常用处理方式是使用<strong>Collections.synchronizedList(new LinkedList(…))</strong>来在LinkedList初始化时保证LinkedList的线程安全。示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = Collections.synchronizedList(<span class="keyword">new</span> LinkedList(...));</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;LinkedList返回的迭代器支持快速失败（fail-fast）检查。如果当前迭代器发现LinkedList集合最近一次做了不是由当前迭代器执行的结构化修改，那么就返回一个<strong>ConcurrentModificationException</strong>异常。</p>
<p>&emsp;&emsp;LinkedList中通过两个Node节点：<strong>first</strong>和<strong>last</strong>来维护存储在LinkedList的元素内容。其中first节点指向集合中的第一个元素，last节点指向集合中的最后一个元素。在访问集合中元素时都是通过first或者last节点开始，逐个遍历直到到达目标位置。结构示例如图1所示：</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1544328570/BlogImages/java-collection/list/LinkedList-Node-example.png" alt></p>
<div align="center">
<div align="center">图 - 1</div>
&emsp;
</div>

<p>&emsp;&emsp;<strong>这里的first和last节点中也会存储元素。</strong></p>
<p>&emsp;</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LinkedList&lt;E&gt;</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.util.AbstractCollection&lt;E&gt;</span><br><span class="line">    --java.util.AbstractList&lt;E&gt;</span><br><span class="line">      --java.util.AbstractSequentialList&lt;E&gt;</span><br><span class="line">        --java.util.LinkedList&lt;E&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><div class="table-container">
<table>
<thead>
<tr>
<th>类名</th>
<th>实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>LinkedList&lt;E&gt;</td>
<td>Iterable&lt;E&gt;, Collection&lt;E&gt;, List&lt;E&gt;, Queue&lt;E&gt;, Serializable, Cloneable</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><h3 id="Constructor-Summary"><a href="#Constructor-Summary" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="public-LinkedList"><a href="#public-LinkedList" class="headerlink" title="public LinkedList()"></a>public LinkedList()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个LinkedList空集合实例。</p>
<h4 id="public-LinkedList-Collection-lt-extends-E-gt-c"><a href="#public-LinkedList-Collection-lt-extends-E-gt-c" class="headerlink" title="public LinkedList(Collection&lt;? extends E&gt; c)"></a>public LinkedList(Collection&lt;? extends E&gt; c)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;根据集合c初始化一个LinkedList空集合实例，并将c中的内容复制到实例化后的集合实例中。初始化的实例集合中元素的位置和c一致。元素的加入通过<strong>addAll(Collection&lt;? extends E&gt; c)</strong>完成。</p>
<h3 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="private-void-linkFirst-E-e"><a href="#private-void-linkFirst-E-e" class="headerlink" title="private void linkFirst(E e)"></a>private void linkFirst(E e)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在链表首部加入元素e。<strong>LinkedList底层双向链表操作方法API之一</strong>。操作过程如图2所示：</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1544280608/BlogImages/java-collection/list/LinkedList-LinkFirst-example.png" alt></p>
<div align="center">
<div align="center">图 - 2</div>
&emsp;
</div>

<p>&emsp;&emsp;第2 ~ 3行代码根据元素e和当前LinkedList集合的首部元素创建一个Node节点，即alpha阶段。alpha的（1）过程表明在元素初始化过程中将新节点newNode的后继指向当前LinkedList集合的首部元素节点。第4行代码将当前LinkedList集合的首部元素节点指向新创建的newNode节点，使新的newNode节点成为新的首部元素。如果当前LinkedList集合是个空集合，则将last节点也指向到newNode，最终到达bravo_2阶段。此时整个集合中只包含一个元素，即newNode。如果当前LinkedList集合不为空，那么将被newNode之后的节点的前驱指向新创建的newNode节点，即bravo_1阶段的步骤（2）。</p>
<h4 id="void-linkLast-E-e"><a href="#void-linkLast-E-e" class="headerlink" title="void linkLast(E e)"></a>void linkLast(E e)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在链表尾部加入元素e。<strong>LinkedList底层双向链表操作方法API之一</strong>。操作过程如图3所示：</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1544280610/BlogImages/java-collection/list/LinkedList-LinkLast-example.png" alt></p>
<div align="center">
<div align="center">图 - 3</div>
&emsp;
</div>

<p>&emsp;&emsp;第2 ~ 3行代码根据元素e和当前LinkedList集合的尾部元素创建一个Node节点，即alpha阶段。alpha的（1）过程表明在元素初始化过程中将新节点newNode的前驱指向当前LinkedList集合的尾部元素节点。第4行代码将当前LinkedList集合的last节点指向新创建的newNode节点，使新的newNode节点成为新的尾部元素。如果当前LinkedList集合是个空集合，则将first节点也指向到newNode，最终到达bravo_2阶段。此时整个集合中只包含一个元素，即newNode。如果当前LinkedList集合不为空，那么将被newNode之前的节点的后继指向新创建的newNode节点，即bravo_1阶段的步骤（2）。</p>
<h4 id="void-linkBefore-E-e-Node-lt-E-gt-succ"><a href="#void-linkBefore-E-e-Node-lt-E-gt-succ" class="headerlink" title="void linkBefore(E e, Node&lt;E&gt; succ)"></a>void linkBefore(E e, Node&lt;E&gt; succ)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在元素succ之前插入一个元素e。<strong>LinkedList底层双向链表操作方法API之一</strong>。操作过程如图4所示：</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1544280608/BlogImages/java-collection/list/LinkedList-LinkBefore-example.png" alt></p>
<div align="center">
<div align="center">图 - 4</div>
&emsp;
</div>

<p>&emsp;&emsp;在这个操作中，参数succ即为元素e的后继节点。第3 ~ 4行代码根据元素e和前驱节点succ创建一个Node节点，即alpha阶段。此时newNode的后继是succ，newNode的前驱为succ的前驱（有可能为null，若为null则表示succ为当前LinkedList集合的首部元素）。第5行代码将当前succ节点的前驱指向newNode节点，即bravo阶段的过程（1）。如果succ是当前LinkedList集合的第一个元素，那么完成newNode和succ的相互指定后newNode会成为LinkedList集合的首部元素（第6 ~ 7行代码的执行情况），反之，则将succ的前驱节点的后继更新为newNode节点，即bravo阶段的过程（2）。</p>
<h4 id="private-E-unlinkFirst-Node-lt-E-gt-f"><a href="#private-E-unlinkFirst-Node-lt-E-gt-f" class="headerlink" title="private E unlinkFirst(Node&lt;E&gt; f)"></a>private E unlinkFirst(Node&lt;E&gt; f)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = f.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    first = next;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        next.prev = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;移除LinkedList集合中的首部元素f。<strong>LinkedList底层双向链表操作方法API之一</strong>。操作过程如图5所示：</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1544280612/BlogImages/java-collection/list/LinkedList-unlinkFirst-example.png" alt></p>
<div align="center">
<div align="center">图 - 5</div>
&emsp;
</div>

<p>&emsp;&emsp;第3 ~ 4行代码获取首部元素的内容及其后继节点的相关信息。第6行代码将首部元素指向其后继的指针断开，即alpha阶段的步骤（1）。第7行代码则将first指向当前首部元素f的后继节点上，即bravo阶段。如果f节点的后继为空，且该方法删除是的首部节点，那么认为该节点会是当前LinkedList集合的唯一一个节点，所以last节点被置为null。反之，则将f的后继节点的前驱指针置为空，这样该后续节点将会成为真正的首部元素，即charlie阶段的过程（2）。最后，脱离LinkedList集合的首部元素element会被返回给方法调用方。</p>
<h4 id="private-E-unlinkLast-Node-lt-E-gt-l"><a href="#private-E-unlinkLast-Node-lt-E-gt-l" class="headerlink" title="private E unlinkLast(Node&lt;E&gt; l)"></a>private E unlinkLast(Node&lt;E&gt; l)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert l == last &amp;&amp; l != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = l.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">    l.item = <span class="keyword">null</span>;</span><br><span class="line">    l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    last = prev;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        prev.next = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;移除LinkedList集合中的尾部元素l。<strong>LinkedList底层双向链表操作方法API之一</strong>。操作过程如图6所示：</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1544280614/BlogImages/java-collection/list/LinkedList-unlinkLast-example.png" alt></p>
<div align="center">
<div align="center">图 - 6</div>
&emsp;
</div>

<p>&emsp;&emsp;第3 ~ 4行代码获取尾部元素的内容及其前驱节点的相关信息。第6行代码将尾部元素指向其前驱的指针断开，即alpha阶段的步骤（1）。第7行代码则将last指向当前尾部元素l的前驱节点上，即bravo阶段。如果l节点的前驱为空，且该方法删除是的尾部节点，那么认为该节点会是当前LinkedList集合的唯一一个节点，所以first节点被置为null。反之，则将l的前驱节点的后继指针置为空，这样该前驱节点将会成为真正的尾部元素，即charlie阶段的过程（2）。最后，脱离LinkedList集合的尾部元素element会被返回给方法调用方。</p>
<h4 id="E-unlink-Node-lt-E-gt-x"><a href="#E-unlink-Node-lt-E-gt-x" class="headerlink" title="E unlink(Node&lt;E&gt; x)"></a>E unlink(Node&lt;E&gt; x)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;移除LinkedList集合中的元素x。<strong>LinkedList底层双向链表操作方法API之一</strong>。操作过程如图7所示：</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1544280664/BlogImages/java-collection/list/LinkedList-unlink-example.png" alt></p>
<div align="center">
<div align="center">图 - 7</div>
&emsp;
</div>

<p>&emsp;&emsp;第3 ~ 5行代码获取x元素的内容及其前驱、后继节点的相关信息。第7 ~ 8行代码中，如果x的前驱节点为null，那么x会是当前LinkedList集合的首部元素，那么就将first节点指向x的后继节点（PS：按照移除首部元素的方式处理）。否则，就将x的前驱节点的后继指针指向x的后继节点，即alpha阶段的步骤（1）。同时将x的前驱指针指向null以断开x和x的前驱节点的前驱关系，即alpha阶段的步骤（2）。如果x的后继节点为null，那么认为x元素为当前linkedList集合的尾部元素，那么就将last指向x的前驱节点（PS：按照移除尾部元素的方式处理）。否则，就将x的后继元素的前驱指针指向x的前驱节点，即alpha阶段的步骤（3）。同时将x的后继指针指向null以断开x和x的后继节点的后继关系，即alpha阶段的步骤（4）。最后，脱离LinkedList集合的尾部元素element会被返回给方法调用方，而linkedList集合的状态为bravo阶段所处的状态。</p>
<h4 id="public-E-getFirst"><a href="#public-E-getFirst" class="headerlink" title="public E getFirst()"></a>public E getFirst()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">element</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;得到当前LinkedList集合的首部元素。如果首部元素为null，那么抛出一个<strong>NoSuchElementException</strong>异常。<strong>public E element()</strong>方法完全调用getFirst()方法。</p>
<h4 id="public-E-peek"><a href="#public-E-peek" class="headerlink" title="public E peek()"></a>public E peek()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;得到当前LinkedList集合的首部元素。如果首部元素为null，那么直接返回null（此时集合为空）。方法<strong>public E peekFirst()</strong>和peek()方法方法体完全相同，只是声明不同。</p>
<h4 id="public-E-getLast"><a href="#public-E-getLast" class="headerlink" title="public E getLast()"></a>public E getLast()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> l.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;得到当前LinkedList集合的尾部元素。如果尾部元素为null，则抛出<strong>NoSuchElementException</strong>异常。</p>
<h4 id="public-E-peekLast"><a href="#public-E-peekLast" class="headerlink" title="public E peekLast()"></a>public E peekLast()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : l.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回当前LinkedList集合的尾部元素。如果尾部元素为null，那么直接返回null（此时集合为空）。</p>
<h4 id="public-E-get-int-index"><a href="#public-E-get-int-index" class="headerlink" title="public E get(int index)"></a>public E get(int index)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回当前LinkedList集合中index位置的元素。底层调用<strong>node(int index)</strong>完成操作。</p>
<h4 id="private-void-checkElementIndex-int-index"><a href="#private-void-checkElementIndex-int-index" class="headerlink" title="private void checkElementIndex(int index)"></a>private void checkElementIndex(int index)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">outOfBoundsMsg</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Index: "</span>+index+<span class="string">", Size: "</span>+size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isElementIndex(index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;index下标检查。如果index不符合要求，抛出<strong>IndexOutOfBoundsException</strong>异常。</p>
<h4 id="private-boolean-isElementIndex-int-index"><a href="#private-boolean-isElementIndex-int-index" class="headerlink" title="private boolean isElementIndex(int index)"></a>private boolean isElementIndex(int index)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;index下标检查，避免发生越界溢出的情况。</p>
<h4 id="Node-lt-E-gt-node-int-index"><a href="#Node-lt-E-gt-node-int-index" class="headerlink" title="Node&lt;E&gt; node(int index)"></a>Node&lt;E&gt; node(int index)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;采用顺序访问的方式从首/尾元素逐个访问直到到达index下标位置处，并返回index位置的元素。在访问过程中借鉴了二分查找的思想，通过比较index和$\frac{1}{2}$size 的大小关系决定是从首部进行遍历还是从尾部进行遍历（size为当前LinkedList集合中存储的元素数）来提高效率。</p>
<h4 id="public-E-set-int-index-E-element"><a href="#public-E-set-int-index-E-element" class="headerlink" title="public E set(int index, E element)"></a>public E set(int index, E element)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;用element替换当前LinkedList集合中index位置处的内容。首先检查index的合法性，检查通过后通过<strong>node(int index)</strong>方法得到index位置的原有内容，同时用element替换原有内容。最后返回被替换的原有内容。</p>
<h4 id="public-E-removeFirst"><a href="#public-E-removeFirst" class="headerlink" title="public E removeFirst()"></a>public E removeFirst()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;移除当前LinkedList集合的首部元素。实际调用<strong>unlinkFirst(Node&lt;E&gt; f)</strong>方法完成操作。如果首部元素为null，那么抛出<strong>NoSuchElementException</strong>异常。<strong>public E remove()</strong>方法通过 removeFirst()方法完成首部元素删除。</p>
<h4 id="public-E-pop"><a href="#public-E-pop" class="headerlink" title="public E pop()"></a>public E pop()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;完全调用removeFirst()方法移除首部元素，除此之外无任何处理。该方法在使用LinkedList作为栈存储的场景中使用。</p>
<h4 id="public-E-poll"><a href="#public-E-poll" class="headerlink" title="public E poll()"></a>public E poll()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;移除当前LinkedList集合的首部元素。实际调用<strong>unlinkFirst(Node&lt;E&gt; f)</strong>方法完成操作。如果首部元素为null，那么直接返回null（此时集合为空）。</p>
<h4 id="public-E-pollFirst"><a href="#public-E-pollFirst" class="headerlink" title="public E pollFirst()"></a>public E pollFirst()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;移除当前LinkedList集合的首部元素。实际调用<strong>unlinkFirst(Node&lt;E&gt; f)</strong>方法完成操作。如果首部元素为null，那么直接返回null（此时集合为空）。</p>
<h4 id="public-E-pollLast"><a href="#public-E-pollLast" class="headerlink" title="public E pollLast()"></a>public E pollLast()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkLast(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;移除当前LinkedList集合的尾部元素。实际调用<strong>unlinkLast(Node&lt;E&gt; l)</strong>方法完成操作。如果首部元素为null，那么直接返回null（此时集合为空）。</p>
<h4 id="public-E-removeLast"><a href="#public-E-removeLast" class="headerlink" title="public E removeLast()"></a>public E removeLast()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;移除当前LinkedList集合的尾部元素。实际调用<strong>unlinkLast(Node&lt;E&gt; f)</strong>方法完成操作。如果尾部元素为null，那么抛出<strong>NoSuchElementException</strong>异常。</p>
<h4 id="public-boolean-remove-Object-o"><a href="#public-boolean-remove-Object-o" class="headerlink" title="public boolean remove(Object o)"></a>public boolean remove(Object o)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeFirstOccurrence</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> remove(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;移除当前LinkedList集合中存储的第一个对象o。在执行过程中从<strong>首部元素</strong>开始遍历，如果在遍历过程中第一次遇到了对象o，那么就将其从集合中移除，并返回true。如果当前集合中未曾存储对象o，那么返回false表示当前集合未被修改。<strong>public boolean removeFirstOccurrence(Object o)</strong>方法直接调用<strong>remove(Object o)</strong>完成元素删除操作。</p>
<h4 id="public-E-remove-int-index"><a href="#public-E-remove-int-index" class="headerlink" title="public E remove(int index)"></a>public E remove(int index)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;删除LinkedList集合中index位置处的元素。先通过<strong>node(int index)</strong>方法得到index位置处的元素，然后再通过<strong>E unlink(Node&lt;E&gt; x)</strong>删除元素。</p>
<h4 id="public-boolean-removeLastOccurrence-Object-o"><a href="#public-boolean-removeLastOccurrence-Object-o" class="headerlink" title="public boolean removeLastOccurrence(Object o)"></a>public boolean removeLastOccurrence(Object o)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeLastOccurrence</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;移除当前LinkedList集合中存储的最后一个对象o。在执行过程中从<strong>尾部元素</strong>开始遍历，如果在遍历过程中第一次遇到了对象o，那么就将其从集合中移除，并返回true。如果当前集合中未曾存储对象o，那么返回false表示当前集合未被修改。</p>
<h4 id="public-void-addFirst-E-e"><a href="#public-void-addFirst-E-e" class="headerlink" title="public void addFirst(E e)"></a>public void addFirst(E e)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将元素e加入到当前LinkedList集合首部位置。实际调用<strong>linkFirst(E e)</strong>方法完成操作。</p>
<h4 id="public-boolean-offerFirst-E-e"><a href="#public-boolean-offerFirst-E-e" class="headerlink" title="public boolean offerFirst(E e)"></a>public boolean offerFirst(E e)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将元素e加入到当前LinkedList集合中的首部位置。底层直接调用<strong>addFirst(E e)</strong>方法完成操作。该方法适用于利用LinkedList作为双端队列（Deque operations）的场景中，通过该方法向队列首部输入元素。</p>
<h4 id="public-boolean-offer-E-e"><a href="#public-boolean-offer-E-e" class="headerlink" title="public boolean offer(E e)"></a>public boolean offer(E e)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将元素e加入到当前LinkedList集合中的尾部位置。底层直接调用<strong>add(E e)</strong>方法完成操作。该方法适用于利用LinkedList作为双端队列（Deque operations）的场景中，通过该方法向队列尾部输入元素。</p>
<h4 id="public-boolean-offerLast-E-e"><a href="#public-boolean-offerLast-E-e" class="headerlink" title="public boolean offerLast(E e)"></a>public boolean offerLast(E e)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将元素e加入到当前LinkedList集合的尾部位置上。底层直接调用<strong>addLast(E e)</strong>方法完成操作。该方法适用于利用LinkedList作为双端队列（Deque operations）的场景中，通过该方法向队列尾部输入元素。</p>
<h4 id="public-void-push-E-e"><a href="#public-void-push-E-e" class="headerlink" title="public void push(E e)"></a>public void push(E e)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将元素e加入到当前LinkedList集合中的首部位置。底层直接调用<strong>addFirst(E e)</strong>方法完成操作。该方法适用于利用LinkedList作为栈存储的场景中，通过该方法想栈顶部输入元素。</p>
<h4 id="public-void-addLast-E-e"><a href="#public-void-addLast-E-e" class="headerlink" title="public void addLast(E e)"></a>public void addLast(E e)</h4><pre><code>public void addLast(E e) {
    linkLast(e);
}
</code></pre><p>&emsp;&emsp;将元素e加入到当前LinkedList集合的尾部位置上。实际调用<strong>linkLast(E e)</strong>方法完成操作。</p>
<h4 id="public-boolean-add-E-e"><a href="#public-boolean-add-E-e" class="headerlink" title="public boolean add(E e)"></a>public boolean add(E e)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将元素e加入到当前LinkedList集合的尾部位置上。实际调用<strong>linkLast(E e)</strong>方法完成操作。</p>
<h4 id="public-boolean-addAll-Collection-lt-extends-E-gt-c"><a href="#public-boolean-addAll-Collection-lt-extends-E-gt-c" class="headerlink" title="public boolean addAll(Collection&lt;? extends E&gt; c)"></a>public boolean addAll(Collection&lt;? extends E&gt; c)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将集合c中的元素全部加入到当前LinkedList集合的尾部位置上。实际调用<strong>addAll(int index, Collection&lt;? extends E&gt; c)</strong>方法完成操作。</p>
<h4 id="public-boolean-addAll-int-index-Collection-lt-extends-E-gt-c"><a href="#public-boolean-addAll-int-index-Collection-lt-extends-E-gt-c" class="headerlink" title="public boolean addAll(int index, Collection&lt;? extends E&gt; c)"></a>public boolean addAll(int index, Collection&lt;? extends E&gt; c)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; pred, succ;</span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">        succ = <span class="keyword">null</span>;</span><br><span class="line">        pred = last;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        succ = node(index);</span><br><span class="line">        pred = succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) o;</span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        pred = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = pred;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pred.next = succ;</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size += numNew;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将集合c中的元素加入到LinkedList集合中自index指定的位置起。如果c集合中没有存储任何元素，那么不做处理直接返回false。第9 ~ 16行代码计算index位置处的节点及其前驱节点，如果index指向了集合尾部（index = size），那么操作会在集合尾部执行，这种情况下只会确定前驱节点而认为后继节点为null，否则将前驱节点和后继节点都计算确认完成。</p>
<p>&emsp;&emsp;在通过计算得到index位置处的前驱节点和后继节点信息后，以计算好的前驱节点为基础，依次将c集合中的元素加入当前LinkedList集合中（第18 ~ 26行代码的操作过程）。在c中所有元素全部加入到当前LinkedList集合后，建立与前面计算得到的后继节点的指向关系 — c集合中最后一个元素的后继节点是根据index计算得到的后继节点，同时计算得到的后继节点的前驱节点是c集合中的最后一个元素。最后更新当前LinkedList集合中存储的元素总数并返回true表示确实执行过元素添加操作。</p>
<h4 id="public-void-add-int-index-E-element"><a href="#public-void-add-int-index-E-element" class="headerlink" title="public void add(int index, E element)"></a>public void add(int index, E element)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将元素element加入到当前LinkedList集合中index指定的位置上。先对index做边界检查，检查通过的话根据index指定的位置决定采用<strong>linkLast(E e)</strong>或者<strong>linkBefore(E e, Node&lt;E&gt; succ)</strong>方法完成元素插入。</p>
<h4 id="public-boolean-contains-Object-o"><a href="#public-boolean-contains-Object-o" class="headerlink" title="public boolean contains(Object o)"></a>public boolean contains(Object o)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;判断当前LinkedList集合中是否存储了元素o。如果未存储元素o，则返回false，否则返回true。</p>
<h4 id="public-int-indexOf-Object-o"><a href="#public-int-indexOf-Object-o" class="headerlink" title="public int indexOf(Object o)"></a>public int indexOf(Object o)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回元素o在当前LinkedList集合中第一次被存储的位置。从集合首部元素开始遍历，如果元素o为null，那么返回null在集合中第一次被存储的位置下标，反之则返回非null元素o在集合中第一次被存储的位置。如果集合中不存在元素o，那么返回-1。</p>
<h4 id="public-int-lastIndexOf-Object-o"><a href="#public-int-lastIndexOf-Object-o" class="headerlink" title="public int lastIndexOf(Object o)"></a>public int lastIndexOf(Object o)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = size;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回元素o在当前LinkedList集合中最后一次被存储的位置。从集合尾部元素开始遍历，如果元素o为null，那么返回null在集合中最后一次被存储的位置下标，反之则返回非null元素o在集合中最后一次被存储的位置。如果集合中不存在元素o，那么返回-1。</p>
<h4 id="public-int-size"><a href="#public-int-size" class="headerlink" title="public int size()"></a>public int size()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回当前LinkedList集合中存储的元素数。</p>
<h4 id="public-void-clear"><a href="#public-void-clear" class="headerlink" title="public void clear()"></a>public void clear()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Clearing all of the links between nodes is "unnecessary", but:</span></span><br><span class="line">    <span class="comment">// - helps a generational GC if the discarded nodes inhabit</span></span><br><span class="line">    <span class="comment">//   more than one generation</span></span><br><span class="line">    <span class="comment">// - is sure to free memory even if there is a reachable Iterator</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">        Node&lt;E&gt; next = x.next;</span><br><span class="line">        x.item = <span class="keyword">null</span>;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">        x = next;</span><br><span class="line">    &#125;</span><br><span class="line">    first = last = <span class="keyword">null</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;清空当前LinkedList集合中的所有元素。</p>
<h4 id="public-ListIterator-lt-E-gt-listIterator-int-index"><a href="#public-ListIterator-lt-E-gt-listIterator-int-index" class="headerlink" title="public ListIterator&lt;E&gt; listIterator(int index)"></a>public ListIterator&lt;E&gt; listIterator(int index)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回一个基于当前LinkedList集合从index位置开始遍历元素的迭代器。</p>
<h4 id="public-Object-clone"><a href="#public-Object-clone" class="headerlink" title="public Object clone()"></a>public Object clone()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;E&gt; clone = superClone();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Put clone into "virgin" state</span></span><br><span class="line">    clone.first = clone.last = <span class="keyword">null</span>;</span><br><span class="line">    clone.size = <span class="number">0</span>;</span><br><span class="line">    clone.modCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize clone with our elements</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">        clone.add(x.item);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> LinkedList&lt;E&gt; <span class="title">superClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (LinkedList&lt;E&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回一个LinkedList集合的浅度复制对象。该方法只复制LinkedList对象自身，对于其内部存储的元素内容并不会参与复制过程，所以通过复制操作得到的副本集合中存储的元素内容是通过遍历添加得到的（第10 ~ 11行代码的操作过程）。</p>
<h4 id="public-Iterator-lt-E-gt-descendingIterator"><a href="#public-Iterator-lt-E-gt-descendingIterator" class="headerlink" title="public Iterator&lt;E&gt; descendingIterator()"></a>public Iterator&lt;E&gt; descendingIterator()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DescendingIterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DescendingIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ListItr itr = <span class="keyword">new</span> ListItr(size());</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> itr.hasPrevious();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> itr.previous();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        itr.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回一个基于整个LinkedList集合的逆序迭代器。该迭代器的执行方向是单向的，执行顺序是从尾部向首部进行遍历。该实现类实现了Iterator&lt;E&gt;接口的三个方法，而实际调用的是ListItr实现类的获取前驱元素的方法来完成逆向集合遍历。</p>
<h4 id="public-Object-toArray"><a href="#public-Object-toArray" class="headerlink" title="public Object[] toArray()"></a>public Object[] toArray()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    Object[] result = <span class="keyword">new</span> Object[size];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">        result[i++] = x.item;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将当前LinkedList集合中存储的所有元素存入一个Object[] 数组中并返回。</p>
<h4 id="public-lt-T-gt-T-toArray-T-a"><a href="#public-lt-T-gt-T-toArray-T-a" class="headerlink" title="public &lt;T&gt; T[] toArray(T[] a)"></a>public &lt;T&gt; T[] toArray(T[] a)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">        a = (T[])java.lang.reflect.Array.newInstance(</span><br><span class="line">        a.getClass().getComponentType(), size);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    Object[] result = a;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">        result[i++] = x.item;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">        a[size] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将当前LinkedList集合中存储的所有元素存储到数组a中并返回a。如果数组的长度不足以容纳集合中的所有元素，那么会以a的类型重新分配一个数组空间来容纳集合中所有元素。之后将集合中的所有元素按照从首部到尾部的顺序依次存储到数组中。在执行完存储操作后数组中仍有空余空间，那么就将数组中存储元素的下一个空间位置置为null，这么做有利于快速地知道集合中存储的元素个数（在集合中没有存储null元素的情况下）。</p>
<h4 id="private-void-writeObject-java-io-ObjectOutputStream-s"><a href="#private-void-writeObject-java-io-ObjectOutputStream-s" class="headerlink" title="private void writeObject(java.io.ObjectOutputStream s)"></a>private void writeObject(java.io.ObjectOutputStream s)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Write out any hidden serialization magic</span></span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out size</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">        s.writeObject(x.item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;LinkedList集合的自定义序列化方法。在实际序列化操作过程中会调用LinkedList自己的序列化方法来完成序列化操作。</p>
<h4 id="private-void-readObject-java-io-ObjectInputStream-s"><a href="#private-void-readObject-java-io-ObjectInputStream-s" class="headerlink" title="private void readObject(java.io.ObjectInputStream s)"></a>private void readObject(java.io.ObjectInputStream s)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// Read in any hidden serialization magic</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in size</span></span><br><span class="line">    <span class="keyword">int</span> size = s.readInt();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        linkLast((E)s.readObject());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;LinkedList集合的自定义反序列化方法。在反序列化过程中会按照LinkedList自己的反序列化过程来完成反序列化操作。</p>
<p>&emsp;</p>
<h2 id="Node-lt-E-gt"><a href="#Node-lt-E-gt" class="headerlink" title="Node&lt;E&gt;"></a>Node&lt;E&gt;</h2><p>&emsp;&emsp;在LinkedList中，底层元素存储结构是一个Node节点，每个节点有一个前驱节点指向当前节点的前一个节点，有一个后继节点指向当前节点的下一个节点。除此之外，还有一个字段来维护当前节点存储的内容。具体内容代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="private-class-ListItr-implements-ListIterator-lt-E-gt"><a href="#private-class-ListItr-implements-ListIterator-lt-E-gt" class="headerlink" title="private class ListItr implements ListIterator&lt;E&gt;"></a>private class ListItr implements ListIterator&lt;E&gt;</h2><p>&emsp;&emsp;LinkedList集合自定义的迭代器实现类，相关实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; lastReturned = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; next;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nextIndex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    ListItr(<span class="keyword">int</span> index) &#123;</span><br><span class="line">        <span class="comment">// assert isPositionIndex(index);</span></span><br><span class="line">        next = (index == size) ? <span class="keyword">null</span> : node(index);</span><br><span class="line">        nextIndex = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextIndex &lt; size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">if</span> (!hasNext())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">        lastReturned = next;</span><br><span class="line">        next = next.next;</span><br><span class="line">        nextIndex++;</span><br><span class="line">        <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextIndex &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">if</span> (!hasPrevious())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">        lastReturned = next = (next == <span class="keyword">null</span>) ? last : next.prev;</span><br><span class="line">        nextIndex--;</span><br><span class="line">        <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextIndex - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line"></span><br><span class="line">        Node&lt;E&gt; lastNext = lastReturned.next;</span><br><span class="line">        unlink(lastReturned);</span><br><span class="line">        <span class="keyword">if</span> (next == lastReturned)</span><br><span class="line">            next = lastNext;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nextIndex--;</span><br><span class="line">        lastReturned = <span class="keyword">null</span>;</span><br><span class="line">        expectedModCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line">        lastReturned.item = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        lastReturned = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">            linkLast(e);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            linkBefore(e, next);</span><br><span class="line">        nextIndex++;</span><br><span class="line">        expectedModCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;ListItr的构造函数会传入一个index参数。根据index会找到该index位置处的元素节点，该元素节点是迭代器遍历的起点。同时初始化nextIndex的值，该字段标记了迭代执行到了什么位置。</p>
<p>&emsp;&emsp;根据nextIndex和size的大小关系来判断当前迭代是否已经到了集合尾部位置。根据nextIndex和0的大小关系判断当前迭代是否已经到了集合首部位置。</p>
<p>&emsp;&emsp;如果想遍历得到当前节点的下一个节点，可以调用方法next()。当前next指针指示的即是需要返回的节点，取得当前next指针指向的内容，同时将next指针指向next的后继节点来完成next向后遍历一个节点的操作。最后更新nextIndex的值并返回取得的元素内容。</p>
<p>&emsp;&emsp;如果想得到当前节点的前驱节点，可以调用方法previous()。在完成快速失败和边界检查以后获取到当前next节点的前驱节点。如果当前next节点为null，那么说明当前next的前驱节点是集合的last节点，所以直接返回last节点上的内容。</p>
<p>&emsp;&emsp;如果想在某次调用next()或者previous()方法之后删除某个节点，可以调用remove()方法。在删除之前得到当前节点的后继节点，之后从当前LinkedList集合中删除当前节点。如果迭代器执行的previous()方法遍历，那么将当前被移除节点的后继节点的前驱指针指向当前next节点。如图8所示：</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1544329940/BlogImages/java-collection/list/LinkedList-ListIterator-remove-previous.png" alt></p>
<div align="center">
<div align="center">图 - 8</div>
&emsp;
</div>

<p>&emsp;&emsp;alpha阶段是迭代器初始化完成后的状态，此时只有next指针和nextIndex下标指示器。bravo阶段是迭代器完成了一次previous()方法操作之后的结果。此时lastReturn和next指向了同一个元素，nextIndex指示的下标就是next元素的下标位置。执行remove()操作时，删除lastReturn节点的元素，同时将next指针指向lastReturn元素的后继节点。即charlie阶段。此时next节点指示的元素的下标位置等同于被删除节点的下标位置，而next和nextIndex指向的会是同一个元素节点。</p>
<p>&emsp;&emsp;反之，迭代器执行的是next()方法遍历，则将nextIndex的值减一，表示迭代位置由于元素移除而向前偏移了一个位置。如图9所示：</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1544330769/BlogImages/java-collection/list/LinkedList-ListIterator-remove-next.png" alt></p>
<div align="center">
<div align="center">图 - 9</div>
&emsp;
</div>

<p>&emsp;&emsp;alpha阶段是迭代器初始化完成后的状态，此时只有next指针和nextIndex下标指示器。bravo阶段是迭代器完成了一次next()方法操作之后的结果。此时lastReturn和next指向了不同元素，nextIndex指示的下标就是next元素的下标位置。执行remove()操作时，删除lastReturn节点的元素，同时将nextIndex的值减1。即charlie阶段。此时next节点指示的元素未发生变化，只是该节点元素的逻辑位置下标前移了一位，为了保证next和nextIndex指示的是同一个元素，所以需要对nextIndex做减一操作。</p>
<p>&emsp;&emsp;相关移除操作完成后，最后将lastReturned置为null，保证不会连续执行remove操作，并更新expectedModCount。</p>
<p>&emsp;&emsp;如果想在某次调用next()或者previous()方法之后更新某个节点的内容，可以调用set(E e)方法。该方法直接将当前节点的值进行替换。</p>
<p>&emsp;&emsp;如果想在某次调用next()或者previous()方法之后加入一个元素e，可以调用add(E e)方法。如果当前next已经到达了集合尾部位置，那么就按照将元素加入集合尾部的思路进行处理，否则按照将元素加入到next元素之前的思路进行处理。最后最后更新nextIndex和expectedModCount的值。</p>
<p>&emsp;</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li><p><strong>为什么说fail-fast无法得到保证</strong></p>
<p>&emsp;&emsp;“快速失败”也就是fail-fast，它是Java集合的一种错误检测机制。当多个线程对集合进行结构上的改变的操作时，就有可能会产生fail-fast机制。如果两个及以上线程对同一个集合的元素做了结构化修改，就有可能触发快速失败校验并抛出<strong>ConcurrentModificationException</strong>异常。在多/单线程环境里，Iterator是工作在一个独立的线程中，并且拥有一个 mutex 锁。Iterator被创建之后会建立一个指向原来对象的单链索引表，当原来的对象经历过结构化修改时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候就找不到要迭代的对象，所以会马上抛出ConcurrentModificationException 异常。</p>
<p>&emsp;&emsp;如果在单线程环境下，集合在被遍历的过程中没有通过迭代器提供的API对集合做结构化修改，那么就会抛出ConcurrentModificationException 异常。如果是在多线程环境下，当一个线程在遍历这个集合的同时，另一个线程修改了这个集合的结构。这种情况下也会抛出ConcurrentModificationException 异常。</p>
<p>&emsp;&emsp;但是该异常不是任何情况下都会触发的。因为modCount在多线程环境中由于没有synchronized或者volatile修饰，所以可能会存在多线程下某个线程作出的结构化修改导致另外一个线程无法及时得到更新后的modCount内容，从而导致不会检测到并抛出ConcurrentModificationException 异常。</p>
<p>&emsp;&emsp;如果需要解决该问题，那么可以考虑使用<strong>java.util.concurrent.CopyOnWriteArrayList&lt;E&gt;</strong>，这个实现是ArrayList的一个线程安全版本。CopyOnWriteArrayList是一个实现了List接口，底层依赖数组作为存储结构的线程安全实现，其从数据结构、定义等方面都和ArrayList完全一致，其中所有可变操作（add、set 等等）都是通过对底层数组进行一次新的复制来实现。但是CopyOnWriteArrayList也有缺陷，那就是由于每次修改容器都会复制底层数组，需要很大的开销，特别是容器规模很大的时候。所以，只有当迭代操作远远多于修改操作的时候，才使用这个容器。</p>
</li>
</ol>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>楚云之南. <a href="https://www.jb51.net/article/79739.htm" target="_blank" rel="noopener">解析Java的迭代器中的fast-fail错误检测机制</a> [E]</li>
<li>h2pl. <a href="https://h2pl.github.io/2018/05/09/collection3/" target="_blank" rel="noopener">Java集合详解3：Iterator，fail-fast机制与比较器</a> [E]</li>
<li>Hollis. <a href="https://www.hollischuang.com/archives/33" target="_blank" rel="noopener">Java中的fail-fast机制</a> [E]</li>
<li>chenssy. <a href="https://blog.csdn.net/chenssy/article/details/38151189" target="_blank" rel="noopener">Java提高篇（三四）——-fail-fast机制</a> [E]</li>
<li>清浅池塘. <a href="https://zhuanlan.zhihu.com/p/28101975" target="_blank" rel="noopener">LinkedList初探</a> [E]</li>
</ol>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Collection 01 - List</title>
    <url>/2018/java-Collection-List.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;在Java语言规范中，List作为Java集合框架中的一员，提供了对同类型数据进行存储、插入、删除和查找等需求的实现过程。其实现机制和特点使得List是一个有序的，可存储重复数据的数据结构。本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;List是Java集合体系中的成员之一，直接继承于Collection。同Collection一样，List本身只是一个接口定义，其定义了对List进行操作的方法API。List是一个有序的（即输入顺序=存储顺序=输出顺序），可存放重复数据的数据结构，甚至可以向其中存储null元素。List的一些特点如下：</p>
<ol>
<li>List元素的位置下标都从0开始递增，且提供了四种方法来根据下标值获取元素，但是由于实现的不同，根据下标获取元素的时间复杂度可能随List集合元素数量成正比关系（例如LinkedList）。鉴于此，在不确定List实现方式的情况下建议采用iterate的方式获取数组元素。</li>
<li>List还可以通过两种方法高效地在集合中的任意位置插入或者移除多个元素。</li>
<li>List会限制保存在其中的对象类型，有些实现会限制null元素，而其他一些实现会限制特定的数据对象类型。尝试向这种List集合实现中加入不满足条件的元素会对外抛出异常。尝试查找不满条件的元素时根据实现的不同可能会对外抛出异常，或者直接返回false标识查找失败。</li>
</ol>
<p>&emsp;&emsp;常见的List实现包括<a href>AbstractList</a>、<a href>ArrayList</a>、<a href>LinkedList</a>、<a href>Vector</a>、<a href>AbstractSequentialList</a>、<a href>Stack</a>等。其结构如图1所以：</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1543413660/BlogImages/java-collection/list/List-guide.png" alt></p>
<div align="center">
<div align="center">图 - 1</div>
&emsp;
</div>

<p>关于上述几个具体实现类之间，分别有其适应的应用场景和特点：</p>
<ul>
<li><p>ArrayList</p>
<p>&emsp;&emsp;ArrayList直接继承于AbstractList，实现了List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable四个接口;</p>
<p>&emsp;&emsp;基于数组实现，在初始化时会指定数组长度，默认为0。可以执行扩容操作，扩容规则是按照当前数组容量的1.5倍进行扩容；</p>
<p>&emsp;&emsp;由于是数组实现，所以具有随机访问元素的特点。可以在常量时间里完成元素访问，但是元素插入效率不高，需要将插入位置（如果不是在尾部插入的话）及之后的元素统一后移以释放插入空间；</p>
<p>&emsp;&emsp;多线程环境中无法保证线程安全，不太适用于多线程环境。如果必须要用，那么需要用Collections.synchronizedList(new ArrayList(…))做一层包装；</p>
</li>
<li><p>LinkedList</p>
<p>&emsp;&emsp;LinkedList直接继承于AbstractSequentialList，除了List&lt;E&gt;, Cloneable, Serializable接口外还实现了Deque&lt;E&gt;接口。而AbstractSequentialList则直接继承于AbstractList；</p>
<p>&emsp;&emsp;基于双端链表实现，没有初始长度限制，实际上长度限制仅受限于内存容量。也没有扩容操作等；</p>
<p>&emsp;&emsp;由于是链表实现，所以具有顺序访问的特点。访问元素时只能从首部/尾部元素逐个遍历直至到达目标元素，时间复杂度在O(n)。但是元素插入效率高；</p>
<p>&emsp;&emsp;多线程环境中无法保证线程安全，不太适用于多线程环境。如果必须要用，那么需要用Collections.synchronizedList(new LinkedList(…))做一层包装；</p>
</li>
<li><p>Vector</p>
<p>&emsp;&emsp;Vector直接继承于AbstractList，实现了List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable四个接口;</p>
<p>&emsp;&emsp;同样基于数组实现，在初始化时会指定数组长度，默认为10。可进行扩容操作，扩容长度由内部字段<strong>capacityIncrement</strong>指定，如果在初始化时未指定该字段，那么会按照当前数组容量的两倍执行扩容处理；</p>
<p>&emsp;&emsp;同样因为采用了数组实现，所以具有随机访问元素的特点。可以在常量时间里完成元素访问，但是元素插入效率不高，需要将插入位置（如果不是在尾部插入的话）及之后的元素统一后移以释放插入空间；</p>
<p>&emsp;&emsp;是ArrayList的线程安全版本。底层实现和依赖数据结构基本相同，由于在方法上采用了synchronized关键字来保证多线程环境下的线程安全要求。</p>
</li>
<li><p>Stack</p>
<p>&emsp;&emsp;Stack是Vector的直接实现子类。具有Vector的所有特性，但是Stack是一种具有先进后出（FILO）属性的数据结构，常用于栈等场景中。</p>
</li>
</ul>
<p>&emsp;</p>
<h2 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h2><div class="table-container">
<table>
<thead>
<tr>
<th>方法声明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>int size();</td>
<td>返回list集合中的元素总数</td>
</tr>
<tr>
<td>boolean isEmpty();</td>
<td>判断list集合是否为空，为空时返回true</td>
</tr>
<tr>
<td>boolean contains(Object o);</td>
<td>判断list集合中是否含有元素o</td>
</tr>
<tr>
<td>Iterator&lt;E&gt; iterator();</td>
<td>返回可以游历list集合的一个迭代器对象</td>
</tr>
<tr>
<td>Object[] toArray();</td>
<td>将当前list集合中的元素以数组方式返回</td>
</tr>
<tr>
<td>&lt;T&gt; T[] toArray(T[] a);</td>
<td>将当前list集合中的元素以数组方式存储到参数a中</td>
</tr>
<tr>
<td>boolean add(E e);</td>
<td>加入一个元素到list集合尾部</td>
</tr>
<tr>
<td>boolean remove(Object o);</td>
<td>从list集合中移除一个元素</td>
</tr>
<tr>
<td>boolean containsAll(Collection&lt;?&gt; c);</td>
<td>当前list集合中是否包含集合c的所有元素</td>
</tr>
<tr>
<td>boolean addAll(Collection&lt;? extends E&gt; c);</td>
<td>将集合c中的元素都加入到list集合中</td>
</tr>
<tr>
<td>boolean addAll(int index, Collection&lt;? extends E&gt; c);</td>
<td>将集合c中的元素都加入到list集合中自index位置起的位置中</td>
</tr>
<tr>
<td>boolean removeAll(Collection&lt;?&gt; c);</td>
<td>从list集合中移除c中所有元素</td>
</tr>
<tr>
<td>boolean retainAll(Collection&lt;?&gt; c);</td>
<td>保留当前list集合中出现在c中的元素，其他元素都移除</td>
</tr>
<tr>
<td>void clear();</td>
<td>清空list集合</td>
</tr>
<tr>
<td>boolean equals(Object o);</td>
<td>相等性判断</td>
</tr>
<tr>
<td>int hashCode();</td>
<td>生成list集合的散列值</td>
</tr>
<tr>
<td>E get(int index);</td>
<td>根据下标获取元素</td>
</tr>
<tr>
<td>E set(int index, E element);</td>
<td>替换下标位置index处的元素为element</td>
</tr>
<tr>
<td>void add(int index, E element);</td>
<td>将元素加入到下标位置index处</td>
</tr>
<tr>
<td>E remove(int index);</td>
<td>移除下标位置index出的元素</td>
</tr>
<tr>
<td>int indexOf(Object o);</td>
<td>返回对象在list集合中第一次出现的下标位置</td>
</tr>
<tr>
<td>int lastIndexOf(Object o);</td>
<td>返回对象在list集合中最后一次出现的下标位置</td>
</tr>
<tr>
<td>ListIterator&lt;E&gt; listIterator();</td>
<td>返回一个list迭代器</td>
</tr>
<tr>
<td>ListIterator&lt;E&gt; listIterator(int index);</td>
<td>返回一个list迭代器</td>
</tr>
<tr>
<td>List&lt;E&gt; subList(int fromIndex, int toIndex);</td>
<td>得到自fromIndex到toIndex位置的子集合</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li><p><strong>List中提供的subList的缺陷</strong></p>
<p>&emsp;&emsp;subList是基于原始List集合产生的，二者共同依赖于一套底层数组结构。如果对subList做了修改，那么修改内容会同步反映在原始List集合上，会原始List做的非结构化修改也会反映到subList上。</p>
<p>&emsp;&emsp;此外，subList也具有快速失败的检查机制。如果在生成subList之后对原始List集合做了结构化修改，那么在访问subList时会抛出<strong>ConcurrentModificationException</strong>异常。</p>
</li>
</ol>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>RUNOOB.COM. <a href="http://www.runoob.com/java/java-collections.html" target="_blank" rel="noopener">Java 集合框架</a> [E]</li>
<li>J Steven Perry. <a href="https://www.ibm.com/developerworks/cn/java/j-perry-java-collections/index.html" target="_blank" rel="noopener">第 10 单元：Java 集合</a> [E]</li>
<li>ORACLE. <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/collections/overview.html" target="_blank" rel="noopener">Collections Framework Overview</a> [E]</li>
</ol>
<p>   &emsp;<br>   &emsp;<br>   &emsp;<br>   &emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Map 01 - Map</title>
    <url>/2018/java-Collection-Map.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;在Java语言规范中，Map作为Java集合框架中的一员，提供了对同类型数据进行存储、插入、删除和查找等需求的实现过程。其实现机制和特点使得Map是一个无序的（部分实现可以保证顺序），不可存储相同key的数据结构。本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;Map是Java集合框架体系中的成员之一，和Collection相互独立且两者地位平等。Map本身只是一个接口定义，其定义了对Map进行操作的方法API，且所有的map实现类都会实现Map接口定义的方法。</p>
<p>&emsp;&emsp;Map是一个保存键值对映射的数据结构，map不允许维护重复的key，且每个key最多只能映射一个value。Map接口完全取代了抽象类Dictionary类。Map提供了三种浏览集合内数据的方式：键集合、值集合和键值对集合。像TreeMap这样的实现类可以保证元素遍历的顺序，而像HashMap这样的实现类则无法保证元素遍历的顺序，也就是说其是一个无序结构。需要注意的是，Map的key如果存储的是可变的对象，那么由于equals()方法的影响无法保证根据可变对象可以正确的存储和获取Map集合中的元素。除此之外，也不允许map集合以其自身作为key存储到map集合中（equals()和hashCode()方法无法保证）。</p>
<p>&emsp;&emsp;通用的map实现需要提供两种标准的构造器：一个是无参构造器，用来构建一个空map集合。另一个是只含有一个以map作为参数的构造器，这个构造方法允许用户实现map复制。</p>
<p>&emsp;&emsp;有些实现类对维护的key和value值会有一些限制。例如，有的实现禁止null类型的key和value值，有的实现则限制了key的类型。尝试加入key-value映射会抛出NullPointerException或者ClassCastException异常。尝试查找违反规则的key或者value会抛出异常或者直接返回false。</p>
<p>&emsp;&emsp;Map接口的常见实现有<a href>AbstractMap</a>、<a href>HashMap</a>、<a href>ConcurrentHashMap</a>、<a href>LinkedHashMap</a>、<a href>Hashtable</a>、TreeMap，而TreeMap则实现了NavigableMap和SortedMap声明的一系列方法。其结构如图1所示：</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1544529859/BlogImages/java-collection/map/Map-guide.png" alt></p>
<div align="center">
<div align="center">图 - 1</div>
&emsp;
</div>


<p>关于上述几个具体实现类之间，分别有其适应的应用场景和特点：</p>
<ul>
<li><strong>HashMap</strong>：<ol>
<li>HashMap是一个key不可重复的集合结构；</li>
<li>遍历HashMap时，从底层数组首部依次向后遍历；</li>
<li>底层实现依赖于数组，查找元素可以保证常量时间的性能，插入和删除需要的时间和集合存储的键值对数量成比例；</li>
<li>HashMap需要考虑扩容情况，扩容规则是按照当前容量的两倍进行扩容；</li>
<li>HashMap不是一个线程安全的集合实现；</li>
<li>HashMap可以允许key、value为null，如果key为null，那么该键值对会存储在内部数组的第一个下标位置上；</li>
<li>加入到HashMap的元素只需要保证hashcode()和equals()方法被实现即可（默认实现或者自定义实现）。不需要实现Comparable或者Comparator接口；</li>
</ol>
</li>
<li><strong>LinkedHashMap</strong>：<ol>
<li>LinkedHashMap是一个有序的，key不可重复的集合结构。其顺序默认为元素插入顺序，但是也具有访问顺序的特性（最近被访问的元素位于集合的尾部位置，即LRU）；</li>
<li>底层依赖于链表，查找元素时需要逐个遍历，时间开销和链表长度成比例，元素插入和移除可以保证常量时间内完成；</li>
<li>LinkedHashMap同样存在扩容过程；</li>
<li>LinkedHashMap同样也不是一个线程安全的集合实现；</li>
<li>LinkedHashMap允许key、value为null；</li>
<li>加入到LinkedHashMap的元素只需要保证hashcode()和equals()方法被实现即可（默认实现或者自定义实现）。不需要实现Comparable或者Comparator接口；</li>
</ol>
</li>
<li><strong>Hashtable</strong>：<ol>
<li>Hashtable是一个key不可重复的集合；</li>
<li>遍历Hashtable时，从底层数组尾部依次向前遍历；</li>
<li>底层实现依赖于数组，具体实现和HashMap类似；</li>
<li>Hashtable需要考虑扩容情况，扩容规则是按照当前容量的两倍与1的和进行扩容；</li>
<li>Hashtable是HashMap的线程安全版本；</li>
<li>Hashtable的key和value均不允许为null；</li>
<li>加入到Hashtable的元素只需要保证hashcode()和equals()方法被实现即可（默认实现或者自定义实现）。不需要实现Comparable或者Comparator接口；</li>
</ol>
</li>
<li><strong>TreeMap</strong>：<ol>
<li>TreeMap是一个key不可重复的集合；</li>
<li>遍历TreeMap的元素时，要么按照自然排序进行遍历（集合内元素实现的Comparable接口），要么按照特定的规则进行遍历（集合内元素实现的Comparator接口）；</li>
<li>底层实现依赖于红黑树结构，查找、插入和删除性能都可以达到O($ \lg n $)；</li>
<li>TreeMap不需要考虑扩容。但是在元素插入后需要重新调整树结构以保持红黑树的性质；</li>
<li>TreeMap也不是一个线程安全的集合实现；</li>
<li>TreeMap不允许key为null，但是value可以为null；</li>
<li>加入到TreeMap的元素需要实现Comparable或者Comparator接口，否则元素无法正常加入到集合中；</li>
</ol>
</li>
<li><strong>ConcurrentHashMap</strong>：<ol>
<li>ConcurrentHashMap是一个key不可重复的集合；</li>
<li>遍历ConcurrentHashMap时，从底层数组尾部依次向前遍历;</li>
<li>底层实现依赖于数组，数组元素是Segment实例，每个Segment实例内部又维护了一个HashEntry数组。类似于书本分页设计，一个Segment实例类似于一本书的一页，而Segment实例内部的HashEntry数组类似于每页中的每一行；</li>
<li>ConcurrentHashMap需要考虑扩容，在扩容时针对的是某个具体的segment实例内部的HashEntry数组进行扩容；</li>
<li>ConcurrentHashMap是HashMap的另一个线程安全的实现版本；</li>
<li>ConcurrentHashMap可以允许多个线程同时对集合内的不同元素进行锁定和处理，如果是对同一个键值对实体或者同一个Segment实例内部的键值对实体进行处理，那么依旧存在锁抢占，即同一时刻只有线程可以访问一个键值对实体或者一个特定的segment内部的HashEntry数组；</li>
<li>加入到ConcurrentHashMap的元素只需要保证hashcode()和equals()方法被实现即可（默认实现或者自定义实现）。不需要实现Comparable或者Comparator接口；</li>
</ol>
</li>
</ul>
<p>&emsp;</p>
<h2 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h2><div class="table-container">
<table>
<thead>
<tr>
<th>方法声明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>Map.Entry&lt;K,V&gt; lowerEntry(K key)</td>
<td>返回严格小于key的最大key的键值对映射</td>
</tr>
<tr>
<td>K lowerKey(K key)</td>
<td>返回严格小于key的最大key</td>
</tr>
<tr>
<td>Map.Entry&lt;K,V&gt; floorEntry(K key)</td>
<td>返回小于等于key的最大key的键值对映射</td>
</tr>
<tr>
<td>K floorKey(K key)</td>
<td>返回小于等于key的最大key</td>
</tr>
<tr>
<td>Map.Entry&lt;K,V&gt; ceilingEntry(K key)</td>
<td>返回大于等于key的最小key的键值对映射</td>
</tr>
<tr>
<td>K ceilingKey(K key)</td>
<td>返回大于等于key的最小key</td>
</tr>
<tr>
<td>Map.Entry&lt;K,V&gt; higherEntry(K key)</td>
<td>返回严格大于key的最小key的键值对映射</td>
</tr>
<tr>
<td>K higherKey(K key)</td>
<td>返回严格大于key的最小key</td>
</tr>
<tr>
<td>Map.Entry&lt;K,V&gt; firstEntry()</td>
<td>返回当前map集合中key最小的键值对映射</td>
</tr>
<tr>
<td>Map.Entry&lt;K,V&gt; lastEntry()</td>
<td>返回当前map集合中key最大的键值对映射</td>
</tr>
<tr>
<td>Map.Entry&lt;K,V&gt; pollFirstEntry()</td>
<td>取出并返回当前map集合中key最小的键值对映射</td>
</tr>
<tr>
<td>Map.Entry&lt;K,V&gt; pollLastEntry()</td>
<td>取出并返回当前map集合中key最大的键值对映射</td>
</tr>
<tr>
<td>NavigableMap&lt;K,V&gt; descendingMap()</td>
<td>返回当前map集合的一个逆序集合</td>
</tr>
<tr>
<td>NavigableMap&lt;K,V&gt; navigableKeySet()</td>
<td>返回当前map集合的key值集合</td>
</tr>
<tr>
<td>NavigableMap&lt;K,V&gt; descendingKeySet()</td>
<td>返回当前map集合的key值一个逆序集合</td>
</tr>
<tr>
<td>NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive, K toKey,   boolean toInclusive)</td>
<td>返回当前map集合中自fromKey到toKey的子集合，由fromInclusive和toInclusive指定是否包含fronKey和toKey</td>
</tr>
<tr>
<td>NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive)</td>
<td>返回小于等于toKey的集合，由inclusive指定是否等于toKey</td>
</tr>
<tr>
<td>NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive)</td>
<td>返回大于等于fromKey的集合，由inclusive指定是否等于fromKey</td>
</tr>
<tr>
<td>SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey)</td>
<td>返回当前map集合中自fromKey（包含）到toKey（不包含）的子集合。</td>
</tr>
<tr>
<td>SortedMap&lt;K,V&gt; headMap(K toKey)</td>
<td>返回小于toKey的集合</td>
</tr>
<tr>
<td>SortedMap&lt;K,V&gt; tailMap(K fromKey)</td>
<td>返回大于fromKey的集合</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li>NIL</li>
</ol>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>RUNOOB.COM. <a href="http://www.runoob.com/java/java-collections.html" target="_blank" rel="noopener">Java 集合框架</a> [E]</li>
<li>J Steven Perry. <a href="https://www.ibm.com/developerworks/cn/java/j-perry-java-collections/index.html" target="_blank" rel="noopener">第 10 单元：Java 集合</a> [E]</li>
<li>ORACLE. <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/collections/overview.html" target="_blank" rel="noopener">Collections Framework Overview</a> [E]</li>
</ol>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Map 08 - Segment</title>
    <url>/2018/java-Collection-Segment.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;关于<em> <strong>java.util.concurrent.ConcurrentHashMap.Segment&lt;K, V&gt;</strong> </em>的部分笔记，Segment是ConcurrentHashMap的内部类，也是ConcurrentHashMap集合中存储键值对实体的底层数据结构。本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;Segment是一个特殊的散列表。这个类继承了ReentrantLock，因此Segment自身具有锁和解锁的特性，可以在希望的场景中取得锁和释放锁，以此来保证多线程环境下的线程安全。</p>
<p>&emsp;&emsp;在ConcurrentHashMap的底层是一个Segment数组，每个元素都是一个Segment节点。而每个Segment节点内部维护了一个HashEntry对象，ConcurrentHashMap中的键值对都是存储在某个具体的Segment节点的HashEntry数组内。每个线程会对一个特定的Segment元素获取锁，也就是说，不同的线程会操作不同的Segment元素。在读取元素时，不会对Segment元素加锁，只有向集合中写入数据时才会尝试获取锁。Segment结构如图1所示：</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1545100740/BlogImages/java-collection/map/ConcurrentHashMap-Segment-demo-example.png" alt></p>
<div align="center">
<div align="center">图 - 1</div>
&emsp;
</div>

<p>&emsp;</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ConcurrentHashMap&lt;E&gt;</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.util.AbstractMap&lt;K,V&gt;</span><br><span class="line">    --java.util.concurrent.ConcurrentHashMap&lt;K,V&gt;</span><br><span class="line">      --java.util.concurrent.ConcurrentHashMap.Segment&lt;K,V&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><div class="table-container">
<table>
<thead>
<tr>
<th>类名</th>
<th>实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>Segment&lt;E, V&gt;</td>
<td>Serializable, Lock</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="Segment"><a href="#Segment" class="headerlink" title="Segment"></a>Segment</h2><h3 id="Constructor-Summary"><a href="#Constructor-Summary" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="Segment-float-lf-int-threshold-HashEntry-lt-K-V-gt-tab"><a href="#Segment-float-lf-int-threshold-HashEntry-lt-K-V-gt-tab" class="headerlink" title="Segment(float lf, int threshold, HashEntry&lt;K,V&gt;[] tab)"></a>Segment(float lf, int threshold, HashEntry&lt;K,V&gt;[] tab)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Segment(<span class="keyword">float</span> lf, <span class="keyword">int</span> threshold, HashEntry&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = lf;</span><br><span class="line">    <span class="keyword">this</span>.threshold = threshold;</span><br><span class="line">    <span class="keyword">this</span>.table = tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个空Segment实例，指定加载因子、扩容限制阈值和内部的HashEntry数组。</p>
<h3 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="final-V-put-K-key-int-hash-V-value-boolean-onlyIfAbsent"><a href="#final-V-put-K-key-int-hash-V-value-boolean-onlyIfAbsent" class="headerlink" title="final V put(K key, int hash, V value, boolean onlyIfAbsent)"></a>final V put(K key, int hash, V value, boolean onlyIfAbsent)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> : scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将key=value键值对存储到当前segment实体的HashEntry集合中。第2行代码会尝试对当前segment获取锁控制。如果成功得到了锁，那么就直接执行后续后续代码，如果当前方法被其他锁占有，那么等待，直到当前线程得到锁并返回一个node对象（有可能是其他线程插入的，也有可能是当前线程自己生成的）。</p>
<p>&emsp;&emsp;根据hash值计算出node在当前HashEntry数组中的下标位置，如果该下标位置尚未存储HashEntry实体，且node已经生成（如果没有生成的话，第26行代码负责生成一个），那么首先通过rehash()方法判断是否需要执行扩容操作，之后将新生成的node节点存入当前segment的HashEntry数组中。如果该下标位置已经存储了HashEntry实体，那么循环遍历该链表集合，检查是否存在可以匹配key的键值对映射，如果存在，根据onlyIfAbsent字段决定是否需要替换。</p>
<p>&emsp;&emsp;最后释放当前线程对方法的占用。</p>
<h4 id="private-void-rehash-HashEntry-lt-K-V-gt-node"><a href="#private-void-rehash-HashEntry-lt-K-V-gt-node" class="headerlink" title="private void rehash(HashEntry&lt;K,V&gt; node)"></a>private void rehash(HashEntry&lt;K,V&gt; node)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable =</span><br><span class="line">        (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</span><br><span class="line">    <span class="keyword">int</span> sizeMask = newCapacity - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">int</span> idx = e.hash &amp; sizeMask;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)   <span class="comment">//  Single node on list</span></span><br><span class="line">                newTable[idx] = e;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                <span class="keyword">int</span> lastIdx = idx;</span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">                     last != <span class="keyword">null</span>;</span><br><span class="line">                     last = last.next) &#123;</span><br><span class="line">                    <span class="keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                <span class="comment">// Clone remaining nodes</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    V v = p.value;</span><br><span class="line">                    <span class="keyword">int</span> h = p.hash;</span><br><span class="line">                    <span class="keyword">int</span> k = h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nodeIndex = node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] = node;</span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;对当前segment的HashEntry数组进行扩容并完成元素迁移。第3 ~ 6行代码完成新数组容量、扩容限制阈值的计算，并在第7行代码中完成数组初始化操作。</p>
<p>&emsp;&emsp;第10 ~ 40行代码遍历整个数组，完成数组中元素向新数组的迁移。第11行代码取得数组中不为null的元素，如果该元素的链表集合中仅有一个元素，那么计算该元素在新数组的下标并保存到新数组中。反之，如果当前数组元素的链表集合中有多个元素，那么首先遍历该链表集合，找到这样的一个节点：1）该节点及之后的所有节点在新数组的同一个下标位置，2）满足条件（1）的节点是当前数组元素的链表集合中最后一个满足条件（1）的节点。之后在第29行代码会把找到的节点及其之后的所有节点移到新数组的对应下标中。第31 ~ 36行代码则遍历当前数组元素的链表集合中剩余的元素，循环计算它们在新数组的下标并保存到新数组的对应位置中。</p>
<p>&emsp;&emsp;最后，第41 ~ 44行代码计算新元素节点在新数组中的下标位置，并把新元素节点放到该下标位置的链表集合的首部位置。</p>
<h4 id="private-HashEntry-lt-K-V-gt-scanAndLockForPut-K-key-int-hash-V-value"><a href="#private-HashEntry-lt-K-V-gt-scanAndLockForPut-K-key-int-hash-V-value" class="headerlink" title="private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value)"></a>private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line">    <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">        <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123;</span><br><span class="line">            e = first = f; <span class="comment">// re-traverse if entry changed</span></span><br><span class="line">            retries = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;当前线程等待其他线程释放对当前segment的控制，并返回（生成）一个node节点，该node的key等于入参key，node的hash等于入参hash，node的value等于入参value。</p>
<p>&emsp;&emsp;这个方法可能会在两个地方获得锁，第6行代码和第20行代码，在任何一个地方得到锁以后都会退出循环且得到一个node对象，最后返回到put方法。</p>
<h4 id="private-void-scanAndLock-Object-key-int-hash"><a href="#private-void-scanAndLock-Object-key-int-hash" class="headerlink" title="private void scanAndLock(Object key, int hash)"></a>private void scanAndLock(Object key, int hash)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scanAndLock</span><span class="params">(Object key, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// similar to but simpler than scanAndLockForPut</span></span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; f;</span><br><span class="line">        <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span> || key.equals(e.key))</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123;</span><br><span class="line">            e = first = f;</span><br><span class="line">            retries = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;当前线程尝试对当前segment对象获取锁控制。</p>
<h4 id="final-V-remove-Object-key-int-hash-Object-value"><a href="#final-V-remove-Object-key-int-hash-Object-value" class="headerlink" title="final V remove(Object key, int hash, Object value)"></a>final V remove(Object key, int hash, Object value)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">remove</span><span class="params">(Object key, <span class="keyword">int</span> hash, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryLock())</span><br><span class="line">        scanAndLock(key, hash);</span><br><span class="line">    V oldValue = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        HashEntry&lt;K,V&gt; e = entryAt(tab, index);</span><br><span class="line">        HashEntry&lt;K,V&gt; pred = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                V v = e.value;</span><br><span class="line">                <span class="keyword">if</span> (value == <span class="keyword">null</span> || value == v || value.equals(v)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                        setEntryAt(tab, index, next);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        pred.setNext(next);</span><br><span class="line">                    ++modCount;</span><br><span class="line">                    --count;</span><br><span class="line">                    oldValue = v;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pred = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从当前segment实体中删除key=value映射实体。</p>
<p>&emsp;&emsp;第2 ~ 3行代码执行时当前线程会尝试获取对方法的锁控制，如果得到锁以后，第7行代码会计算入参key=value键值对在当前segment的HashEntry数组中的下标位置。得到该下标位置处的链表集合后，遍历该集合中的每个键值对实体。如果存在key相同且value相同的记录，那么如果该节点是链表的第一个节点，那么执行第18行代码用该节点的后继节点完成删除操作。如果该节点不是链表的第一个节点，那么就采用第20行代码的方式完成删除操作。如果没有找到key相同的记录，那么向后遍历直至整个链表集合全部被遍历过。</p>
<p>&emsp;&emsp;最后释放对方法的锁控制并返回被删除的键值对实体的value值。</p>
<h4 id="final-boolean-replace-K-key-int-hash-V-oldValue-V-newValue"><a href="#final-boolean-replace-K-key-int-hash-V-oldValue-V-newValue" class="headerlink" title="final boolean replace(K key, int hash, V oldValue, V newValue)"></a>final boolean replace(K key, int hash, V oldValue, V newValue)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, <span class="keyword">int</span> hash, V oldValue, V newValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryLock())</span><br><span class="line">        scanAndLock(key, hash);</span><br><span class="line">    <span class="keyword">boolean</span> replaced = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">for</span> (e = entryForHash(<span class="keyword">this</span>, hash); e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (oldValue.equals(e.value)) &#123;</span><br><span class="line">                    e.value = newValue;</span><br><span class="line">                    ++modCount;</span><br><span class="line">                    replaced = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> replaced;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;用key=value键值对替换当前segment实体中HashEntry数组中可以匹配的键值对实体。第2 ~ 3行代码会尝试得到锁控制。在得到锁以后，根据hash计算出键值对在HashEntry数组中的下标位置并遍历该下标处的链表集合，找到可以匹配入参key、value和hash的键值对实体。如果有，那么完成value替换。替换完成或者遍历完成后释放锁控制，返回替换结果（true - 替换完成，false - 替换未执行）。</p>
<h4 id="final-V-replace-K-key-int-hash-V-value"><a href="#final-V-replace-K-key-int-hash-V-value" class="headerlink" title="final V replace(K key, int hash, V value)"></a>final V replace(K key, int hash, V value)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">replace</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryLock())</span><br><span class="line">        scanAndLock(key, hash);</span><br><span class="line">    V oldValue = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">for</span> (e = entryForHash(<span class="keyword">this</span>, hash); e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                ++modCount;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;用key=value键值对替换当前segment实体中HashEntry数组中可以匹配的键值对实体。第2 ~ 3行代码会尝试得到锁控制。在得到锁以后，根据hash计算出键值对在HashEntry数组中的下标位置并遍历该下标处的链表集合，找到可以匹配入参key、value和hash的键值对实体。如果有，那么完成value替换。替换完成或者遍历完成后释放锁控制，返回被替换value值。</p>
<h4 id="final-void-clear"><a href="#final-void-clear" class="headerlink" title="final void clear()"></a>final void clear()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length ; i++)</span><br><span class="line">            setEntryAt(tab, i, <span class="keyword">null</span>);</span><br><span class="line">        ++modCount;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;清空当前Segment实体的HashEntry集合。</p>
<p>&emsp;</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li>NIL</li>
</ol>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>NIL</li>
</ol>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Collection 08 - Set</title>
    <url>/2018/java-Collection-Set.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;在Java语言规范中，Set和List同属于Java集合框架中的Collection，是一种可以保证不会出现重复元素的数据结构，类似于数学领域中的集合。提供了对同类型数据进行存储、插入、删除和查找等需求的实现过程。本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;Set是Java集合体系中的成员之一，和List接口一样直接继承于Collection。所以，Set本身只是一个接口定义，其定义了对Set集合进行操作的方法API。Set底层依赖的数据结构决定了其无法存储重复元素（如果允许存储null元素的话最多也只能存储一个null元素），而且也无法保证Set集合的元素先后顺序，即在多次重复遍历同一集合的情况下，每次遍历得到的元素返回顺序无法保证一致。Set的特点如下：</p>
<ol>
<li>Set的底层实现基于map完成，而且Set暴露出去的方法API大多数都是对map方法的包装。</li>
<li>Set会限制保存在其中的对象类型，有些实现会限制null元素，而其他一些实现会限制特定的数据对象类型。尝试向这种Set集合实现中加入不满足条件的元素会对外抛出异常。尝试查找不满条件的元素时根据实现的不同可能会对外抛出异常，或者直接返回false标识查找失败。</li>
</ol>
<p>&emsp;&emsp;常见的Set实现包括<a href>AbstractSet</a>、<a href>HashSet</a>、<a href>LinkedHashSet</a>、<a href>TreeSet</a>等，而TreeSet还实现了<a href>SortedSet</a>接口。其结构如图1所以：</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1544021679/BlogImages/java-collection/list/Set-guide.png" alt></p>
<div align="center">
<div align="center">图 - 1</div>
&emsp;
</div>

<p>关于上述几个具体实现类之间，分别有其适应的应用场景和特点：</p>
<ul>
<li><p>HashSet</p>
<p>&emsp;&emsp;直接继承于AbstractSet，实现了Set&lt;E&gt;, Cloneable和Serializable接口；</p>
<p>&emsp;&emsp;底层数据结构依赖于HashMap，可允许存储null元素。具有集合内元素唯一，元素遍历顺序不确定的特点；</p>
<p>&emsp;&emsp;HashSet是一个非线程安全的实现。多线程环境下无法保证线程安全。多线程环境下无法保证线程安全。如果需要在多线程环境下使用LinkedHashSet，则需要采用<strong>Collections.synchronizedSet(new HashSet(…));</strong>进行包装。</p>
</li>
<li><p>LinkedHashSet</p>
<p>&emsp;&emsp;直接继承于HashSet，是HashSet的子类。同时实现了Set&lt;E&gt;, Cloneable和Serializable接口；</p>
<p>&emsp;&emsp;底层数据结构依赖于LinkedHashMap，可允许存储null元素。具有集合内元素唯一，遍历顺序确定的特点；</p>
<p>&emsp;&emsp;LinkedHashSet同样是一个非线程安全的实现。多线程环境下无法保证线程安全。如果需要在多线程环境下使用LinkedHashSet，则需要采用<strong>Collections.synchronizedSet(new LinkedHashSet(…));</strong>进行包装；</p>
<p>&emsp;&emsp;LinkedHashSet中加入的元素不必实现Comparable或者Comparator接口，集合元素相等比较依赖的是equals()方法；</p>
<p>&emsp;&emsp;LinkedHashSet可以保证的遍历顺序基于元素的插入元素产生，且元素插入时既有元素的顺序不会因为新元素的插入而发生变化。</p>
</li>
<li><p>TreeSet</p>
<p>&emsp;&emsp;直接继承于AbstractSet，实现了NavigableSet&lt;E&gt;, Cloneable和Serializable接口；</p>
<p>&emsp;&emsp;底层数据依赖于TreeMap，具有集合内元素唯一，遍历顺序确定的特点；</p>
<p>&emsp;&emsp;TreeSet同样是一个非线程安全的实现。多线程环境下无法保证TreeSet使用的线程安全。如果需要在多线程环境下使用LinkedHashSet，则需要采用<strong>Collections.synchronizedSet(new TreeSet(…));</strong>进行包装；</p>
<p>&emsp;&emsp;TreeSet中加入的元素需要实现Comparable或者Comparator接口，集合元素相等比较依赖的是compareTo()方法。如果未实现上述接口的方法在加入集合中时，会抛出<strong>ClassCastException</strong>，提示“TTTT cannot be cast to java.lang.Comparable”；</p>
<p>&emsp;&emsp;TreeSet集合维护的元素是基于Comparable或者Comparator接口的compareTo()方法实现的，进行的对象内容上的比较，按照自然排序（升序或者降序）完成元素排序。该集合的元素顺序会随着元素的加入和删除而产生变化。</p>
</li>
</ul>
<p>&emsp;</p>
<h2 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h2><div class="table-container">
<table>
<thead>
<tr>
<th>方法声明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>int size();</td>
<td>返回Set集合中的元素总数</td>
</tr>
<tr>
<td>boolean isEmpty();</td>
<td>判断Set集合是否为空，为空时返回true</td>
</tr>
<tr>
<td>boolean contains(Object o);</td>
<td>判断Set集合中是否含有元素o</td>
</tr>
<tr>
<td>Iterator&lt;E&gt; iterator();</td>
<td>返回可以游历Set集合的一个迭代器对象</td>
</tr>
<tr>
<td>Object[] toArray();</td>
<td>将当前Set集合中的元素以数组方式返回</td>
</tr>
<tr>
<td>&lt;T&gt; T[] toArray(T[] a);</td>
<td>将当前Set集合中的元素以数组方式存储到参数a中</td>
</tr>
<tr>
<td>boolean add(E e);</td>
<td>加入一个元素到Set集合尾部</td>
</tr>
<tr>
<td>boolean remove(Object o);</td>
<td>从Set集合中移除一个元素</td>
</tr>
<tr>
<td>boolean containsAll(Collection&lt;?&gt; c);</td>
<td>当前Set集合中是否包含集合c的所有元素</td>
</tr>
<tr>
<td>boolean addAll(Collection&lt;? extends E&gt; c);</td>
<td>将集合c中的元素都加入到Set集合中</td>
</tr>
<tr>
<td>boolean removeAll(Collection&lt;?&gt; c);</td>
<td>从Set集合中移除c中所有元素</td>
</tr>
<tr>
<td>boolean retainAll(Collection&lt;?&gt; c);</td>
<td>保留当前Set集合中出现在c中的元素，其他元素都移除</td>
</tr>
<tr>
<td>void clear();</td>
<td>清空Set集合</td>
</tr>
<tr>
<td>boolean equals(Object o);</td>
<td>相等性判断</td>
</tr>
<tr>
<td>int hashCode();</td>
<td>生成Set集合的散列值</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li>NIL</li>
</ol>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>RUNOOB.COM. <a href="http://www.runoob.com/java/java-collections.html" target="_blank" rel="noopener">Java 集合框架</a> [E]</li>
<li>J Steven Perry. <a href="https://www.ibm.com/developerworks/cn/java/j-perry-java-collections/index.html" target="_blank" rel="noopener">第 10 单元：Java 集合</a> [E]</li>
<li>ORACLE. <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/collections/overview.html" target="_blank" rel="noopener">Collections Framework Overview</a> [E]</li>
</ol>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Collection 12 - SortedSet &amp; NavigableSet</title>
    <url>/2018/java-Collection-SortedSet-NavigableSet.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;SortedSet和NavigableSet是两个继承了Set接口的子接口。除了常见的Set集合操作外，这两个接口提供了一种排序来更快的访问元素的机制和方法。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;SortedSet和NavigableSet均是Set接口的子接口，其中SortedSet直接继承于Set，而NavigableSet则直接继承于SortedSet。SortedSet借助于接口<strong>java.lang.Comparable</strong>和<strong>java.util.Comparator</strong>提供了一种建立在元素上的全排序（即对象中的所有字段都参与排序，在某字段相同的情况下比较下一个字段的大小关系），而这种排序手段可以允许迭代器向前或者向后访问元素。因此，SortedSet额外声明了一些方法来充分利用这种双向访问的特点。LinkedHashSet也是有序访问的，但是LinkedHashSet维护的是元素插入集合时的先后顺序，这个顺序是固定的，不会随着元素的插入发生变化。而SortedSet维护的是元素之间大小关系的顺序（比如升序、 降序等），这种顺序会随着元素的插入而发生变更。 </p>
<p>&emsp;&emsp;但是SortedSet对加入集合中的元素也提出了一些要求，即需要实现Comparable或者comparator接口。此外，这些元素相互之间可以互相比较而不会抛出<strong>ClassCastException</strong>异常。</p>
<p>&emsp;&emsp;NavigableSet&lt;E&gt;直接继承了SortedSet提供了更丰富的方法来完成元素查找，常用的有lower(E e)， floor(E e)，ceiling(E e)，higher(E e)等。 除此之外，NavigableSet&lt;E&gt;可以以升序或者降序的任意一种方式来完成遍历操作。需要注意的是，通过升序访问的性能会优于通过降序访问的性能。</p>
<p>&emsp;&emsp;为了避免null引起的误会，NavigableSet&lt;E&gt;的实现类不鼓励允许null元素的加入。</p>
<p>&emsp;</p>
<h2 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h2><h3 id="方法列表"><a href="#方法列表" class="headerlink" title="方法列表"></a>方法列表</h3><div class="table-container">
<table>
<thead>
<tr>
<th>方法声明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>Comparator&lt;? super E&gt; comparator();</td>
<td>返回当前集合采用的比较器</td>
</tr>
<tr>
<td>SortedSet&lt;E&gt; subSet(E fromElement, E toElement);</td>
<td>返回当前集合中大于等于fromElement且小于toElement的元素集合。对该集合的修改会同步到原始集合上，反之亦然</td>
</tr>
<tr>
<td>SortedSet&lt;E&gt; headSet(E toElement);</td>
<td>返回当前集合中小于toElement的元素集合。对该集合的修改会同步到原始集合上，反之亦然</td>
</tr>
<tr>
<td>SortedSet&lt;E&gt; tailSet(E fromElement);</td>
<td>返回当前集合中大于等于fromElement的元素集合。对该集合的修改会同步到原始集合上，反之亦然</td>
</tr>
<tr>
<td>E first();</td>
<td>返回当前集合中第一个（也是最小）的元素</td>
</tr>
<tr>
<td>E last();</td>
<td>返回当前集合中最后（也是最大）的元素</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="NavigableSet"><a href="#NavigableSet" class="headerlink" title="NavigableSet"></a>NavigableSet</h2><h3 id="方法列表-1"><a href="#方法列表-1" class="headerlink" title="方法列表"></a>方法列表</h3><div class="table-container">
<table>
<thead>
<tr>
<th>方法声明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>E lower(E e);</td>
<td>返回小于元素e的最大元素，如果没有返回null</td>
</tr>
<tr>
<td>E floor(E e);</td>
<td>返回小于或者等于元素e的最大元素，如果没有返回null</td>
</tr>
<tr>
<td>E ceiling(E e);</td>
<td>返回大于或者等于元素e的最小元素，如果没有返回null</td>
</tr>
<tr>
<td>E higher(E e);</td>
<td>返回大于元素e的最小元素，如果没有返回null</td>
</tr>
<tr>
<td>E pollFirst();</td>
<td>移除并返回集合中的最小（第一个）元素，如果集合为空返回null</td>
</tr>
<tr>
<td>E pollLast();</td>
<td>移除并返回集合中的最大（最后一个）元素，如果集合为空返回null</td>
</tr>
<tr>
<td>Iterator&lt;E&gt; iterator();</td>
<td>返回一个以升序方式迭代集合的迭代器</td>
</tr>
<tr>
<td>NavigableSet&lt;E&gt; descendingSet();</td>
<td>返回当前集合的一个逆序集合表示。对该集合的修改会同步到原始集合上，反之亦然</td>
</tr>
<tr>
<td>Iterator&lt;E&gt; descendingIterator();</td>
<td>返回一个以降序方式迭代集合的迭代器</td>
</tr>
<tr>
<td>NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive,E toElement,   boolean toInclusive);</td>
<td>返回一个以fromElement为起点，toElement为终点的子集合。由fromInclusive和toInclusive字段标记是否包含fromElement和toElement节点。</td>
</tr>
<tr>
<td>NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive);</td>
<td>返回一个小于（等于）toElement元素的子集合。由inclusive指定是否可以返回等于toElement元素的元素。</td>
</tr>
<tr>
<td>NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive);</td>
<td>返回一个大于（等于）fromElement元素的子集合。由inclusive指定是否可以返回等于fromElement元素的元素</td>
</tr>
<tr>
<td>SortedSet&lt;E&gt; subSet(E fromElement, E toElement);</td>
<td>返回一个大于（等于）fromElement元素、小于toElement元素的子集合。</td>
</tr>
<tr>
<td>SortedSet&lt;E&gt; headSet(E toElement);</td>
<td>返回一个小于toElement元素的子集合。</td>
</tr>
<tr>
<td>SortedSet&lt;E&gt; tailSet(E fromElement);</td>
<td>返回一个大于（等于）fromElement元素的子集合。</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li><p><strong>“consistent with equals”的意义是什么</strong></p>
<p>&emsp;&emsp;标识比较结果和equals()方法结果一致。在<strong>java.lang.Comparable&lt;T&gt;</strong>接口中对“consistent with equals”做了如下定义：</p>
<blockquote>
<p>The natural ordering for a class C is said to be consistent with equals if and only if e1.compareTo(e2) == 0 has the same boolean value as e1.equals(e2) for every e1 and e2 of class C. Note that null is not an instance of any class, and e.compareTo(null) should throw a NullPointerException even though e.equals(null) returns false.</p>
</blockquote>
<p>&emsp;&emsp;翻译过来就是如果一个对象的自然排序被认为是consistent with equals当且仅当通过通过compareTo()和通过equals()方法可以得到一致的判断结果。如果是null元素，那么equals()方法返回false的同时compareTo()会抛出一个<strong>NullPointerException </strong>异常。</p>
<p>&emsp;&emsp;在java中，==用来比较两个变量是否相等。如果运算数是基本数据类型，那么==比较的是值，如果运算数是对象，那么==比较的是对象在内存中的地址。equals()方法的默认实现也是比较对象在内存中的地址。而compareTo()方法则需要被实现来完成元素之间的比较。只有equals()方法和compareTo()方法完成了同样的判断结果时就认为相等性是一致的。</p>
</li>
<li><p><strong>覆盖equals()方法需要遵守的约定</strong></p>
<p>&emsp;&emsp;在《Effective Java》中，介绍了如下的几条规则：</p>
<blockquote>
<p>自反性（reflexive）。对于任何非 null 的引用值 x，x.equals(x) 必须返回 true 。</p>
<p>对称性（symmetric）。对于任何非 null 的引用值 x 和 y，当且仅当 y.equals(x) 返回 true时，x.equals(y) 必须返回 true 。</p>
<p>传递性（transitive）。对于任何非 null 的引用值 x 、 y 和 z 。如果 x.equals(y) 返回 true ，并且 y.equals(z) 也返回 true ，那么 x.equals(z) 也必须返回 true 。</p>
<p>一致性（consistent）。对于任何非 null 的引用值 x 和 y ，只要 equals 的比较操作在对象中所用的信息没有被修改，多次调用 x.equals(x) 就会一致地返回 true ，或者一致的返回 false 。</p>
<p>对于任何非 null 的引用值 x ， x.equals(null) 必须返回 false 。</p>
</blockquote>
<p>&emsp;&emsp;如果确实需要覆盖equals()方法，那么需要同时覆盖hashCode()方法。否则无法保证可以在基于散列的集合中存储使用只覆盖了equals()方法的类。在覆盖hashCode()方法时，需要遵循如下规则：</p>
<blockquote>
<p>在应用程序的执行期间，只要对象的 equals 方法的比较操作所用到的信息没有被修改，那么对同一个对象调用多次， hashCode 方法都必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中 ,每次执行所返回的整数可以不一致。</p>
<p>如果两个对象根据 equals(Object) 方法比较是相等的，那么调用这两个对象中任意一个对象的hashCode方法都必须产生同样的整数结果。</p>
<p>如果两个对象根据 equals(Object) 方法比较是不等的，那么调用这两个对象中任意一个对象的hashCode  方法，则不一定要产生不同的整数结果。但是程序员应该知道，给不相等的对象产生截然不同的整数结果，有可能提高散列表（hash table）的性能。</p>
</blockquote>
</li>
<li><p><strong>equals()和compartTo()的异同</strong></p>
<p>&emsp;&emsp;两个方法都可以用来完成元素比较操作。</p>
<p>&emsp;&emsp;equals()方法默认比较对象的内存地址，用来比较两个对象物理上是否属于同一个对象，可以通过覆盖equals()方法实现对象的逻辑比较（即值比较）。compareTo()方法被设计用来做内容比较，如果两个通过new实例化的对象含有相同的内容，那么通过compareTo()方法比较这两个对象被认为是相等的。</p>
<p>&emsp;&emsp;equals()方法是Object的自带方法，由于Java中所有类都是Object的父类，所以所有类都继承了equals()方法。由于equals()方法有默认实现，所以equals()方法只有在实际需要的情况下才会被子类覆盖，反之则可以使用默认实现完成相关操作。而compareTo()方法是Comparable接口声明的方法，只有实现了该接口的方法才会拥有compareTo()方法。但是该方法没有任何实现，任何实现了Comparable接口的类都需要自定义实现compareTo()方法。</p>
<p>&emsp;&emsp;只有实现了Comparable接口的类才能被存储到TreeSet等依赖于内容比较的集合中。而只有equals()方法未实现compareTo()方法的类在尝试加入到上述集合中时会导致失败。</p>
</li>
</ol>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>[美] Joshua Bloch. Effective Java 2nd Edtion[M]. Boston:Addison-Wesley.</li>
</ol>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Collection 05 - Stack</title>
    <url>/2018/java-Collection-Stack.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;关于<em> <strong>java.util.Stack&lt;E&gt;</strong> </em>的部分笔记，这是一种先进后出的数据结构，对外暴露的操作方法API数量有限。本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;Stack是一种以Vector为基础，具有先进后出(last-in-first-out或者LIFO)特性的数据结构。Stack只有为数不多的方法可以实现元素的存储和输出操作，其中push()方法用于将一个元素存储到Stack集合的顶部位置， pop()方法则从顶部取出一个元素并将次顶部的元素推到顶部位置， peek()仅仅是获取到顶部的元素， empty()方法用来判断当前Stack是否为空， search()方法则用来计算某个特定元素到Stack顶部的距离。</p>
<p>&emsp;&emsp;如果需要用到LIFO特性的数据结构，Deque是一种比Stack更能满足要求的数据结构。Deque能够提供比Stack更为丰富的操作方法API，在实际使用时可以优先考虑Deque。</p>
<p>&emsp;</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Stack&lt;E&gt;</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.util.AbstractCollection&lt;E&gt;</span><br><span class="line">    --java.util.AbstractList&lt;E&gt;</span><br><span class="line">      --java.util.Vector&lt;E&gt;</span><br><span class="line">        --java.util.Stack&lt;E&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><div class="table-container">
<table>
<thead>
<tr>
<th>类名</th>
<th>实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>Stack&lt;E&gt;</td>
<td>Iterable&lt;E&gt;, Collection&lt;E&gt;, List&lt;E&gt;, RandomAccess, Serializable, Cloneable</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><h3 id="Constructor-Summary"><a href="#Constructor-Summary" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="public-Stack"><a href="#public-Stack" class="headerlink" title="public Stack()"></a>public Stack()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个Stack集合。初始化之后，Stack是一个不含有任何元素的空集合。</p>
<h3 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="public-E-push-E-item"><a href="#public-E-push-E-item" class="headerlink" title="public E push(E item)"></a>public E push(E item)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">push</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    addElement(item);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将元素item压入到Stack栈顶部位置。实际调用的是Vector的<strong>addElement(E obj)</strong>方法。</p>
<h4 id="public-synchronized-E-pop"><a href="#public-synchronized-E-pop" class="headerlink" title="public synchronized E pop()"></a>public synchronized E pop()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    E       obj;</span><br><span class="line">    <span class="keyword">int</span>     len = size();</span><br><span class="line"></span><br><span class="line">    obj = peek();</span><br><span class="line">    removeElementAt(len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回并退出Stack栈顶部位置的元素。首先通过Vector的size()方法获取栈顶位置下标，然后peek()方法会返回处于栈顶位置的元素，最后通过Vector的<strong>removeElementAt(int index)</strong>方法删除len-1（也就是栈顶位置）的元素。</p>
<h4 id="public-synchronized-E-peek"><a href="#public-synchronized-E-peek" class="headerlink" title="public synchronized E peek()"></a>public synchronized E peek()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>     len = size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">    <span class="keyword">return</span> elementAt(len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回Stack栈顶部位置的元素。该方法仅返回顶部位置的元素，不会执行删除操作。通过Vector的size()方法得到栈顶位置下标，然后通过Vector的elementAt(int index)直接返回栈顶元素。</p>
<h4 id="public-boolean-empty"><a href="#public-boolean-empty" class="headerlink" title="public boolean empty()"></a>public boolean empty()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;判断当前栈是否为空。</p>
<h4 id="public-synchronized-int-search-Object-o"><a href="#public-synchronized-int-search-Object-o" class="headerlink" title="public synchronized int search(Object o)"></a>public synchronized int search(Object o)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = lastIndexOf(o);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> size() - i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回元素o在栈中的位置。实际返回的当前元素o与栈顶位置之间的距离，且返回的是栈中距离栈顶位置最近的元素o的位置。如果元素o不存在与栈中，那么就返回-1。</p>
<p>&emsp;</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li>NIL</li>
</ol>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>NIL</li>
</ol>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Collection 13 - TreeSet</title>
    <url>/2018/java-Collection-TreeSet.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;关于<em> <strong>java.util.TreeSet&lt;E&gt;</strong> </em>的部分笔记，TreeSet是一个有序的、不可存储重复元素的Set集合实现类。TreeSet集合的顺序由Comparable实现或者Comparator指定。本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;TreeSet是一个基于TreeMap的Set集合实现，继承了AbstractSet的同时实现了NavigableSet接口（该接口直接继承于SortedSet）中声明的方法操作。集合内的元素按照实现了Comparable接口的自然顺序进行排序，或者由Comparator指定一个排序顺序。TreeSet实现保证在调用add(E e)、remove(Object o) 、contains(Object o)方法时可以得到log(n)的时间性能。</p>
<p>&emsp;&emsp;和LinkedHashSet不一致的是，TreeSet维护的顺序是基于元素内容的，按照事先定义好的比较规则比较插入TreeSet集合的每一个元素，因此在元素插入后，集合的顺序可能会随之发生变更。而LinkedHashSet维护的元素插入的顺序，这个顺序为固定的，只与元素被加入集合时的时间有关系。</p>
<p>&emsp;&emsp;TreeSet集合也是一个非线程安全的集合实现类。如果需要在多线程环境中使用TreeSet集合，那么需要对TreeSet集合做额外的处理来保证其多线程环境下的线程安全。一种常见的处理方式是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SortedSet s = Collections.synchronizedSortedSet(<span class="keyword">new</span> TreeSet(...));</span><br></pre></td></tr></table></figure>
<p>该处理需要在TreeSet初始化的同时就完成，避免因为多线程环境下使用时出现问题。</p>
<p>&emsp;&emsp;TreeSet返回的迭代器也支持快速失败检查。</p>
<p>&emsp;</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TreeSet&lt;E&gt;</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.util.AbstractCollection&lt;E&gt;</span><br><span class="line">    --java.util.AbstractSet&lt;E&gt;</span><br><span class="line">      --java.util.TreeSet&lt;E&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><div class="table-container">
<table>
<thead>
<tr>
<th>类名</th>
<th>实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>TreeSet&lt;E&gt;</td>
<td>Iterable&lt;E&gt;, Collection&lt;E&gt;, NavigableSet&lt;E&gt;, Set&lt;E&gt;, SortedSet&lt;E&gt;, Serializable, Cloneable</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><h3 id="Constructor-Summary"><a href="#Constructor-Summary" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="TreeSet-NavigableMap-lt-E-Object-gt-m"><a href="#TreeSet-NavigableMap-lt-E-Object-gt-m" class="headerlink" title="TreeSet(NavigableMap&lt;E,Object&gt; m)"></a>TreeSet(NavigableMap&lt;E,Object&gt; m)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeSet(NavigableMap&lt;E,Object&gt; m) &#123;</span><br><span class="line">    <span class="keyword">this</span>.m = m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;根据入参NavigableMap构建一个TreeSet集合。m集合会成为TreeSet集合的底层依赖集合实例。</p>
<h4 id="public-TreeSet"><a href="#public-TreeSet" class="headerlink" title="public TreeSet()"></a>public TreeSet()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;E,Object&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个空的TreeSet集合，集合排序按照元素的自然排序进行处理。</p>
<h4 id="public-TreeSet-Comparator-lt-super-E-gt-comparator"><a href="#public-TreeSet-Comparator-lt-super-E-gt-comparator" class="headerlink" title="public TreeSet(Comparator&lt;? super E&gt; comparator)"></a>public TreeSet(Comparator&lt;? super E&gt; comparator)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;&gt;(comparator));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个空的TreeSet集合，集合排序按照comparator规则进行处理。</p>
<h4 id="public-TreeSet-Collection-lt-extends-E-gt-c"><a href="#public-TreeSet-Collection-lt-extends-E-gt-c" class="headerlink" title="public TreeSet(Collection&lt;? extends E&gt; c)"></a>public TreeSet(Collection&lt;? extends E&gt; c)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个空的TreeSet集合，并将集合c的所有元素加入到集合中。集合排序按照元素的自然排序规则进行处理。底层通过调用<strong>addAll(Collection&lt;? extends E&gt; c) </strong>完成元素添加操作。</p>
<h4 id="public-TreeSet-SortedSet-lt-E-gt-s"><a href="#public-TreeSet-SortedSet-lt-E-gt-s" class="headerlink" title="public TreeSet(SortedSet&lt;E&gt; s)"></a>public TreeSet(SortedSet&lt;E&gt; s)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(SortedSet&lt;E&gt; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(s.comparator());</span><br><span class="line">    addAll(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个空的TreeSet集合，并将SortedSet集合s的所有元素加入到集合中。集合排序按照s的排序规则进行处理。底层通过调用<strong>addAll(Collection&lt;? extends E&gt; c) </strong>完成元素添加操作。</p>
<h3 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="public-Iterator-lt-E-gt-iterator"><a href="#public-Iterator-lt-E-gt-iterator" class="headerlink" title="public Iterator&lt;E&gt; iterator()"></a>public Iterator&lt;E&gt; iterator()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.navigableKeySet().iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回一个遍历当前TreeSet集合的迭代器，迭代器按照升序方式进行遍历迭代。底层调用<strong>NavigableMap.navigableKeySet().iterator()完成操作</strong>。</p>
<h4 id="public-Iterator-lt-E-gt-descendingIterator"><a href="#public-Iterator-lt-E-gt-descendingIterator" class="headerlink" title="public Iterator&lt;E&gt; descendingIterator()"></a>public Iterator&lt;E&gt; descendingIterator()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.descendingKeySet().iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回一个遍历当前TreeSet集合的迭代器，迭代器按照降序方式进行遍历迭代。底层调用<strong>NavigableMap.descendingKeySet().iterator()完成操作</strong>。</p>
<h4 id="public-NavigableSet-lt-E-gt-descendingSet"><a href="#public-NavigableSet-lt-E-gt-descendingSet" class="headerlink" title="public NavigableSet&lt;E&gt; descendingSet()"></a>public NavigableSet&lt;E&gt; descendingSet()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title">descendingSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeSet&lt;&gt;(m.descendingMap());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回当前集合的一个逆序集合表示。对该集合的修改会同步到原始集合上，反之亦然</p>
<h4 id="public-int-size"><a href="#public-int-size" class="headerlink" title="public int size()"></a>public int size()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回当前TreeSet集合存储的元素总数。</p>
<h4 id="public-boolean-isEmpty"><a href="#public-boolean-isEmpty" class="headerlink" title="public boolean isEmpty()"></a>public boolean isEmpty()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;判断当前TreeSet集合是否为空。</p>
<h4 id="public-boolean-contains-Object-o"><a href="#public-boolean-contains-Object-o" class="headerlink" title="public boolean contains(Object o)"></a>public boolean contains(Object o)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.containsKey(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;判断当前TreeSet集合是否存储了元素o。如果有则返回true，反之返回false。</p>
<h4 id="public-boolean-add-E-e"><a href="#public-boolean-add-E-e" class="headerlink" title="public boolean add(E e)"></a>public boolean add(E e)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将元素e加入到当前TreeSet集合中。</p>
<h4 id="public-boolean-remove-Object-o"><a href="#public-boolean-remove-Object-o" class="headerlink" title="public boolean remove(Object o)"></a>public boolean remove(Object o)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从当前TreeSet集合中移除元素o。移除成功后返回true，表示集合中的元素o已经被移除掉。</p>
<h4 id="public-void-clear"><a href="#public-void-clear" class="headerlink" title="public void clear()"></a>public void clear()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;清空当前TreeSet集合中的所有元素。</p>
<h4 id="public-boolean-addAll-Collection-lt-extends-E-gt-c"><a href="#public-boolean-addAll-Collection-lt-extends-E-gt-c" class="headerlink" title="public  boolean addAll(Collection&lt;? extends E&gt; c)"></a>public  boolean addAll(Collection&lt;? extends E&gt; c)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Use linear-time version if applicable</span></span><br><span class="line">    <span class="keyword">if</span> (m.size()==<span class="number">0</span> &amp;&amp; c.size() &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        c <span class="keyword">instanceof</span> SortedSet &amp;&amp;</span><br><span class="line">        m <span class="keyword">instanceof</span> TreeMap) &#123;</span><br><span class="line">        SortedSet&lt;? extends E&gt; set = (SortedSet&lt;? extends E&gt;) c;</span><br><span class="line">        TreeMap&lt;E,Object&gt; map = (TreeMap&lt;E, Object&gt;) m;</span><br><span class="line">        Comparator&lt;? <span class="keyword">super</span> E&gt; cc = (Comparator&lt;? <span class="keyword">super</span> E&gt;) set.comparator();</span><br><span class="line">        Comparator&lt;? <span class="keyword">super</span> E&gt; mc = map.comparator();</span><br><span class="line">        <span class="keyword">if</span> (cc==mc || (cc != <span class="keyword">null</span> &amp;&amp; cc.equals(mc))) &#123;</span><br><span class="line">            map.addAllForTreeSet(set, PRESENT);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将集合c中的元素加入到当前TreeSet集合中。如果当前TreeSet集合尚未存储任何元素，那么就执行第3 ~ 14行代码的操作，反之，则直接执行第15行代码。第11行代码的方法API是专门为TreeSet集合实现的，该方法可以保证大量元素插入的性能效率。所以如果满足采用优化操作插入元素的条件，那么就采用快速方法完成元素插入。否则就只有用AbstractCollection的addAll(Collection&lt;? extends E&gt; c)方法完成操作，而该方法将元素一个一个的加入到集合中，性能相对来说不是很理想。</p>
<h4 id="public-NavigableSet-lt-E-gt-subSet-E-fromElement-boolean-fromInclusive-E-toElement-boolean-toInclusive"><a href="#public-NavigableSet-lt-E-gt-subSet-E-fromElement-boolean-fromInclusive-E-toElement-boolean-toInclusive" class="headerlink" title="public NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive, E toElement,   boolean toInclusive)"></a>public NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive, E toElement,   boolean toInclusive)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E fromElement, <span class="keyword">boolean</span> fromInclusive,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  E toElement,   <span class="keyword">boolean</span> toInclusive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeSet&lt;&gt;(m.subMap(fromElement, fromInclusive,</span><br><span class="line">                                  toElement,   toInclusive));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回一个以fromElement为起点，toElement为终点的子集合。由fromInclusive和toInclusive字段标记是否包含fromElement和toElement节点。对该集合的修改会同步到原始集合上，反之亦然。</p>
<h4 id="public-NavigableSet-lt-E-gt-headSet-E-toElement-boolean-inclusive"><a href="#public-NavigableSet-lt-E-gt-headSet-E-toElement-boolean-inclusive" class="headerlink" title="public NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive)"></a>public NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E toElement, <span class="keyword">boolean</span> inclusive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeSet&lt;&gt;(m.headMap(toElement, inclusive));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回一个小于（等于）toElement元素的子集合。由inclusive指定是否可以返回等于toElement元素的元素。对该集合的修改会同步到原始集合上，反之亦然。</p>
<h4 id="public-NavigableSet-lt-E-gt-tailSet-E-fromElement-boolean-inclusive"><a href="#public-NavigableSet-lt-E-gt-tailSet-E-fromElement-boolean-inclusive" class="headerlink" title="public NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive)"></a>public NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E fromElement, <span class="keyword">boolean</span> inclusive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeSet&lt;&gt;(m.tailMap(fromElement, inclusive));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回一个大于（等于）fromElement元素的子集合。由inclusive指定是否可以返回等于fromElement元素的元素。对该集合的修改会同步到原始集合上，反之亦然。</p>
<h4 id="public-SortedSet-lt-E-gt-subSet-E-fromElement-E-toElement"><a href="#public-SortedSet-lt-E-gt-subSet-E-fromElement-E-toElement" class="headerlink" title="public SortedSet&lt;E &gt; subSet(E fromElement, E toElement)"></a>public SortedSet&lt;E &gt; subSet(E fromElement, E toElement)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SortedSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E fromElement, E toElement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> subSet(fromElement, <span class="keyword">true</span>, toElement, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回一个以fromElement为起点（包含fromElement），toElement为终点（不包含toElement）的子集合。对该集合的修改会同步到原始集合上，反之亦然。</p>
<h4 id="public-SortedSet-lt-E-gt-headSet-E-toElement"><a href="#public-SortedSet-lt-E-gt-headSet-E-toElement" class="headerlink" title="public SortedSet&lt;E&gt; headSet(E toElement)"></a>public SortedSet&lt;E&gt; headSet(E toElement)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SortedSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E toElement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> headSet(toElement, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;返回一个小于toElement元素的子集合。对该集合的修改会同步到原始集合上，反之亦然。&emsp;</p>
<h4 id="public-SortedSet-lt-E-gt-tailSet-E-fromElement"><a href="#public-SortedSet-lt-E-gt-tailSet-E-fromElement" class="headerlink" title="public SortedSet&lt;E&gt; tailSet(E fromElement)"></a>public SortedSet&lt;E&gt; tailSet(E fromElement)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SortedSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E fromElement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tailSet(fromElement, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回一个大于fromElement元素的子集合。对该集合的修改会同步到原始集合上，反之亦然。</p>
<h4 id="public-Comparator-lt-super-E-gt-comparator"><a href="#public-Comparator-lt-super-E-gt-comparator" class="headerlink" title="public Comparator&lt;? super E&gt; comparator()"></a>public Comparator&lt;? super E&gt; comparator()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator() &#123;</span><br><span class="line">    <span class="keyword">return</span> m.comparator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回当前集合采用的比较器。如果当前TreeSet集合采用的自然排序，那么返回null。</p>
<h4 id="public-E-first"><a href="#public-E-first" class="headerlink" title="public E first()"></a>public E first()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.firstKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回当前集合中第一个（也是最小）的元素。如果集合为空则抛出<strong>NoSuchElementException</strong>异常。</p>
<h4 id="public-E-last"><a href="#public-E-last" class="headerlink" title="public E last()"></a>public E last()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">last</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.lastKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回当前集合中最后（也是最大）的元素。如果集合为空则抛出<strong>NoSuchElementException</strong>异常。</p>
<h4 id="public-E-lower-E-e"><a href="#public-E-lower-E-e" class="headerlink" title="public E lower(E e)"></a>public E lower(E e)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">lower</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.lowerKey(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回小于元素e的最大元素，如果没有返回null。</p>
<h4 id="public-E-floor-E-e"><a href="#public-E-floor-E-e" class="headerlink" title="public E floor(E e)"></a>public E floor(E e)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">floor</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.floorKey(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回小于或者等于元素e的最大元素，如果没有返回null。</p>
<h4 id="public-E-ceiling-E-e"><a href="#public-E-ceiling-E-e" class="headerlink" title="public E ceiling(E e)"></a>public E ceiling(E e)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">ceiling</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.ceilingKey(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回大于或者等于元素e的最小元素，如果没有返回null。</p>
<h4 id="public-E-higher-E-e"><a href="#public-E-higher-E-e" class="headerlink" title="public E higher(E e)"></a>public E higher(E e)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">higher</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.higherKey(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回大于元素e的最小元素，如果没有返回null。</p>
<h4 id="public-E-pollFirst"><a href="#public-E-pollFirst" class="headerlink" title="public E pollFirst()"></a>public E pollFirst()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map.Entry&lt;E,?&gt; e = m.pollFirstEntry();</span><br><span class="line">    <span class="keyword">return</span> (e == <span class="keyword">null</span>) ? <span class="keyword">null</span> : e.getKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;移除并返回集合中的最小（第一个）元素，如果集合为空返回null。该方法是在JDK1.6版本中加入的。</p>
<h4 id="public-E-pollLast"><a href="#public-E-pollLast" class="headerlink" title="public E pollLast()"></a>public E pollLast()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map.Entry&lt;E,?&gt; e = m.pollLastEntry();</span><br><span class="line">    <span class="keyword">return</span> (e == <span class="keyword">null</span>) ? <span class="keyword">null</span> : e.getKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;移除并返回集合中的最大（最后一个）元素，如果集合为空返回null。该方法是在JDK1.6版本中加入的。</p>
<h4 id="public-Object-clone"><a href="#public-Object-clone" class="headerlink" title="public Object clone()"></a>public Object clone()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TreeSet&lt;E&gt; clone = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        clone = (TreeSet&lt;E&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    clone.m = <span class="keyword">new</span> TreeMap&lt;&gt;(m);</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回当前TreeSet集合的一个浅复制实例。在复制过程中，集合中的元素不会被复制，而是先把集合复制出来，之后单独完成集合内元素的赋值操作。</p>
<h4 id="private-void-writeObject-java-io-ObjectOutputStream-s"><a href="#private-void-writeObject-java-io-ObjectOutputStream-s" class="headerlink" title="private void writeObject(java.io.ObjectOutputStream s)"></a>private void writeObject(java.io.ObjectOutputStream s)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Write out any hidden stuff</span></span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out Comparator</span></span><br><span class="line">    s.writeObject(m.comparator());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out size</span></span><br><span class="line">    s.writeInt(m.size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (E e : m.keySet())</span><br><span class="line">        s.writeObject(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将当前TreeSet集合执行序列化操作后保存到流中。在执行TreeSet的序列化操作时采用TreeSet自己实现的序列化方法完成操作。</p>
<h4 id="private-void-readObject-java-io-ObjectInputStream-s"><a href="#private-void-readObject-java-io-ObjectInputStream-s" class="headerlink" title="private void readObject(java.io.ObjectInputStream s)"></a>private void readObject(java.io.ObjectInputStream s)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// Read in any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in Comparator</span></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> E&gt; c = (Comparator&lt;? <span class="keyword">super</span> E&gt;) s.readObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create backing TreeMap</span></span><br><span class="line">    TreeMap&lt;E,Object&gt; tm;</span><br><span class="line">    <span class="keyword">if</span> (c==<span class="keyword">null</span>)</span><br><span class="line">        tm = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tm = <span class="keyword">new</span> TreeMap&lt;&gt;(c);</span><br><span class="line">    m = tm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in size</span></span><br><span class="line">    <span class="keyword">int</span> size = s.readInt();</span><br><span class="line"></span><br><span class="line">    tm.readTreeSet(size, s, PRESENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从流中读取处序列化数据并执行反序列操作在内存中生成一个TreeSet集合实例。在执行TreeSet的反序列化操作时采用TreeSet自己实现的反序列化方法完成操作。</p>
<p>&emsp;</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li>NIL</li>
</ol>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>Lirx_Tech. <a href="https://blog.csdn.net/Lirx_Tech/article/details/51514248" target="_blank" rel="noopener">[疯狂Java]集合：SortedSet、TreeSet</a> [E]</li>
</ol>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Collection 04 - Vector</title>
    <url>/2018/java-Collection-Vector.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;关于<em> <strong>java.util.Vector&lt;E&gt;</strong> </em>的部分笔记。Vector是线程安全版本的、可变长度的、可用随机访问的方式获取元素的、基于数组实现的集合容器实现类。但是由于其主要方法都通过synchronized保证了多线程的线程安全特性，所以其性能相对ArrayList而言会慢很多。本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;Vector是一个可变长度的集合容器，底层是基于数组实现的。由于其同样实现了RandomAccess接口，所以可以按照随机访问的方式来访问集合中的元素。</p>
<p>&emsp;&emsp;Vector生成的iterators同样带有快速失败属性。如果某个迭代器在运行时发现Vector集合最近一次的结构化修改不是由迭代器自身完成的，那么会抛出<strong>ConcurrentModificationException</strong>异常。</p>
<p>&emsp;&emsp;在List中，支持随机访问存储的集合实现有ArrayList和Vector。二者的底层实现都是依赖于数组完成的。但是ArrayList在多线程环境下无法保证线程安全，而Vector则可以用于多线程环境下的元素存储需要，通过在方法声明中加入synchronized关键字来保证多线程环境的线程安全。所以如果需要在多线程环境下实现可随机访问的List集合，那么需要使用的是Vector而不是ArrayList。需要注意的是，由于Vector的多线程特性，所以其性能会稍逊于ArrayList。所以，如果没有实际的多线程环境需要，可用ArrayList来替换Vector以提高性能。</p>
<p>&emsp;</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vector&lt;E&gt;</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.util.AbstractCollection&lt;E&gt;</span><br><span class="line">    --java.util.AbstractList&lt;E&gt;</span><br><span class="line">      --java.util.Vector&lt;E&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><div class="table-container">
<table>
<thead>
<tr>
<th>类名</th>
<th>实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>Vector&lt;E&gt;</td>
<td>Iterable&lt;E&gt;, Collection&lt;E&gt;, List&lt;E&gt;, RandomAccess, Serializable, Cloneable</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><h3 id="Constructor-Summary"><a href="#Constructor-Summary" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="public-Vector-int-initialCapacity-int-capacityIncrement"><a href="#public-Vector-int-initialCapacity-int-capacityIncrement" class="headerlink" title="public Vector(int initialCapacity, int capacityIncrement)"></a>public Vector(int initialCapacity, int capacityIncrement)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;根据入参initialCapacity指定的长度初始化一个Vector空集合实例。capacityIncrement参数指定了Vector在执行扩容操作时依据的扩容规模大小。</p>
<h4 id="public-Vector-int-initialCapacity"><a href="#public-Vector-int-initialCapacity" class="headerlink" title="public Vector(int initialCapacity)"></a>public Vector(int initialCapacity)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;根据入参initialCapacity指定的长度初始化一个Vector空集合实例。capacityIncrement默认为0。</p>
<h4 id="public-Vector-Collection-lt-extends-E-gt-c"><a href="#public-Vector-Collection-lt-extends-E-gt-c" class="headerlink" title="public Vector(Collection&lt;? extends E&gt; c)"></a>public Vector(Collection&lt;? extends E&gt; c)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    elementCount = elementData.length;</span><br><span class="line">    <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">    <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">        elementData = Arrays.copyOf(elementData, elementCount, Object[].class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;根据集合c初始化一个Vector集合实例，并将c中的内容复制到实例化后的集合实例中。初始化的实例集合中元素的位置和c一致。</p>
<p>&emsp;&emsp;<strong>elementCount</strong>是Vector当前已经容纳的元素数，非Vector可以容纳的元素总数，Vector可以容纳的元素总数可以从elementData.length中得到。</p>
<h3 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="public-void-trimToSize"><a href="#public-void-trimToSize" class="headerlink" title="public void trimToSize()"></a>public void trimToSize()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">        elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;缩小Vector的存储容量。将暂时尚未存储元素的空间全部释放掉。</p>
<h4 id="public-synchronized-void-copyInto-Object-anArray"><a href="#public-synchronized-void-copyInto-Object-anArray" class="headerlink" title="public synchronized void copyInto(Object[] anArray)"></a>public synchronized void copyInto(Object[] anArray)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">copyInto</span><span class="params">(Object[] anArray)</span> </span>&#123;</span><br><span class="line">    System.arraycopy(elementData, <span class="number">0</span>, anArray, <span class="number">0</span>, elementCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将Vector中的元素复制到数组anArray中。由于System.arraycopy是浅复制，所以对anArray的修改会同步出现在Vector的集合中。</p>
<h4 id="public-synchronized-void-ensureCapacity-int-minCapacity"><a href="#public-synchronized-void-ensureCapacity-int-minCapacity" class="headerlink" title="public synchronized void ensureCapacity(int minCapacity)"></a>public synchronized void ensureCapacity(int minCapacity)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        ensureCapacityHelper(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;扩容操作。由于扩容操作会修改Vector集合的空间大小，所以需要记录modCount值。这个方法没有在Vector内部调用，如果在需要用Vector的场景中可以预先估计到可能存储的元素数量，那么可以调用该方法提前完成内存空间的分配进而避免频繁分配存储空间降低执行性能。</p>
<h4 id="private-void-ensureCapacityHelper-int-minCapacity"><a href="#private-void-ensureCapacityHelper-int-minCapacity" class="headerlink" title="private void ensureCapacityHelper(int minCapacity)"></a>private void ensureCapacityHelper(int minCapacity)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityHelper</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">    MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;扩容底层操作。如果调用时需要的容量大小超过了当前Vector的elementData长度就执行扩容操作。反之不做处理。在计算扩充后容量时，如果指定了capacityIncrement大小，那么就在当前Vector空间容量的基础上增加capacityIncrement个空间。反之，如果未指定capacityIncrement大小，那么扩容后容量是当前容量的两倍大小。如果扩容后数量还是无法满足参数要求，那么就将Vector空间扩容为参数minCapacity指定的大小。</p>
<h4 id="public-synchronized-void-setSize-int-newSize"><a href="#public-synchronized-void-setSize-int-newSize" class="headerlink" title="public synchronized void setSize(int newSize)"></a>public synchronized void setSize(int newSize)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">int</span> newSize)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (newSize &gt; elementCount) &#123;</span><br><span class="line">        ensureCapacityHelper(newSize);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = newSize ; i &lt; elementCount ; i++) &#123;</span><br><span class="line">            elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    elementCount = newSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;重置Vector的存储元素个数。由于该操作会修改Vector集合的存储元素数，所以需要记录modCount值。如果newSize大于Vector集合中存储的元素数，那么就执行扩容处理，空出部分被填充为null。反之，则清除自newSize及以后位置的元素，并释放空间。最后更新elementCount，该字段标记了Vector集合中存储的元素个数。</p>
<h4 id="public-synchronized-int-capacity"><a href="#public-synchronized-int-capacity" class="headerlink" title="public synchronized int capacity()"></a>public synchronized int capacity()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> elementData.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回Vector集合的空间大小，既可以容纳的元素个数。</p>
<h4 id="public-synchronized-int-size"><a href="#public-synchronized-int-size" class="headerlink" title="public synchronized int size()"></a>public synchronized int size()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> elementCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> elementCount == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回Vector集合当前存储的元素个数。如果elementCount为0，那么isEmpty()方法就会返回true，否则返回false。</p>
<h4 id="public-Enumeration-lt-E-gt-elements"><a href="#public-Enumeration-lt-E-gt-elements" class="headerlink" title="public Enumeration&lt;E&gt; elements()"></a>public Enumeration&lt;E&gt; elements()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Enumeration&lt;E&gt; <span class="title">elements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Enumeration&lt;E&gt;() &#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> count &lt; elementCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">nextElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Vector.<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count &lt; elementCount) &#123;</span><br><span class="line">                    <span class="keyword">return</span> elementData(count++);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"Vector Enumeration"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;以枚举方式返回Vector集合中的每一个元素。</p>
<h4 id="public-boolean-contains-Object-o"><a href="#public-boolean-contains-Object-o" class="headerlink" title="public boolean contains(Object o)"></a>public boolean contains(Object o)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o, <span class="number">0</span>) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;判断当前Vector集合中是否含有元素o。如果Vector集合存储了一个及以上元素o，那么就返回true，否则返回false。</p>
<h4 id="public-int-indexOf-Object-o"><a href="#public-int-indexOf-Object-o" class="headerlink" title="public int indexOf(Object o)"></a>public int indexOf(Object o)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index ; i &lt; elementCount ; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index ; i &lt; elementCount ; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回元素o在Vector集合中第一次出现的位置（即o在集合中第一次被存储的位置）。如果元素o为null，那么就返回null第一次被存储的位置，否则返回非null元素在Vector集合中第一次出现的位置。如果元素o不存在于集合Vector中，那么返回-1。</p>
<h4 id="public-synchronized-int-lastIndexOf-Object-o"><a href="#public-synchronized-int-lastIndexOf-Object-o" class="headerlink" title="public synchronized int lastIndexOf(Object o)"></a>public synchronized int lastIndexOf(Object o)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lastIndexOf(o, elementCount-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(index + <span class="string">" &gt;= "</span>+ elementCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回元素o在Vector集合中最后一次出现的位置（即o在集合中最后一次被存储的位置）。将当前Vector集合从尾向首逐个遍历，如果元素o为null，那么就返回null最后一次被存储的位置，否则返回非null元素在Vector集合中最后一次出现的位置。如果元素o不存在于集合Vector中，那么返回-1。</p>
<h4 id="public-synchronized-E-elementAt-int-index"><a href="#public-synchronized-E-elementAt-int-index" class="headerlink" title="public synchronized E elementAt(int index)"></a>public synchronized E elementAt(int index)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">elementAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt;= "</span> + elementCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回Vector中index位置指定的元素。如果index指示位置大于Vector的元素个数（index &gt;= elementCount）则抛出边界溢出异常。实际调用<strong>elementData(int index)</strong>方法完成所有操作。</p>
<h4 id="E-elementData-int-index"><a href="#E-elementData-int-index" class="headerlink" title="E elementData(int index)"></a>E elementData(int index)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回Vector中index位置处的元素。</p>
<h4 id="public-synchronized-E-firstElement"><a href="#public-synchronized-E-firstElement" class="headerlink" title="public synchronized E firstElement()"></a>public synchronized E firstElement()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">firstElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> elementData(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回Vector集合中第一个元素。</p>
<h4 id="public-synchronized-E-lastElement"><a href="#public-synchronized-E-lastElement" class="headerlink" title="public synchronized E lastElement()"></a>public synchronized E lastElement()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">lastElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> elementData(elementCount - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回Vector集合中最后一个元素。</p>
<h4 id="public-synchronized-void-setElementAt-E-obj-int-index"><a href="#public-synchronized-void-setElementAt-E-obj-int-index" class="headerlink" title="public synchronized void setElementAt(E obj, int index)"></a>public synchronized void setElementAt(E obj, int index)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setElementAt</span><span class="params">(E obj, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt;= "</span> +</span><br><span class="line">                                                 elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    elementData[index] = obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将index位置处的元素置换为obj。</p>
<h4 id="public-synchronized-void-removeElementAt-int-index"><a href="#public-synchronized-void-removeElementAt-int-index" class="headerlink" title="public synchronized void removeElementAt(int index)"></a>public synchronized void removeElementAt(int index)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeElementAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt;= "</span> +</span><br><span class="line">                                                 elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> j = elementCount - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index, j);</span><br><span class="line">    &#125;</span><br><span class="line">    elementCount--;</span><br><span class="line">    elementData[elementCount] = <span class="keyword">null</span>; <span class="comment">/* to let gc do its work */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;移除index位置处的元素。因为元素移除属于结构化修改，所以需要维护modCount的值。接着需要通过边界检查判定index的合法性以避免边界溢出。然后将index位置之后的元素（不包括index）统一向前移动一个单位，便会覆盖移除掉index位置处的元素。最后维护elementCount并更新其值。</p>
<h4 id="public-synchronized-void-insertElementAt-E-obj-int-index"><a href="#public-synchronized-void-insertElementAt-E-obj-int-index" class="headerlink" title="public synchronized void insertElementAt(E obj, int index)"></a>public synchronized void insertElementAt(E obj, int index)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">insertElementAt</span><span class="params">(E obj, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index</span><br><span class="line">                                                 + <span class="string">" &gt; "</span> + elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, elementCount - index);</span><br><span class="line">    elementData[index] = obj;</span><br><span class="line">    elementCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在index位置处插入元素obj。因为元素插入属于结构化修改，所以需要维护modCount的值。接着需要通过边界检查判定index的合法性以避免边界溢出。然后判断当前集合空间是否足够，如果空间不足的话需要执行扩容操作。最后将index位置之后的元素（包括index）统一向后移动一个单位，加入传入的元素obj，并维护更新elementCount的值。</p>
<h4 id="public-synchronized-boolean-add-E-e"><a href="#public-synchronized-boolean-add-E-e" class="headerlink" title="public synchronized boolean add(E e)"></a>public synchronized boolean add(E e)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;向Vector集合中加入元素o，返回true表示加入成功。</p>
<h4 id="public-void-add-int-index-E-element"><a href="#public-void-add-int-index-E-element" class="headerlink" title="public void add(int index, E element)"></a>public void add(int index, E element)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    insertElementAt(element, index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;向Vector集合中index指定的位置处加入元素element。</p>
<h4 id="public-synchronized-void-addElement-E-obj"><a href="#public-synchronized-void-addElement-E-obj" class="headerlink" title="public synchronized void addElement(E obj)"></a>public synchronized void addElement(E obj)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addElement</span><span class="params">(E obj)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;向Vector集合中加入一个元素obj。因为元素加入属于结构化修改，所以需要维护modCount的值。加入元素之前需要先判断是否有必要执行扩容处理，如果需要的话先完成扩容处理提供足够的空间来容纳新元素。最后在集合尾部将元素obj加入到集合中。</p>
<h4 id="public-synchronized-boolean-addAll-int-index-Collection-lt-extends-E-gt-c"><a href="#public-synchronized-boolean-addAll-int-index-Collection-lt-extends-E-gt-c" class="headerlink" title="public synchronized boolean addAll(int index, Collection&lt;? extends E&gt; c)"></a>public synchronized boolean addAll(int index, Collection&lt;? extends E&gt; c)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    ensureCapacityHelper(elementCount + numNew);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = elementCount - index;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                         numMoved);</span><br><span class="line"></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">    elementCount += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将集合c中的元素全部加入到Vector集合中自index位置起的空间里。因为元素加入属于结构化修改，所以需要维护modCount的值。获取到c集合中的元素数据内容和元素个数，判断当前Vector集合是否有足够空间存储c中所有元素，如果空间不足则需要执行扩容操作。第11 ~ 13行代码将Vector集合中自index位置起，长度为c中集合元素数的空间里存储的元素统一向后移动，留出的空间被用来存储c中元素。最后将c中元素存储到Vector集合中指定位置的空间里，更新elementCount的值。</p>
<h4 id="public-synchronized-boolean-addAll-Collection-lt-extends-E-gt-c"><a href="#public-synchronized-boolean-addAll-Collection-lt-extends-E-gt-c" class="headerlink" title="public synchronized boolean addAll(Collection&lt;? extends E&gt; c)"></a>public synchronized boolean addAll(Collection&lt;? extends E&gt; c)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    ensureCapacityHelper(elementCount + numNew);</span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, elementCount, numNew);</span><br><span class="line">    elementCount += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将集合c中的元素全部加入到Vector集合中。因为元素加入属于结构化修改，所以需要维护modCount的值。获取到c集合中的元素数据内容和元素个数，判断当前Vector集合是否有足够空间存储c中所有元素，如果空间不足则需要执行扩容操作。空间充足时将c中元素存储到Vector集合中，更新elementCount的值。</p>
<h4 id="public-synchronized-E-remove-int-index"><a href="#public-synchronized-E-remove-int-index" class="headerlink" title="public synchronized E remove(int index)"></a>public synchronized E remove(int index)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = elementCount - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--elementCount] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;移除index位置处存储的元素并返回被移除的元素。</p>
<h4 id="public-synchronized-boolean-removeElement-Object-obj"><a href="#public-synchronized-boolean-removeElement-Object-obj" class="headerlink" title="public synchronized boolean removeElement(Object obj)"></a>public synchronized boolean removeElement(Object obj)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">removeElement</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> i = indexOf(obj);</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        removeElementAt(i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;移除Vector集合中删除元素obj。删除原则是先判断obj是否存在于集合中，如果不存在返回false，否则确定obj被存储的下标index最小的位置，并把该位置处存储的obj删除调，返回true标识成功删除元素obj。</p>
<h4 id="public-boolean-remove-Object-o"><a href="#public-boolean-remove-Object-o" class="headerlink" title="public boolean remove(Object o)"></a>public boolean remove(Object o)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeElement(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;移除Vector集合中删除元素o。</p>
<h4 id="public-synchronized-void-removeAllElements"><a href="#public-synchronized-void-removeAllElements" class="headerlink" title="public synchronized void removeAllElements()"></a>public synchronized void removeAllElements()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeAllElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// Let gc do its work</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elementCount; i++)</span><br><span class="line">        elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    elementCount = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;清空Vector集合中的所有元素。集合容量重置为0。</p>
<h4 id="public-synchronized-boolean-removeAll-Collection-lt-gt-c"><a href="#public-synchronized-boolean-removeAll-Collection-lt-gt-c" class="headerlink" title="public synchronized boolean removeAll(Collection&lt;?&gt; c)"></a>public synchronized boolean removeAll(Collection&lt;?&gt; c)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.removeAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;移除同时存在于Vector集合和c集合中的元素。调用的是AbstractCollection.removeAll(Collection&lt;?&gt; c)。</p>
<h4 id="public-void-clear"><a href="#public-void-clear" class="headerlink" title="public void clear()"></a>public void clear()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    removeAllElements();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;清空Vector集合中的所有元素。集合容量重置为0。</p>
<h4 id="public-synchronized-Object-clone"><a href="#public-synchronized-Object-clone" class="headerlink" title="public synchronized Object clone()"></a>public synchronized Object clone()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        Vector&lt;E&gt; v = (Vector&lt;E&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">        v.elementData = Arrays.copyOf(elementData, elementCount);</span><br><span class="line">        v.modCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">// this shouldn't happen, since we are Cloneable</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;对象克隆复制。浅度复制，对复制内容的修改会在Vector集合中显现，反之亦然。</p>
<h4 id="public-synchronized-Object-toArray"><a href="#public-synchronized-Object-toArray" class="headerlink" title="public synchronized Object[] toArray()"></a>public synchronized Object[] toArray()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object[] toArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(elementData, elementCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将Vector集合中的元素按照数组的方式返回。</p>
<h4 id="public-synchronized-lt-T-gt-T-toArray-T-a"><a href="#public-synchronized-lt-T-gt-T-toArray-T-a" class="headerlink" title="public synchronized &lt;T&gt; T[] toArray(T[] a)"></a>public synchronized &lt;T&gt; T[] toArray(T[] a)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; elementCount)</span><br><span class="line">        <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, elementCount, a.getClass());</span><br><span class="line"></span><br><span class="line">    System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, elementCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; elementCount)</span><br><span class="line">        a[elementCount] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将Vector集合中的元素以数组的方式存储到数组a中。如果a的空间小于Vector集合的元素数，那么就返回一个新的数组对象，该对象中以a的类型为基础，且存储的是Vector集合中的元素数据内容。如果a的长度大于集合中存储的元素总数，那么a数组中最后一个元素的下一个存储位置会被置为null，如果集合中没有存储任何null元素，那么这个操作执行完成后便可以非常方便的得到集合中存储的元素总数。</p>
<h4 id="E-elementData-int-index-1"><a href="#E-elementData-int-index-1" class="headerlink" title="E elementData(int index)"></a>E elementData(int index)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回Vector集合中index位置处的元素。</p>
<h4 id="public-synchronized-E-get-int-index"><a href="#public-synchronized-E-get-int-index" class="headerlink" title="public synchronized E get(int index)"></a>public synchronized E get(int index)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回Vector集合中index位置处的元素。在有效使用index之前对index做了边界校验，避免越界溢出发生。</p>
<h4 id="public-synchronized-E-set-int-index-E-element"><a href="#public-synchronized-E-set-int-index-E-element" class="headerlink" title="public synchronized E set(int index, E element)"></a>public synchronized E set(int index, E element)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将Vector集合中index位置处的元素替换为element，并返回被替换的元素。</p>
<h4 id="public-synchronized-boolean-containsAll-Collection-lt-gt-c"><a href="#public-synchronized-boolean-containsAll-Collection-lt-gt-c" class="headerlink" title="public synchronized boolean containsAll(Collection&lt;?&gt; c)"></a>public synchronized boolean containsAll(Collection&lt;?&gt; c)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.containsAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;判断Vector集合中是否包含c中所有元素。如果Vecto集合包含c中所有元素，那么返回true，否则返回false。实际调用AbstractCollection.containsAll(Collection&lt;?&gt; c)完成操作。</p>
<h4 id="public-synchronized-boolean-retainAll-Collection-lt-gt-c"><a href="#public-synchronized-boolean-retainAll-Collection-lt-gt-c" class="headerlink" title="public synchronized boolean retainAll(Collection&lt;?&gt; c)"></a>public synchronized boolean retainAll(Collection&lt;?&gt; c)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.retainAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;保留同时包含在Vector集合和c集合中的元素，对于只存在于Vector集合，不存在于c集合的元素会被删除掉，类似于数学领域内的两个集合取交集操作。实际调用AbstractCollection.retainAll(Collection&lt;?&gt; c)完成操作。</p>
<h4 id="public-synchronized-boolean-equals-Object-o"><a href="#public-synchronized-boolean-equals-Object-o" class="headerlink" title="public synchronized boolean equals(Object o)"></a>public synchronized boolean equals(Object o)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.equals(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;判断当前Vector集合是否等于对象o。实际调用AbstractList.equals(Object o)完成操作。</p>
<h4 id="public-synchronized-int-hashCode"><a href="#public-synchronized-int-hashCode" class="headerlink" title="public synchronized int hashCode()"></a>public synchronized int hashCode()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.hashCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回当前Vector集合的散列值。实际调用AbstractList.hashCode()完成操作。</p>
<h4 id="public-synchronized-String-toString"><a href="#public-synchronized-String-toString" class="headerlink" title="public synchronized String toString()"></a>public synchronized String toString()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回当前Vector集合的字符串表示，内部元素也以字符串形式表示。实际调用AbstractCollection.toString()完成操作。</p>
<h4 id="public-synchronized-List-lt-E-gt-subList-int-fromIndex-int-toIndex"><a href="#public-synchronized-List-lt-E-gt-subList-int-fromIndex-int-toIndex" class="headerlink" title="public synchronized List&lt;E&gt; subList(int fromIndex, int toIndex)"></a>public synchronized List&lt;E&gt; subList(int fromIndex, int toIndex)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.synchronizedList(<span class="keyword">super</span>.subList(fromIndex, toIndex), <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过调用AbstractList.subList(int fromIndex, int toIndex)方法获取Vector集合中自fromIndex位置起，到toIndex位置之间的子集合并返回。由于Vector被应用于多线程环境，而subList(int fromIndex, int toIndex)返回的是一个非线程安全的随机访问集合，所以通过Collections.synchronizedList(List<t> list, Object mutex)可以保证返回的subList具有多线程环境的线程安全特性。</t></p>
<h4 id="protected-synchronized-void-removeRange-int-fromIndex-int-toIndex"><a href="#protected-synchronized-void-removeRange-int-fromIndex-int-toIndex" class="headerlink" title="protected synchronized void removeRange(int fromIndex, int toIndex)"></a>protected synchronized void removeRange(int fromIndex, int toIndex)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numMoved = elementCount - toIndex;</span><br><span class="line">    System.arraycopy(elementData, toIndex, elementData, fromIndex,</span><br><span class="line">                     numMoved);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Let gc do its work</span></span><br><span class="line">    <span class="keyword">int</span> newElementCount = elementCount - (toIndex-fromIndex);</span><br><span class="line">    <span class="keyword">while</span> (elementCount != newElementCount)</span><br><span class="line">        elementData[--elementCount] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;移除Vector集合中自fromIndex位置起，到toIndex位置之间的所有元素。操作过程可见图1：</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1543842373/BlogImages/java-collection/list/Vector-removeRange-example.png" alt="1543839602703"></p>
<div align="center">
<div align="center">图 - 1</div>
&emsp;
</div>

<p>&emsp;&emsp;在alpha阶段由fromIndex和toIndex指定了需要删除的范围。第3 ~ 5行代码执行完之后则到达bravo阶段。灰色区域为fromIndex之前的元素，无变化。红色区域的元素由alpha阶段toIndex位置及之后的元素向左移动得到。第8行代码重新计算得到了newElementCount，也是从集合尾部删除元素操作的终点位置。在charlie中，elementCount逐个向左移动并删除元素释放空间，直到其到达newElementCount位置便停止操作。</p>
<h4 id="private-void-writeObject-java-io-ObjectOutputStream-s"><a href="#private-void-writeObject-java-io-ObjectOutputStream-s" class="headerlink" title="private void writeObject(java.io.ObjectOutputStream s)"></a>private void writeObject(java.io.ObjectOutputStream s)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> java.io.ObjectOutputStream.PutField fields = s.putFields();</span><br><span class="line">    <span class="keyword">final</span> Object[] data;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        fields.put(<span class="string">"capacityIncrement"</span>, capacityIncrement);</span><br><span class="line">        fields.put(<span class="string">"elementCount"</span>, elementCount);</span><br><span class="line">        data = elementData.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    fields.put(<span class="string">"elementData"</span>, data);</span><br><span class="line">    s.writeFields();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;序列化写操作。将当前Vector集合对象的内容以自定义的方式重新实现了其序列化过程。</p>
<h4 id="public-synchronized-Iterator-lt-E-gt-iterator"><a href="#public-synchronized-Iterator-lt-E-gt-iterator" class="headerlink" title="public synchronized Iterator&lt;E&gt; iterator()"></a>public synchronized Iterator&lt;E&gt; iterator()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回一个基于Vector集合的迭代器。该迭代器只能对集合做向后遍历。Itr类的相关实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Racy but within spec, since modifications are checked</span></span><br><span class="line">        <span class="comment">// within or after synchronization in next/previous</span></span><br><span class="line">        <span class="keyword">return</span> cursor != elementCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Vector.<span class="keyword">this</span>) &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">int</span> i = cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> elementData(lastRet = i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        <span class="keyword">synchronized</span> (Vector.<span class="keyword">this</span>) &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            Vector.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="public-synchronized-ListIterator-lt-E-gt-listIterator-int-index"><a href="#public-synchronized-ListIterator-lt-E-gt-listIterator-int-index" class="headerlink" title="public synchronized ListIterator&lt;E&gt; listIterator(int index)"></a>public synchronized ListIterator&lt;E&gt; listIterator(int index)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回一个基于Vector集合的可以从index位置开始遍历的迭代器。如果index参数没有传，那么默认从首部位置开始迭代。该迭代器可以对Vector集合进行双向遍历。ListItr(0)的相关实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">extends</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    ListItr(<span class="keyword">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        cursor = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Vector.<span class="keyword">this</span>) &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">int</span> i = cursor - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            cursor = i;</span><br><span class="line">            <span class="keyword">return</span> elementData(lastRet = i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        <span class="keyword">synchronized</span> (Vector.<span class="keyword">this</span>) &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            Vector.<span class="keyword">this</span>.set(lastRet, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        <span class="keyword">synchronized</span> (Vector.<span class="keyword">this</span>) &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            Vector.<span class="keyword">this</span>.add(i, e);</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li><p><strong>Enumeration和Iterator的联系</strong></p>
<p>&emsp;&emsp;Enumeration接口是JDK1.0时推出的，在JDK1.5之后为Enumeration接口进行了扩充，增加了泛型的操作应用。Iterator迭代器取代了 Enumeration的功能，同时增添了删除元素的方法，并且对方法的名称进行了改进。为什么还要使用Enumeration？这是因为一些比较古老的系统或者类库中的方法还在使用Enumeration接口，因此为了兼容，继续保留Enumeration相关定义保证代码正常有效。本文中涉及到的Vector就仍有Enumeration的具体实现。还有Iterator 是 Fast-Fail的，但 Enumeration不是，也就是说，Iteartor可以对非自身作出的结构化修改作出响应，而Enumeration没有这方面的判断和操作。</p>
</li>
<li><p><strong>Vector实现writeObject(java.io.ObjectOutputStream s)的意义</strong></p>
<p>&emsp;&emsp;和ArrayList一样，Vector自己实现了writeObject方法用来对elementData、elementCount和capacityIncrement执行序列化操作。Vector通过writeObject把elementData、elementCount和capacityIncrement里的元素写入到输出流ObjectOutputStream )中，通过默认处理从输入流（ObjectInputStream ）读取到被序列化的数据并反序列化之后存储到elementData。</p>
<p>&emsp;&emsp;需要注意的是，writeObject方法都被声明为私有方法，且在Vector内部没有任何地方调用了该方法。实际上，这两个方法是通过反射的方式出现在了ObjectOutputStream、的方法writeObject()和调用栈中。</p>
</li>
<li><p><strong>为什么线程安全的Vector会比非线程安全的ArrayList慢</strong></p>
<p>&emsp;&emsp;多线程环境中涉及到一个概念—上下文切换。由于CPU同一个时刻只能执行一个任务，所以如果让CPU在不同的任务之间来回切换任务执行的话不可避免的会执行保存当前任务状态、加载下一个任务状态、执行下一个任务等过程。任务的状态保存和再加载过程被称为上下文切换。而上下文切换会导致直接直接的性能消耗：状态和任务的加载、再加载，也包括间接的性能消耗：不同线程之间的数据共享等问题。</p>
</li>
</ol>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>LINFO. <a href="http://www.linfo.org/context_switch.html" target="_blank" rel="noopener">Context Switch Definition</a> [E]</li>
<li>Wikipedia. <a href="https://zh.wikipedia.org/wiki/%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BA%A4%E6%8F%9B" target="_blank" rel="noopener">上下文交换</a> [E]</li>
<li>rhwayfunn. <a href="https://blog.csdn.net/u011116672/article/details/51136044" target="_blank" rel="noopener">Java并发编程系列之三十：多线程的代价</a> [E]</li>
</ol>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java I/O 06 - DataInputStream &amp; DataOutputStream</title>
    <url>/2018/java-DataInputStream-DataOutputStream.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;关于<em> <strong>java.io.DataInputStream</strong> </em> 和 <em> <strong>java.io.DataOutputStream</strong> </em>的部分笔记，这两个类共同实现对数据类型为Java原生数据类型的数据的字节输入、输出流操作。本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;DataInputStream和DataOutputStream这两个类实现了Java原生数据类型的写入和读取操作。DataInputStream以一种不依赖于特定运行平台的方式从底层输入流中将Java类型的数据读出进行计算处理。但是DataInputStream不保证多线程环境下的安全性，需要开发人员自己来保证多线程环境下可以正确无误的使用该类中的方法。</p>
<p>&emsp;&emsp;DataOutputStream则用来将Java的原生数据类型数据写入到底层的输出流中。</p>
<p>&emsp;</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DataInputStream</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.io.InputStream</span><br><span class="line">    --java.io.FilterInputStream</span><br><span class="line">      --java.io.DataInputStream</span><br><span class="line"></span><br><span class="line"><span class="comment">// DataOutputStream</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.io.OutputStream</span><br><span class="line">    --java.io.FilterOutputStream</span><br><span class="line">      --java.io.DataOutputStream</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类名</th>
<th style="text-align:center">实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">DataInputStream</td>
<td style="text-align:center">Closeable, DataInput, AutoCloseable</td>
</tr>
<tr>
<td style="text-align:center">DataOutputStream</td>
<td style="text-align:center">Closeable, DataOutput, Flushable, AutoCloseable</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="DataInputStream"><a href="#DataInputStream" class="headerlink" title="DataInputStream"></a>DataInputStream</h2><h3 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="public-final-void-readFully-byte-b-int-off-int-len"><a href="#public-final-void-readFully-byte-b-int-off-int-len" class="headerlink" title="public final void readFully(byte b[], int off, int len)"></a>public final void readFully(byte b[], int off, int len)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">readFully</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &lt; len) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = in.read(b, off + n, len - n);</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</span><br><span class="line">        n += count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">readFully</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    readFully(b, <span class="number">0</span>, b.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;读取字节流数据并保存到入参缓存数组b中，直到把入参b填充完全时才会结束。第2 ~ 3行代码用来做参数校验，如果长度小于0，那么会返回一个异常信息给方法调用方，防止越界。第5 ~ 10行代码执行具体的字节数据读取，第6行返回当前读取完成后实际成功读取的字节数，如果实际读取的字节数小于0，那么返回一个文件结束异常，此时b中包含实际读取的内容数据。第9行用于记录累计读取的字节数，如果累计读取字节数达到了入参读取长度，那么结束循环读取操作，b中包含长度为len的实际读取的内容。由于这个方法是个阻塞方法，因此如果因为一些原因导致当前底层输入流在没有到达流结束位置但暂时无法提供新的数据时，这个方法会一直等待，直到新的数据到达被读取保存到b中或者一个IOException、EOFException异常被返回。</p>
<p>&emsp;&emsp;在浏览代码时发现，DataInputStream含有继承自父类InputStream的方法<strong>read(byte b[], int off, int len)</strong>和<strong>read(byte b[])</strong>。这两个方法和对应的readFully方法的入参完全一致，最终实现的效果也是一样的，都是从底层输入流中读取字节内容并保存到入参字节数组b中。但是这两个方法有一些区别：</p>
<ol>
<li>readFully在无异常执行结束后，数组b中实际填充的字节长度等于入参长度值（默认为数组b的长度），而read方法执行后数组b实际填充的字节长度小于等于入参长度值；</li>
<li>readFully方法通过抛出EOFException标识已经到达结束位置，而read方法则通过返回-1（int类型）来标识结束；</li>
<li>readFully方法如果入参缓存数组长度大于底层输入流的完整长度，那么最后会返回一个EOFException异常来结束方法调用，而read方法会正常结束调用；</li>
<li>通过使用readFully可以保证读取到长度明确的流内容，这可以保证读取内容的完整性。而read方法则无法保证实际读取的内容长度，需要方法调用方执行另外的判断操作来保证。</li>
</ol>
<h4 id="public-final-int-skipBytes-int-n"><a href="#public-final-int-skipBytes-int-n" class="headerlink" title="public final int skipBytes(int n)"></a>public final int skipBytes(int n)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">skipBytes</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((total&lt;n) &amp;&amp; ((cur = (<span class="keyword">int</span>) in.skip(n-total)) &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">        total += cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;跳过底层输入流中指定长度的字节内容，并将下次开始读取的位置从当前位置向后偏移n个单位长度。需要注意的是，实际调用时，实际跳过的长度可能小于n，因为当输入流中剩余未读的数据长度可能小于入参跳过长度n。</p>
<h4 id="public-final-short-readShort"><a href="#public-final-short-readShort" class="headerlink" title="public final short readShort()"></a>public final short readShort()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">short</span> <span class="title">readShort</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ch1 = in.read();</span><br><span class="line">    <span class="keyword">int</span> ch2 = in.read();</span><br><span class="line">    <span class="keyword">if</span> ((ch1 | ch2) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">short</span>)((ch1 &lt;&lt; <span class="number">8</span>) + (ch2 &lt;&lt; <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;读出一个有符号short型数据。借鉴参考的数学公式是：</p>
<blockquote>
<p> (short)((a &lt;&lt; 8) | (b &amp; 0xff))</p>
</blockquote>
<p>&emsp;&emsp;在依次读出两个字节的数据后，将第一次读出的数据（即左高八位）向左移动8个进制位，至此完成了左高八位数据的处理，然后将第二次读出的数据（即右低八位）与<strong>11111111（共32位，左高24位均为0）</strong>按位求与。这样执行后，第二次读出的数据将只保留低八位的二进制位，也就是右低八位的数据。最后将左移后的左高八位数据和按位求与后的右低八位数据按位求或（这两个数据都是以32位形式存在），得到最终的32位比特数值，最后的强制转换执行高位截取，只保留右低十六位的比特位，即最终需要返回的short型数据。</p>
<h4 id="public-final-int-readUnsignedShort"><a href="#public-final-int-readUnsignedShort" class="headerlink" title="public final int readUnsignedShort()"></a>public final int readUnsignedShort()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">readUnsignedShort</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ch1 = in.read();</span><br><span class="line">    <span class="keyword">int</span> ch2 = in.read();</span><br><span class="line">    <span class="keyword">if</span> ((ch1 | ch2) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</span><br><span class="line">    <span class="keyword">return</span> (ch1 &lt;&lt; <span class="number">8</span>) + (ch2 &lt;&lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;读出一个无符号short型数据。借鉴参考的数学公式是：</p>
<blockquote>
<p> (((a &amp; 0xff) &lt;&lt; 8) | (b &amp; 0xff))</p>
</blockquote>
<p>&emsp;&emsp;和readShort方法不同的是，readUnsignedShort将第一次读出的数据也和0xff做了按位求与操作。因为在java中int型数据不存在有符号无符号这一说法，所以这么做以后就把第一次读出的数据的高24位全部置为0，消除了符号位可能带来的影响。紧接着将其左移8位完成左高八位数据的处理。然后将第二次读出的数据执行和readShort方法一样的操作，最后将两个数据按位求或，即得到最终需要返回的无符号的short型数据。</p>
<h4 id="public-final-long-readLong"><a href="#public-final-long-readLong" class="headerlink" title="public final long readLong()"></a>public final long readLong()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">readLong</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    readFully(readBuffer, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> (((<span class="keyword">long</span>)readBuffer[<span class="number">0</span>] &lt;&lt; <span class="number">56</span>) +</span><br><span class="line">            ((<span class="keyword">long</span>)(readBuffer[<span class="number">1</span>] &amp; <span class="number">255</span>) &lt;&lt; <span class="number">48</span>) +</span><br><span class="line">            ((<span class="keyword">long</span>)(readBuffer[<span class="number">2</span>] &amp; <span class="number">255</span>) &lt;&lt; <span class="number">40</span>) +</span><br><span class="line">            ((<span class="keyword">long</span>)(readBuffer[<span class="number">3</span>] &amp; <span class="number">255</span>) &lt;&lt; <span class="number">32</span>) +</span><br><span class="line">            ((<span class="keyword">long</span>)(readBuffer[<span class="number">4</span>] &amp; <span class="number">255</span>) &lt;&lt; <span class="number">24</span>) +</span><br><span class="line">            ((readBuffer[<span class="number">5</span>] &amp; <span class="number">255</span>) &lt;&lt; <span class="number">16</span>) +</span><br><span class="line">            ((readBuffer[<span class="number">6</span>] &amp; <span class="number">255</span>) &lt;&lt;  <span class="number">8</span>) +</span><br><span class="line">            ((readBuffer[<span class="number">7</span>] &amp; <span class="number">255</span>) &lt;&lt;  <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;读出一个无符号short型数据。借鉴参考的数学公式是：</p>
<blockquote>
<p>(((long)(a &amp; 0xff) &lt;&lt; 56) | ((long)(b &amp; 0xff) &lt;&lt; 48) |  ((long)(c &amp; 0xff) &lt;&lt; 40) | ((long)(d &amp; 0xff) &lt;&lt; 32) |<br>  ((long)(e &amp; 0xff) &lt;&lt; 24) |  ((long)(f &amp; 0xff) &lt;&lt; 16) |  ((long)(g &amp; 0xff) &lt;&lt;  8) |  ((long)(h &amp; 0xff)))</p>
</blockquote>
<p>&emsp;&emsp;读出一个long类型数据并返回。第2行代码首先一次读出8个长度的byte数组内容，然后由第3 ~ 10行代码完成数据类型的转换。在代码中，都有一个操作，那就是readBuffer[n] &amp; 255。这是因为readBuffer数组中存储的是byte类型的数据，而底层依赖调用的read方法返回的int类型数据，也就是说，在从底层输入流中读出一个int类型的数据后，会转成byte存入readBuffer数组中。如果从底层输入流中读出的是一个大于127的int值，这个值在完成byte转换后就变成了一个负数而不是转换前的大于127的值，所以为了保持一致性，就将byte类型的数据首先与255（也就是0XFF）按位相与，这样就可以正确的将一个byte类型的数据转成int类型。由于int和long类型数据都不存在有无符号这一说法，所以int可以正确无误的转成long型。最后按照从左到右的顺序依次构建long型数据的二进制表示并返回最终转换后的结果。</p>
<h4 id="public-final-static-String-readUTF-DataInput-in"><a href="#public-final-static-String-readUTF-DataInput-in" class="headerlink" title="public final static String readUTF(DataInput in)"></a>public final static String readUTF(DataInput in)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String <span class="title">readUTF</span><span class="params">(DataInput in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> utflen = in.readUnsignedShort();</span><br><span class="line">    <span class="keyword">byte</span>[] bytearr = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">char</span>[] chararr = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (in <span class="keyword">instanceof</span> DataInputStream) &#123;</span><br><span class="line">        DataInputStream dis = (DataInputStream)in;</span><br><span class="line">        <span class="keyword">if</span> (dis.bytearr.length &lt; utflen)&#123;</span><br><span class="line">            dis.bytearr = <span class="keyword">new</span> <span class="keyword">byte</span>[utflen*<span class="number">2</span>];</span><br><span class="line">            dis.chararr = <span class="keyword">new</span> <span class="keyword">char</span>[utflen*<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        chararr = dis.chararr;</span><br><span class="line">        bytearr = dis.bytearr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bytearr = <span class="keyword">new</span> <span class="keyword">byte</span>[utflen];</span><br><span class="line">        chararr = <span class="keyword">new</span> <span class="keyword">char</span>[utflen];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c, char2, char3;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> chararr_count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    in.readFully(bytearr, <span class="number">0</span>, utflen);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (count &lt; utflen) &#123;</span><br><span class="line">        c = (<span class="keyword">int</span>) bytearr[count] &amp; <span class="number">0xff</span>;</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">127</span>) <span class="keyword">break</span>;</span><br><span class="line">        count++;</span><br><span class="line">        chararr[chararr_count++]=(<span class="keyword">char</span>)c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (count &lt; utflen) &#123;</span><br><span class="line">        c = (<span class="keyword">int</span>) bytearr[count] &amp; <span class="number">0xff</span>;</span><br><span class="line">        <span class="keyword">switch</span> (c &gt;&gt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">case</span> <span class="number">4</span>: <span class="keyword">case</span> <span class="number">5</span>: <span class="keyword">case</span> <span class="number">6</span>: <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                <span class="comment">/* 0xxxxxxx*/</span></span><br><span class="line">                count++;</span><br><span class="line">                chararr[chararr_count++]=(<span class="keyword">char</span>)c;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">12</span>: <span class="keyword">case</span> <span class="number">13</span>:</span><br><span class="line">                <span class="comment">/* 110x xxxx   10xx xxxx*/</span></span><br><span class="line">                count += <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (count &gt; utflen)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> UTFDataFormatException(</span><br><span class="line">                    <span class="string">"malformed input: partial character at end"</span>);</span><br><span class="line">                char2 = (<span class="keyword">int</span>) bytearr[count-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> ((char2 &amp; <span class="number">0xC0</span>) != <span class="number">0x80</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> UTFDataFormatException(</span><br><span class="line">                    <span class="string">"malformed input around byte "</span> + count);</span><br><span class="line">                chararr[chararr_count++]=(<span class="keyword">char</span>)(((c &amp; <span class="number">0x1F</span>) &lt;&lt; <span class="number">6</span>) |</span><br><span class="line">                                                (char2 &amp; <span class="number">0x3F</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">14</span>:</span><br><span class="line">                <span class="comment">/* 1110 xxxx  10xx xxxx  10xx xxxx */</span></span><br><span class="line">                count += <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">if</span> (count &gt; utflen)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> UTFDataFormatException(</span><br><span class="line">                    <span class="string">"malformed input: partial character at end"</span>);</span><br><span class="line">                char2 = (<span class="keyword">int</span>) bytearr[count-<span class="number">2</span>];</span><br><span class="line">                char3 = (<span class="keyword">int</span>) bytearr[count-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (((char2 &amp; <span class="number">0xC0</span>) != <span class="number">0x80</span>) || ((char3 &amp; <span class="number">0xC0</span>) != <span class="number">0x80</span>))</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> UTFDataFormatException(</span><br><span class="line">                    <span class="string">"malformed input around byte "</span> + (count-<span class="number">1</span>));</span><br><span class="line">                chararr[chararr_count++]=(<span class="keyword">char</span>)(((c     &amp; <span class="number">0x0F</span>) &lt;&lt; <span class="number">12</span>) |</span><br><span class="line">                                                ((char2 &amp; <span class="number">0x3F</span>) &lt;&lt; <span class="number">6</span>)  |</span><br><span class="line">                                                ((char3 &amp; <span class="number">0x3F</span>) &lt;&lt; <span class="number">0</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">/* 10xx xxxx,  1111 xxxx */</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UTFDataFormatException(</span><br><span class="line">                    <span class="string">"malformed input around byte "</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The number of chars produced may be less than utflen</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(chararr, <span class="number">0</span>, chararr_count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;读出一段指定长度的UTF-8格式的字符串并返回。第2行代码从输入流中读出一个无符号short型数值，这个数值表示接下来需要从底层输入流中读取的数据量。第22行代码执行后，就会从底层输入流中读取确定长度的数据。第24 ~ 29行代码把数值小于128的数据转成了基础的ASCII码字符。第31 ~ 72行数据用来把数据转换成Unicode格式的字符，采用的是修订版的UTF-8标准。每次遍历一个数组元素，将其转成int型数值后右移4位判断转换关系：第34 ~ 38行代码将码值在U+0000 - U+007F之间的字符转换成了对应的UTF格式，这部分数据只需要用一个字节即可存储。第39 ~ 51行用来处理码值在U+0080 - U+07FF之间的字符，第46行的判断用来检查第二个字节是否满足10XXXXXX的格式。第52 ~ 66行代码用来处理码值在U+0800 - U+FFFF之间的字符。如果不满足上述三种情况，那么认为读取的数据是异常的并抛出异常。在最后将转换后的char字符数组转成一个完整的String字符串并返回。</p>
<p>&emsp;</p>
<h2 id="DataOutputStream"><a href="#DataOutputStream" class="headerlink" title="DataOutputStream"></a>DataOutputStream</h2><h3 id="部分方法-1"><a href="#部分方法-1" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="private-void-incCount-int-value"><a href="#private-void-incCount-int-value" class="headerlink" title="private void incCount(int value)"></a>private void incCount(int value)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">incCount</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = written + value;</span><br><span class="line">    <span class="keyword">if</span> (temp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        temp = Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    written = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;记录更新已经写入的字节数。因为written的类型是int，所以如果发生了溢出以后，那么就一律标定为int类型的最大值。</p>
<h4 id="public-synchronized-void-write-int-b"><a href="#public-synchronized-void-write-int-b" class="headerlink" title="public synchronized void write(int b)"></a>public synchronized void write(int b)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    out.write(b);</span><br><span class="line">    incCount(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    out.write(b, off, len);</span><br><span class="line">    incCount(len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;继承自OutputStream的write方法，如果写入完成后无异常，那么就更新已经写入的字节数信息。</p>
<h4 id="基本类型写入方法"><a href="#基本类型写入方法" class="headerlink" title="基本类型写入方法"></a>基本类型写入方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//写入一个boolean值，1 - true ，0 - false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeBoolean</span><span class="params">(<span class="keyword">boolean</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    out.write(v ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    incCount(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入一个byte值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeByte</span><span class="params">(<span class="keyword">int</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    out.write(v);</span><br><span class="line">    incCount(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写入一个short值，每个short值由两个字节构成</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeShort</span><span class="params">(<span class="keyword">int</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    out.write((v &gt;&gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    out.write((v &gt;&gt;&gt; <span class="number">0</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    incCount(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入一个char值，每个char值由两个字节构成</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeChar</span><span class="params">(<span class="keyword">int</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    out.write((v &gt;&gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    out.write((v &gt;&gt;&gt; <span class="number">0</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    incCount(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入一个int值，每个int值由四个字节构成</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeInt</span><span class="params">(<span class="keyword">int</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    out.write((v &gt;&gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    out.write((v &gt;&gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    out.write((v &gt;&gt;&gt;  <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    out.write((v &gt;&gt;&gt;  <span class="number">0</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    incCount(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入一个long值，每个long值由八个字节构成</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeLong</span><span class="params">(<span class="keyword">long</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    writeBuffer[<span class="number">0</span>] = (<span class="keyword">byte</span>)(v &gt;&gt;&gt; <span class="number">56</span>);</span><br><span class="line">    writeBuffer[<span class="number">1</span>] = (<span class="keyword">byte</span>)(v &gt;&gt;&gt; <span class="number">48</span>);</span><br><span class="line">    writeBuffer[<span class="number">2</span>] = (<span class="keyword">byte</span>)(v &gt;&gt;&gt; <span class="number">40</span>);</span><br><span class="line">    writeBuffer[<span class="number">3</span>] = (<span class="keyword">byte</span>)(v &gt;&gt;&gt; <span class="number">32</span>);</span><br><span class="line">    writeBuffer[<span class="number">4</span>] = (<span class="keyword">byte</span>)(v &gt;&gt;&gt; <span class="number">24</span>);</span><br><span class="line">    writeBuffer[<span class="number">5</span>] = (<span class="keyword">byte</span>)(v &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    writeBuffer[<span class="number">6</span>] = (<span class="keyword">byte</span>)(v &gt;&gt;&gt;  <span class="number">8</span>);</span><br><span class="line">    writeBuffer[<span class="number">7</span>] = (<span class="keyword">byte</span>)(v &gt;&gt;&gt;  <span class="number">0</span>);</span><br><span class="line">    out.write(writeBuffer, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">    incCount(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入一个float值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeFloat</span><span class="params">(<span class="keyword">float</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    writeInt(Float.floatToIntBits(v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入一个double值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeDouble</span><span class="params">(<span class="keyword">double</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    writeLong(Double.doubleToLongBits(v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="public-final-void-writeBytes-String-s"><a href="#public-final-void-writeBytes-String-s" class="headerlink" title="public final void writeBytes(String s)"></a>public final void writeBytes(String s)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeBytes</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i++) &#123;</span><br><span class="line">        out.write((<span class="keyword">byte</span>)s.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    incCount(len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;写入一个String到底层输出流中，需要注意的是，这个方法仅适用于单字节字符，即构成String的每个字符都是单字节的。如果是写入类似于Unicode这样的多字节字符，那么由于writeBytes()仅写入了低八位数据，所以会导致写入和读取的内容不一致的问题。除此之外，在DataInputStream中，并没有对应的读取方法来获取一个写入的String字符串，所以该方法需要慎用。</p>
<h4 id="public-final-void-writeChars-String-s"><a href="#public-final-void-writeChars-String-s" class="headerlink" title="public final void writeChars(String s)"></a>public final void writeChars(String s)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeChars</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = s.charAt(i);</span><br><span class="line">        out.write((v &gt;&gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">        out.write((v &gt;&gt;&gt; <span class="number">0</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    incCount(len * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;依次将入参String的每个字符写入到底层输出流中。如果执行过程无异常抛出，那么更新当前写入的字节数，需要注意的是，本次方法调用实际写入的字节数为入参String长度的两倍。</p>
<h4 id="static-int-writeUTF-String-str-DataOutput-out"><a href="#static-int-writeUTF-String-str-DataOutput-out" class="headerlink" title="static int writeUTF(String str, DataOutput out)"></a>static int writeUTF(String str, DataOutput out)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">writeUTF</span><span class="params">(String str, DataOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> strlen = str.length();</span><br><span class="line">    <span class="keyword">int</span> utflen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> c, count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* use charAt instead of copying String to char array */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strlen; i++) &#123;</span><br><span class="line">        c = str.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> ((c &gt;= <span class="number">0x0001</span>) &amp;&amp; (c &lt;= <span class="number">0x007F</span>)) &#123;</span><br><span class="line">            utflen++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &gt; <span class="number">0x07FF</span>) &#123;</span><br><span class="line">            utflen += <span class="number">3</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            utflen += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (utflen &gt; <span class="number">65535</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UTFDataFormatException(</span><br><span class="line">        <span class="string">"encoded string too long: "</span> + utflen + <span class="string">" bytes"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] bytearr = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (out <span class="keyword">instanceof</span> DataOutputStream) &#123;</span><br><span class="line">        DataOutputStream dos = (DataOutputStream)out;</span><br><span class="line">        <span class="keyword">if</span>(dos.bytearr == <span class="keyword">null</span> || (dos.bytearr.length &lt; (utflen+<span class="number">2</span>)))</span><br><span class="line">            dos.bytearr = <span class="keyword">new</span> <span class="keyword">byte</span>[(utflen*<span class="number">2</span>) + <span class="number">2</span>];</span><br><span class="line">        bytearr = dos.bytearr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bytearr = <span class="keyword">new</span> <span class="keyword">byte</span>[utflen+<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bytearr[count++] = (<span class="keyword">byte</span>) ((utflen &gt;&gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    bytearr[count++] = (<span class="keyword">byte</span>) ((utflen &gt;&gt;&gt; <span class="number">0</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;strlen; i++) &#123;</span><br><span class="line">        c = str.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (!((c &gt;= <span class="number">0x0001</span>) &amp;&amp; (c &lt;= <span class="number">0x007F</span>))) <span class="keyword">break</span>;</span><br><span class="line">        bytearr[count++] = (<span class="keyword">byte</span>) c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;i &lt; strlen; i++)&#123;</span><br><span class="line">        c = str.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> ((c &gt;= <span class="number">0x0001</span>) &amp;&amp; (c &lt;= <span class="number">0x007F</span>)) &#123;</span><br><span class="line">            bytearr[count++] = (<span class="keyword">byte</span>) c;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &gt; <span class="number">0x07FF</span>) &#123;</span><br><span class="line">            bytearr[count++] = (<span class="keyword">byte</span>) (<span class="number">0xE0</span> | ((c &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0x0F</span>));</span><br><span class="line">            bytearr[count++] = (<span class="keyword">byte</span>) (<span class="number">0x80</span> | ((c &gt;&gt;  <span class="number">6</span>) &amp; <span class="number">0x3F</span>));</span><br><span class="line">            bytearr[count++] = (<span class="keyword">byte</span>) (<span class="number">0x80</span> | ((c &gt;&gt;  <span class="number">0</span>) &amp; <span class="number">0x3F</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            bytearr[count++] = (<span class="keyword">byte</span>) (<span class="number">0xC0</span> | ((c &gt;&gt;  <span class="number">6</span>) &amp; <span class="number">0x1F</span>));</span><br><span class="line">            bytearr[count++] = (<span class="keyword">byte</span>) (<span class="number">0x80</span> | ((c &gt;&gt;  <span class="number">0</span>) &amp; <span class="number">0x3F</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    out.write(bytearr, <span class="number">0</span>, utflen+<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> utflen + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将一段String字符串以修订版的UTF-8格式写入输出流中，并返回实际写入的字节长度。第7 ~ 16行代码用于统计容纳入参String字符串需要的字节长度。第22 ~ 30行代码用于初始化bytearr数组，这个数组用来存储最后需要写入到输出流中的内容。如果bytearr数组长度不容容纳入参String字符串，那么就需要执行扩容操作，将bytearr数组长度扩展为容纳入参String字符串需要的字节长度的两倍。第32、33行用来存储实际写入的字节长度，长度最大是65535，即$ 2^{16} $。第36 ~ 40行向bytearr写入单字节长度的字符串，在遇到第一个非单字节长度字符时结束。第42 ~ 55行用来向bytearr写入变长字节长度的字符。其中，第44 ~ 46行向bytearr写入单字节长度的字符，第47 ~ 51行向bytearr写入三个字节长度的字符，通过按位与、或操作将单个字符转换成 “<strong>1110xxxx&nbsp;10yyyyyy&nbsp;10zzzzzz</strong>”的格式，有效数据位都存储在了x，y，z占据的二进制位中。第52 ~ 53行向bytearr写入两个字节长度的字符，将当前字符转换成“<strong>110yyyyy&nbsp;10zzzzzz</strong>”的格式，有效数据位都存储在了x，y占据的二进制位中。第56行代码用于将转换后的bytearr中存储的内容写入到输出流中。第57行返回实际写入的字节数，因为utflen代表的是存储入参String需要的字节数，而在写入过程中还向输出流中写入了两个字节长度的实际写入内容长度值，所以需要将utflen的值加2作为最终返回值。</p>
<h4 id="public-final-int-size"><a href="#public-final-int-size" class="headerlink" title="public final int size()"></a>public final int size()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> written;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回当前已经写入的字节数。</p>
<p>&emsp;</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li><p>byte转int的标准操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = (<span class="keyword">byte</span>)<span class="number">255</span>;</span><br><span class="line"><span class="keyword">int</span> i = b &amp; <span class="number">255</span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;byte的有符号数范围是[-128， 127]，无符号数范围是[0， 255]。所以第1行代码中，将255强转成byte类型后，就由32比特的<strong>00000000 00000000 00000000 11111111</strong>被截断成了<strong>11111111</strong>，所以变量b存储的是二进制为<strong>11111111</strong>的值（转成十进制为-1），这种情况在将十进制数值大于127的数字转成byte时普遍存在。所以在将byte转成int时，先将byte类型的数值转成int类型，然后再与255（0XFF）按位相与，这样就保证了数值在不同类型中的不变性。</p>
</li>
<li><p>UTF-8标准的数据结构：</p>
<p>&emsp;&emsp;在UTF-8标准中，一个Unicode字符的比特会被分隔成多个部分，并分配到UTF-8的字符串中保存。可参考如下表格：</p>
<p>表1：UTF-8和Unicode的部分对应关系</p>
<table><tr><td>码点范围 (十六进制) </td><td>UTF-8 (二进制) </td><td>注释 </td></tr>
<tr><td>000000 - 00007F </td><td>0zzzzzzz </td><td>ASCII字符范围，字节由零开始  </td></tr>
<tr><td>000080 - 0007FF </td><td>110yyyyy 10zzzzzz </td><td>第一个字节由110开始，接着的字节由10开始 </td></tr>
<tr><td>000800 - 00D7FF <br>00E000 - 00FFFF</td><td>1110xxxx 10yyyyyy 10zzzzzz </td><td>第一个字节由1110开始，接着的字节由10开始 </td></tr>
<tr><td>010000 - 10FFFF</td><td>11110www 10xxxxxx 10yyyyyy 10zzzzzz </td><td>将由11110开始，接着的字节由10开始 </td></tr>
</table>

<p>一个Unicode字符的二进制序列会被存储在UTF编码的实际存储空间中，对应表1中x，y，z，w标识的二进制位。如果Unicode字符的码值在000000 - 00007F 之间，那么UTF-8会用8个比特位表示一个Unicode字符，其中，最高位固定为0，剩余7位用来存储实际内容。如果Unicode字符的码值在000080 - 0007FF之间，UTF-8会用16个比特位（即两个字节）表示一个Unicode字符，第一个字节的高3位固定为110，第二个字节的高2位固定为10，两个字节的剩余11个比特位用来存储实际内容。如果Unicode字符的码值在000800 - 00D7FF和00E000 - 00FFFF之间，则UTF-8会用24个比特位（即三个字节）来标识一个Unicode字符，第一个字节的高4位固定为1110，后续字节的高2位均固定为10，三个字节剩余的16个比特位用来存储实际内容。</p>
</li>
<li><p>Java int的溢出处理：</p>
<p>&emsp;&emsp;在java语言中，一个int值由四个字节（32个比特位）组成，而计算机中数值是用补码表示的，所以在执行计算时会出现溢出的情况。如果执行的加法运算，那么发生溢出时会执行刷新最左边的符号位，运算前的正数在计算后会变成最小负数，运算前如果是负数计算后会变成最大正数。如果执行的是乘法运算，那么在计算时如果认为可能会发生溢出，那么在计算时会用long型来存储中间计算结果。在最终计算完成后，采取高位截取的方式返回一个int结果，该结果可能并不等于实际的计算结果。</p>
</li>
</ol>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>Stack Overflow. <a href="https://stackoverflow.com/questions/25897627/datainputstream-read-vs-datainputstream-readfully" target="_blank" rel="noopener">DataInputStream.read() vs DataInputStream.readFully()</a> [E]</li>
<li>Stack Overflow. <a href="https://stackoverflow.com/questions/9581530/converting-from-byte-to-int-in-java" target="_blank" rel="noopener">Converting from byte to int in java</a> [E]</li>
<li>Stack Overflow. <a href="https://stackoverflow.com/questions/3911536/utf-8-unicode-whats-with-0xc0-and-0x80" target="_blank" rel="noopener">UTF-8 &amp; Unicode, what’s with 0xC0 and 0x80?</a> [E]</li>
<li>牛奋Debug. <a href="https://my.oschina.net/andyfeng/blog/1621012" target="_blank" rel="noopener">byte &amp; 0xff</a> [E]</li>
<li>陈奎. <a href="http://ckjava.com/2018/05/03/java-byte-0XFF/" target="_blank" rel="noopener">对 byte &amp; 0xFF 的理解</a> [E]</li>
<li>Wikipedia. <a href="https://zh.wikipedia.org/zh/UTF-8" target="_blank" rel="noopener">UTF-8</a> [E]</li>
<li>njuCZ. <a href="https://njucz.github.io/2017/08/16/java-int%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">java int溢出总结</a> [E]</li>
<li>James Gosling等. The Java Language Specification (Java SE 7 Edition) [M]</li>
<li>许令波. <a href="https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/" target="_blank" rel="noopener">深入分析 Java 中的中文编码问题</a> [E]<br>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java I/O 09 - FileInputStream &amp; FileOutputStream</title>
    <url>/2018/java-FileInputStream-FileOutputStream.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;关于<em> <strong>java.io.FileInputStream</strong> </em>和 <em> <strong>java.io.FileOutputStream</strong> </em>的部分笔记，这两个类完成的是对文件的输入输出的字节流操作。本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;FileInputStream和FileOutputStream用来完成对文件的字节流操作。FileInputStream从文件系统的某个文件中获取数据并读取到内存中，FileOutputStream则将内存中的数据写到某个特定的文件中去。这两个类处理的是诸如图像数据这样的原始字节流，如果需要读取写入类似于字符这样的数据流，需要用FileReader和FileWriter。</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FileInputStream</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.io.InputStream</span><br><span class="line">    --java.io.FileInputStream </span><br><span class="line"></span><br><span class="line"><span class="comment">// FileOutputStream</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.io.OutputStream</span><br><span class="line">    --java.io.FileOutputStream</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类名</th>
<th style="text-align:center">实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">FileInputStream</td>
<td style="text-align:center">Closeable, AutoCloseable</td>
</tr>
<tr>
<td style="text-align:center">FileOutputStream</td>
<td style="text-align:center">Closeable, Flushable, AutoCloseable</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h2><h3 id="主要字段"><a href="#主要字段" class="headerlink" title="主要字段"></a>主要字段</h3><h4 id="fd"><a href="#fd" class="headerlink" title="fd"></a>fd</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FileDescriptor fd;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;当前输入流中维护的文件描述符。用来标识进程中打开的一个文件。</p>
<h4 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> FileChannel channel = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;文件管道，用来读、写、映射、操作某个文件。</p>
<h4 id="path"><a href="#path" class="headerlink" title="path"></a>path</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String path;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;维护当前打开的文件路径。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><h4 id="FileInputStream-String-name"><a href="#FileInputStream-String-name" class="headerlink" title="FileInputStream(String name)"></a>FileInputStream(String name)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(String name)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(name != <span class="keyword">null</span> ? <span class="keyword">new</span> File(name) : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;根据一个系统相关的字符串来获取一个文件并创建一个输入流，该输入流会从入参name文件中读取数据到内存中。实际调用的是下面的构造方法public FileInputStream(File file)。</p>
<h4 id="FileInputStream-File-file"><a href="#FileInputStream-File-file" class="headerlink" title="FileInputStream(File file)"></a>FileInputStream(File file)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    String name = (file != <span class="keyword">null</span> ? file.getPath() : <span class="keyword">null</span>);</span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        security.checkRead(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (file.isInvalid()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"Invalid file path"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">    fd.incrementAndGetUseCount();</span><br><span class="line">    <span class="keyword">this</span>.path = name;</span><br><span class="line">    open(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;根据一个入参file创建一个输入流，该输入流将从入参file中获取数据。第3 ~ 6行代码如果存在安全管理器，那么就需要检查是否拥有对该文件进行操作和管理的权限。第7 ~ 12行代码完成一些有效性校验。第13行维护了一个文件描述符，该描述符记录了当前打开的文件。第16行代码则通过调用底层的<strong>private native void open(String name)</strong>方法来打开特定路径下的文件。</p>
<h4 id="FileInputStream-FileDescriptor-fdObj"><a href="#FileInputStream-FileDescriptor-fdObj" class="headerlink" title="FileInputStream(FileDescriptor fdObj)"></a>FileInputStream(FileDescriptor fdObj)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(FileDescriptor fdObj)</span> </span>&#123;</span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (fdObj == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        security.checkRead(fdObj);</span><br><span class="line">    &#125;</span><br><span class="line">    fd = fdObj;</span><br><span class="line">    path = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    fd.incrementAndGetUseCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过一个文件描述符来初始化一个文件输入流。因为文件描述符fdObj记录了一个打开的文件，所以输入流中的字段fd与入参fdObj记录的是同样的文件。第2 ~ 8行代码如果存在安全管理器，那么就需要检查是否拥有对该文件进行操作和管理的权限。</p>
<h3 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="public-int-read"><a href="#public-int-read" class="headerlink" title="public int read()"></a>public int read()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Object traceContext = IoTrace.fileReadBegin(path);</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        b = read0();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        IoTrace.fileReadEnd(traceContext, b == -<span class="number">1</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从path指定的文件中读取一个字节的内容并返回。第2行和第7行的代码用来完成I/O文件操作的一个跟踪记录，所以这两个方法是配对使用的，用来标记文件操作的开始和结束（具体使用场景和实现还有待考证）。底层调用的是<strong>private native int read0()</strong>，通过该方法完成从文件中读取数据的操作。</p>
<h4 id="public-int-read-byte-b-int-off-int-len"><a href="#public-int-read-byte-b-int-off-int-len" class="headerlink" title="public int read(byte b[], int off, int len)"></a>public int read(byte b[], int off, int len)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Object traceContext = IoTrace.fileReadBegin(path);</span><br><span class="line">    <span class="keyword">int</span> bytesRead = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        bytesRead = readBytes(b, off, len);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        IoTrace.fileReadEnd(traceContext, bytesRead == -<span class="number">1</span> ? <span class="number">0</span> : bytesRead);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bytesRead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Object traceContext = IoTrace.fileReadBegin(path);</span><br><span class="line">    <span class="keyword">int</span> bytesRead = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        bytesRead = readBytes(b, <span class="number">0</span>, b.length);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        IoTrace.fileReadEnd(traceContext, bytesRead == -<span class="number">1</span> ? <span class="number">0</span> : bytesRead);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bytesRead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从path指定的文件中读取指定长度的内容到入参数组b中。可能因为已经读到了文件尾部、异常抛出等原因会导致实际返回的b的长度有可能小于入参len。底层调用的是<strong>private native int readBytes(byte b[], int off, int len)</strong>，通过该方法完成从文件中读取数据的操作。</p>
<h4 id="public-void-close"><a href="#public-void-close" class="headerlink" title="public void close()"></a>public void close()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (closeLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        closed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fd.decrementAndGetUseCount();</span><br><span class="line">        channel.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> useCount = fd.decrementAndGetUseCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((useCount &lt;= <span class="number">0</span>) || !isRunningFinalize()) &#123;</span><br><span class="line">        close0();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;关闭当前输入流并释放所有相关的资源。如果在期间创建了文件管道，那么首先需要把该管道占用的资源释放，同时更新文件描述符的信息。在第15 ~ 17行代码中有两个条件来控制是否执行close方法释放输入流的资源。<strong>useCount &lt;= 0</strong>表示当前文件描述符已经没有其他对象使用了，所以如果该条件满足的话就可以执行释放操作了。<strong>!isRunningFinalize()</strong>的值由方法finalize()负责维护。在finalize()方法中，首先向线程本地变量中传入一个true值，然后调用close()方法释放资源。此时，如果文件描述符fd还有其他流在使用，那么就不会执行close0()方法。在finalize()方法的最后将线程本地变量的值变成了false，那么当下次直接调用close方法的时候，不管fd是否还有其他流在使用，都会执行第16行代码，释放所有资源。</p>
<h4 id="protected-void-finalize"><a href="#protected-void-finalize" class="headerlink" title="protected void finalize()"></a>protected void finalize()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((fd != <span class="keyword">null</span>) &amp;&amp;  (fd != FileDescriptor.in)) &#123;</span><br><span class="line">        runningFinalize.set(Boolean.TRUE);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            close();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            runningFinalize.set(Boolean.FALSE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;finalize()方法不会释放仍被其他流使用的文件描述符fd，所以第3行代码向线程本地变量中存入了一个true，这样在第5行代码调用close()方法时就不会释放当前资源。最后向线程本地变量中存入了false，所以那当下次直接调用close方法的时候，不管fd是否还有其他流在使用，都会释放所有资源。</p>
<h4 id="public-final-FileDescriptor-getFD"><a href="#public-final-FileDescriptor-getFD" class="headerlink" title="public final FileDescriptor getFD()"></a>public final FileDescriptor getFD()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> FileDescriptor <span class="title">getFD</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fd != <span class="keyword">null</span>) <span class="keyword">return</span> fd;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;获取并返回一个文件描述符的引用，否则抛出一个IOException给调用方。</p>
<h4 id="public-FileChannel-getChannel"><a href="#public-FileChannel-getChannel" class="headerlink" title="public FileChannel getChannel()"></a>public FileChannel getChannel()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FileChannel <span class="title">getChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</span><br><span class="line">            channel = FileChannelImpl.open(fd, path, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">this</span>);</span><br><span class="line">            fd.incrementAndGetUseCount();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> channel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;获取一个文件管道。该管道可以用来完成文件复制等一系列操作。每次创建文件管道时需要维护文件描述符的信息。</p>
<p>&emsp;</p>
<h2 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h2><h3 id="主要字段-1"><a href="#主要字段-1" class="headerlink" title="主要字段"></a>主要字段</h3><h4 id="fd-1"><a href="#fd-1" class="headerlink" title="fd"></a>fd</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FileDescriptor fd;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;当前输入流中维护的文件描述符。用来标识进程中打开的一个文件。</p>
<h4 id="path-1"><a href="#path-1" class="headerlink" title="path"></a>path</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String path;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;维护当前打开的文件路径。</p>
<h4 id="append"><a href="#append" class="headerlink" title="append"></a>append</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> append;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;写文件的模式，true 为从文件尾部追加写，false为从文件开头写并覆盖当前文件已有内容。</p>
<h4 id="channel-1"><a href="#channel-1" class="headerlink" title="channel"></a>channel</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> FileChannel channel;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;文件管道，用来读、写、映射、操作某个文件。</p>
<h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><h4 id="public-FileOutputStream-String-name"><a href="#public-FileOutputStream-String-name" class="headerlink" title="public FileOutputStream(String name)"></a>public FileOutputStream(String name)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(String name)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(name != <span class="keyword">null</span> ? <span class="keyword">new</span> File(name) : <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;根据一个系统相关的字符串来获取一个文件并创建一个输出流，该输出流会把数据写入到入参指定路径下的文件中。因为在写文件时有追加模式和覆盖模式可供选择，所以该方法默认写文件是覆盖当前已有内容从头开始写文件。实际调用的是下面的构造方法FileOutputStream(File file)。</p>
<h4 id="public-FileOutputStream-String-name-boolean-append"><a href="#public-FileOutputStream-String-name-boolean-append" class="headerlink" title="public FileOutputStream(String name, boolean append)"></a>public FileOutputStream(String name, boolean append)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(String name, <span class="keyword">boolean</span> append)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> FileNotFoundException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(name != <span class="keyword">null</span> ? <span class="keyword">new</span> File(name) : <span class="keyword">null</span>, append);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;根据一个系统相关的字符串来获取一个文件并创建一个输出流，该输出流会把数据写入到入参指定路径下的文件中。因为在写文件时有追加模式和覆盖模式可供选择，由入参append决定该方法采用哪种模式写文件。实际调用的是下面的构造方法FileOutputStream(File file, boolean append)。</p>
<h4 id="public-FileOutputStream-File-file"><a href="#public-FileOutputStream-File-file" class="headerlink" title="public FileOutputStream(File file)"></a>public FileOutputStream(File file)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(file, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;根据一个入参file创建一个输出流，该输出流会把数据写到入参file指定的文件中。该方法默认写文件是覆盖当前已有内容从头开始写文件。</p>
<h4 id="public-FileOutputStream-File-file-boolean-append"><a href="#public-FileOutputStream-File-file-boolean-append" class="headerlink" title="public FileOutputStream(File file, boolean append)"></a>public FileOutputStream(File file, boolean append)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(File file, <span class="keyword">boolean</span> append)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> FileNotFoundException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    String name = (file != <span class="keyword">null</span> ? file.getPath() : <span class="keyword">null</span>);</span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        security.checkWrite(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (file.isInvalid()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"Invalid file path"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.fd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">    <span class="keyword">this</span>.append = append;</span><br><span class="line">    <span class="keyword">this</span>.path = name;</span><br><span class="line">    fd.incrementAndGetUseCount();</span><br><span class="line">    open(name, append);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;根据一个入参file创建一个输出流，该输出流会把数据写到入参file指定的文件中。第5 ~ 8行代码如果存在安全管理器，那么就需要检查是否拥有对该文件进行操作和管理的权限。第9 ~ 14行代码完成一些有效性校验。第15行维护了一个文件描述符，该描述符记录了当前打开的文件。第19行代码则通过调用底层的<strong>private native void open(String name, boolean append)</strong>方法来打开特定路径下的文件。</p>
<h4 id="public-FileOutputStream-FileDescriptor-fdObj"><a href="#public-FileOutputStream-FileDescriptor-fdObj" class="headerlink" title="public FileOutputStream(FileDescriptor fdObj)"></a>public FileOutputStream(FileDescriptor fdObj)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(FileDescriptor fdObj)</span> </span>&#123;</span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (fdObj == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        security.checkWrite(fdObj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.fd = fdObj;</span><br><span class="line">    <span class="keyword">this</span>.path = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.append = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    fd.incrementAndGetUseCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过一个文件描述符来初始化一个文件输出流。因为文件描述符fdObj记录了一个打开的文件，所以输出流中的字段fd与入参fdObj记录的是同样的文件。第2 ~ 8行代码如果存在安全管理器，那么就需要检查是否拥有对该文件进行操作和管理的权限。</p>
<h3 id="部分方法-1"><a href="#部分方法-1" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="public-void-write-int-b"><a href="#public-void-write-int-b" class="headerlink" title="public void write(int b)"></a>public void write(int b)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Object traceContext = IoTrace.fileWriteBegin(path);</span><br><span class="line">    <span class="keyword">int</span> bytesWritten = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        write(b, append);</span><br><span class="line">        bytesWritten = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        IoTrace.fileWriteEnd(traceContext, bytesWritten);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;向path指定的文件中以append指定的写入方式写入一个字节的内容。第2行和第8行的代码用来完成I/O文件操作的一个跟踪记录，所以这两个方法是配对使用的，用来标记文件操作的开始和结束（具体使用场景和实现还有待考证）。底层调用的是<strong>private native void write(int b, boolean append)</strong>，通过该方法完成向文件中写入数据的操作。</p>
<h4 id="public-void-write-byte-b-int-off-int-len"><a href="#public-void-write-byte-b-int-off-int-len" class="headerlink" title="public void write(byte b[], int off, int len)"></a>public void write(byte b[], int off, int len)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Object traceContext = IoTrace.fileWriteBegin(path);</span><br><span class="line">    <span class="keyword">int</span> bytesWritten = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        writeBytes(b, off, len, append);</span><br><span class="line">        bytesWritten = len;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        IoTrace.fileWriteEnd(traceContext, bytesWritten);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;向path指定的文件中以append指定的写入方式写入数组b中包含的内容。第2行和第8行的代码用来完成I/O文件操作的一个跟踪记录，所以这两个方法是配对使用的，用来标记文件操作的开始和结束（具体使用场景和实现还有待考证）。底层调用的是<strong>private native void write(byte b[], int off, int len, boolean append)</strong>，通过该方法完成向文件中写入数据的操作。</p>
<h4 id="public-void-close-1"><a href="#public-void-close-1" class="headerlink" title="public void close()"></a>public void close()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (closeLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        closed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fd.decrementAndGetUseCount();</span><br><span class="line">        channel.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> useCount = fd.decrementAndGetUseCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((useCount &lt;= <span class="number">0</span>) || !isRunningFinalize()) &#123;</span><br><span class="line">        close0();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;执行逻辑同FileInputStream.close()，故不予赘述。</p>
<h4 id="protected-void-finalize-1"><a href="#protected-void-finalize-1" class="headerlink" title="protected void finalize()"></a>protected void finalize()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fd != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fd == FileDescriptor.out || fd == FileDescriptor.err) &#123;</span><br><span class="line">            flush();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            runningFinalize.set(Boolean.TRUE);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                close();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                runningFinalize.set(Boolean.FALSE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;执行逻辑同FileInputStream.finalize()，故不予赘述。</p>
<h4 id="public-final-FileDescriptor-getFD-1"><a href="#public-final-FileDescriptor-getFD-1" class="headerlink" title="public final FileDescriptor getFD()"></a>public final FileDescriptor getFD()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> FileDescriptor <span class="title">getFD</span><span class="params">()</span>  <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fd != <span class="keyword">null</span>) <span class="keyword">return</span> fd;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;获取并返回一个文件描述符的引用，否则抛出一个IOException给调用方。</p>
<h4 id="public-FileChannel-getChannel-1"><a href="#public-FileChannel-getChannel-1" class="headerlink" title="public FileChannel getChannel()"></a>public FileChannel getChannel()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FileChannel <span class="title">getChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</span><br><span class="line">            channel = FileChannelImpl.open(fd, path, <span class="keyword">false</span>, <span class="keyword">true</span>, append, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            fd.incrementAndGetUseCount();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> channel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;获取一个文件管道。该管道可以用来完成文件复制等一系列操作。每次创建文件管道时需要维护文件描述符的信息。</p>
<p>&emsp;</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li><p>FileDescriptor:<br>&emsp;&emsp;文件描述符，简称fd。文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。操作系统使用文件描述符来指代一个打开的文件，对文件的读写操作，都需要文件描述符作为参数。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p>
<p>&emsp;&emsp;在Unix或者Linux系统中，文件描述符标识了内核中一个特定进程正在访问的文件。当打开一个现有文件或创建一个新文件时，内核向进程返回一个文件描述符。当读、写一个文件时，将fd作为参数传送给 read 或 write。在UNIX的传统实现中，文件描述符会被加入到一个内核维护的列表中，该列表中的每个元素指向了一个文件表（file table），这个文件表中维护了当前进程中所有的被打开的文件信息，包括一个指向文件的Inode对象的指针、相关元数据，如当前文件格式、读取模式（read，write，append，read-write……）等信息。file table中的每个元素会指向一个真实文件的物理存储地址。可参考如下图1所示：</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1540392586/BlogImages/FileInputStream-FileOutputStream/File_table_and_inode_table.png" alt></p>
<div align="center"><div align="center">图 - 1</div>&emsp;</div>

<p>最左边为维护文件描述符的列表，其中0（标准输入）,1（标准输出）,2（标准异常输出）为标准的POSIX文件描述符。每个文件描述符会指向File table中的某个文件操作模式，多个文件描述符可以指向同一个文件操作模式。最右边维护了当前进程中打开的所有的真实文件信息，由file table中的某个元素指向其中的某个打开的文件来完成对应的文件操作。</p>
<p>&emsp;&emsp;总结下来，fd只是一个int型的数值，用来标定一个打开的文件，类似于索引的作用。在需要操作文件时，通过fd来指向其标定的那个文件。 </p>
</li>
</ol>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>Wikipedia. <a href="https://en.wikipedia.org/wiki/File_descriptor" target="_blank" rel="noopener">文件描述符</a> [E]</li>
<li>木杉. <a href="http://imushan.com/2018/05/29/java/language/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-FileDescriptor/" target="_blank" rel="noopener">JDK源码阅读-FileDescriptor</a> [E]</li>
<li>WIKIMEDIA COMMONS. <a href="https://commons.wikimedia.org/wiki/File:File_table_and_inode_table.svg" target="_blank" rel="noopener">File table and inode table</a> [E]</li>
<li>鸡蛋卷啊卷. <a href="https://blog.csdn.net/zhjali123/article/details/72566685" target="_blank" rel="noopener">FileDescriptor文件描述符与Linux文件系统</a>  [E]</li>
<li>平林新袖. <a href="https://www.cnblogs.com/plxx/p/5322635.html" target="_blank" rel="noopener">FileDescriptor</a> [E]</li>
<li>mm_hh. <a href="https://blog.csdn.net/mm_hh/article/details/71374474?utm_source=blogkpcl7" target="_blank" rel="noopener">Linux下 文件描述符（fd）与 文件指针（FILE*）</a> [E]</li>
<li>Axtaxt. <a href="https://axtaxt.wordpress.com/2013/09/19/experimenting-with-sun-misc-iotrace/" target="_blank" rel="noopener">IO trace generation in java: experimenting with sun.misc.IoTrace</a> [E]</li>
</ol>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java I/O 19 - FilterReader &amp; FilterWriter</title>
    <url>/2018/java-FilterReader-FilterWriter.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;关于<em> <strong>java.io.FilterReader</strong> </em> 和 <em> <strong>java.io.FilterWriter</strong> </em>的部分笔记，自身实现了完整的输入输出流操作，继承这两个类的子类应该重写其拥有的操作方法API。本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;FilterReader和FilterWriter这两个类分别继承了Reader和Writer，其自身实现了一整套关于输入输出流的默认操作。但是因为FilterReader和FilterWriter被设计成抽象类的缘故，所以任何继承这两个类的子类都应该重写其方法，如果有必要的话可以提供额外的方法和字段。和FilterInputStream/FilterOutputStream类似，FilterReader和FilterWriter在设计时也采用了装饰器的设计模式，继承自FilterReader的子类PushbackReader则是具体的装饰类。</p>
<p>&emsp;</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FilterReader</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.io.Reader</span><br><span class="line">    --java.io.FilterReader</span><br><span class="line"></span><br><span class="line"><span class="comment">// FilterWriter</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.io.Writer</span><br><span class="line">    --java.io.FilterWriter</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类名</th>
<th style="text-align:center">实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">FilterReader</td>
<td style="text-align:center">Closeable, AutoCloseable,Readable</td>
</tr>
<tr>
<td style="text-align:center">FilterWriter</td>
<td style="text-align:center">Closeable, Flushable, AutoCloseable, Appendable</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="FilterReader"><a href="#FilterReader" class="headerlink" title="FilterReader"></a>FilterReader</h2><h3 id="Constructor-Summary"><a href="#Constructor-Summary" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="protected-FilterReader-Reader-in"><a href="#protected-FilterReader-Reader-in" class="headerlink" title="protected FilterReader(Reader in)"></a>protected FilterReader(Reader in)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">FilterReader</span><span class="params">(Reader in)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(in);</span><br><span class="line">    <span class="keyword">this</span>.in = in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个FilterReader。FilterReader底层依赖一个Reader输入流，所以在初始化时需要传入一个实现了Reader接口的实现类来完成初始化操作，FilterReader类中所有的操作都直接依赖于底层的Reader输入流。</p>
<h3 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="public-int-read"><a href="#public-int-read" class="headerlink" title="public int read()"></a>public int read()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> in.read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从底层输入流中读取一个字符内容并返回。</p>
<h4 id="public-int-read-char-cbuf-int-off-int-len"><a href="#public-int-read-char-cbuf-int-off-int-len" class="headerlink" title="public int read(char cbuf[], int off, int len)"></a>public int read(char cbuf[], int off, int len)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> cbuf[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> in.read(cbuf, off, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从底层输入流中读取长度为len的字符内容并保存到字符数组cbuf中自位置off起的空间里。</p>
<h4 id="public-long-skip-long-n"><a href="#public-long-skip-long-n" class="headerlink" title="public long skip(long n)"></a>public long skip(long n)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> in.skip(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;跳过底层输入流中长度为n的字符内容。</p>
<h4 id="public-boolean-ready"><a href="#public-boolean-ready" class="headerlink" title="public boolean ready()"></a>public boolean ready()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">ready</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> in.ready();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通知方法调用方当前底层输入流是否可以通过read()方法对外提供数据。</p>
<h4 id="public-boolean-markSupported"><a href="#public-boolean-markSupported" class="headerlink" title="public boolean markSupported()"></a>public boolean markSupported()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">markSupported</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> in.markSupported();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通知方法调用方当前底层输入流是否支持标记重读操作。</p>
<h4 id="public-void-mark-int-readAheadLimit"><a href="#public-void-mark-int-readAheadLimit" class="headerlink" title="public void mark(int readAheadLimit)"></a>public void mark(int readAheadLimit)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> readAheadLimit)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    in.mark(readAheadLimit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;标记底层输入流的当前读取位置。</p>
<h4 id="public-void-reset"><a href="#public-void-reset" class="headerlink" title="public void reset()"></a>public void reset()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    in.reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;重置下一次读取位置为最近一次调用mark()方法记录的位置值。</p>
<h4 id="public-void-close"><a href="#public-void-close" class="headerlink" title="public void close()"></a>public void close()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    in.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;关闭当前输入流。</p>
<p>&emsp;</p>
<h2 id="FilterWriter"><a href="#FilterWriter" class="headerlink" title="FilterWriter"></a>FilterWriter</h2><h3 id="Constructor-Summary-1"><a href="#Constructor-Summary-1" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="protected-FilterWriter-Writer-out"><a href="#protected-FilterWriter-Writer-out" class="headerlink" title="protected FilterWriter(Writer out)"></a>protected FilterWriter(Writer out)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">FilterWriter</span><span class="params">(Writer out)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(out);</span><br><span class="line">    <span class="keyword">this</span>.out = out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个FilterWriter。FilterWriter底层依赖一个Writer输入流，所以在初始化时需传入一个实现了Writer接口的实现类来完成初始化操作，FilterWriter类中所有的操作都直接依赖于底层的Writer输入流。</p>
<h3 id="部分方法-1"><a href="#部分方法-1" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="public-void-write-int-c"><a href="#public-void-write-int-c" class="headerlink" title="public void write(int c)"></a>public void write(int c)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> c)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    out.write(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;向底层输出流中写入一个字符。</p>
<h4 id="public-void-write-char-cbuf-int-off-int-len"><a href="#public-void-write-char-cbuf-int-off-int-len" class="headerlink" title="public void write(char cbuf[], int off, int len)"></a>public void write(char cbuf[], int off, int len)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> cbuf[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    out.write(cbuf, off, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将字符数组c中的内容写入到底层输出流中。</p>
<h4 id="public-void-write-String-str-int-off-int-len"><a href="#public-void-write-String-str-int-off-int-len" class="headerlink" title="public void write(String str, int off, int len)"></a>public void write(String str, int off, int len)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String str, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    out.write(str, off, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将字符串str中自off位置起长度为len的内容写入到底层输出流中。</p>
<h4 id="public-void-flush"><a href="#public-void-flush" class="headerlink" title="public void flush()"></a>public void flush()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    out.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将缓冲区buf中的内容推到目标输出位置上。</p>
<h4 id="public-void-close-1"><a href="#public-void-close-1" class="headerlink" title="public void close()"></a>public void close()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;关闭当前输出流。</p>
<p>&emsp;</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li><p>装饰器模式：</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1542893609/BlogImages/java-IO-FilterReader-FilterWriter/Design-Patterns-Decorator.png" alt></p>
<div align="center">
<div align="center">图 - 1</div>
&emsp;
</div>

<p>根据图1结构所示，Reader和Writer对应图里的Component，FilterReader和FilterWriter对应于图里的Decorator，PushbackReader对应图里的ConcreteDecorator，而继承自Reader和Writer的其他子类则属于ConcreteComponent。ConcreteDecorator角色提供了更为丰富和个性化的操作。</p>
</li>
</ol>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>[美] Erich Gamma等. Design Patterns: Elements of Reusable Object-Oriented Software[M].  New York:Pearson Education, 2005.</li>
</ol>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java I/O 05 - InputStream &amp; OutputStream</title>
    <url>/2018/java-InputStream-OutputStream.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;关于<em> <strong>java.io.InputStream</strong> </em> 和 <em>  <strong>java.io.OutputStream</strong> </em>的部分笔记，这两个类是字节流读写的公共父类，继承这两个类的子类均实现了读、写操作。本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<p>&emsp;</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;这两个类的设计都比较简单，其作为抽象类的存在给继承这两个类的子类留下了各自的实现read()和write()方法的空间，使得各个子类可以根据具体的设计需要分别有针对性的设计和实现字节流的读写。</p>
<p>&emsp;</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// InputStream</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">    --java.io.InputStream</span><br><span class="line"></span><br><span class="line"><span class="comment">// OutputStream</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">    --java.io.OutputStream</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类名</th>
<th style="text-align:center">实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">InputStream</td>
<td style="text-align:center">Closeable, AutoCloseable</td>
</tr>
<tr>
<td style="text-align:center">OutputStream</td>
<td style="text-align:center">Closeable, Flushable, AutoCloseable</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h2><h3 id="InputStream：public-long-skip-long-n"><a href="#InputStream：public-long-skip-long-n" class="headerlink" title="InputStream：public long skip(long n)"></a>InputStream：public long skip(long n)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> remaining = n;</span><br><span class="line">    <span class="keyword">int</span> nr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = (<span class="keyword">int</span>)Math.min(MAX_SKIP_BUFFER_SIZE, remaining);</span><br><span class="line">    <span class="keyword">byte</span>[] skipBuffer = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">    <span class="keyword">while</span> (remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        nr = read(skipBuffer, <span class="number">0</span>, (<span class="keyword">int</span>)Math.min(size, remaining));</span><br><span class="line">        <span class="keyword">if</span> (nr &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        remaining -= nr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n - remaining;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;该方法会跳过读入内容的指定长度，读取位置会从当前位置向后偏移最多n个长度。为什么说是最多n个呢？我们浏览下第11 ~ 17行代码，代码的期望执行结果是remaining为0，跳出循环，最后返回入参n。这样实际跳过的长度和入参相同。但是在实际执行过程中，有可能输入流读取会直接到流结束的位置，这样循环就会提前跳出，最后remaining的值大于0，那么最终返回的长度会小于入参n。在第9行代码，通过<strong>MAX_SKIP_BUFFER_SIZE (2048)</strong>和入参取较小值，从而控制单次读取的最大长度。</p>
<h3 id="InputStream：public-int-read-byte-b-int-off-int-len"><a href="#InputStream：public-int-read-byte-b-int-off-int-len" class="headerlink" title="InputStream：public int read(byte b[], int off, int len)"></a>InputStream：public int read(byte b[], int off, int len)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (off &lt; <span class="number">0</span> || len &lt; <span class="number">0</span> || len &gt; b.length - off) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = read();</span><br><span class="line">    <span class="keyword">if</span> (c == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    b[off] = (<span class="keyword">byte</span>)c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; len ; i++) &#123;</span><br><span class="line">            c = read();</span><br><span class="line">            <span class="keyword">if</span> (c == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            b[off + i] = (<span class="keyword">byte</span>)c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ee) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;读取多个字节的内容保存到入参数组b中并返回读取的字节数。在做完参数的有效性校验后，首先从底层输入流中尝试读出一个字节的内容，如果说读取时出现了非读到文件结束以外的其他异常的话，那么读取就会终止。如果可以正常读取，那么就循环调用read()方法，每次读取一个字节并将读取的内容保存到入参数组b中，直到读取到指定长度的内容，或者文件已经被读完。最后返回实际读取的字节长度。</p>
<h3 id="OutputStream：public-void-write-byte-b-int-off-int-len"><a href="#OutputStream：public-void-write-byte-b-int-off-int-len" class="headerlink" title="OutputStream：public void write(byte b[], int off, int len)"></a>OutputStream：public void write(byte b[], int off, int len)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((off &lt; <span class="number">0</span>) || (off &gt; b.length) || (len &lt; <span class="number">0</span>) ||</span><br><span class="line">               ((off + len) &gt; b.length) || ((off + len) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i++) &#123;</span><br><span class="line">        write(b[off + i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;写入多个字节到入参数组b中。在内部其实是循环调用<strong>write(int b)</strong>来实现多字节写入的。write(int b)这个方法由继承的子类分别实现。</p>
<p>&emsp;</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li><p>FilterOutputStream的close方法执行逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先将数据全部推送到输出流中，之后再执行底层输出流的close方法。</p>
</li>
</ol>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>NIL</p>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java I/O 13 - FileReader &amp; FileWriter</title>
    <url>/2018/java-FileReader-FileWriter.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;关于<em> <strong>java.io.FileReader</strong> </em> 和 <em> <strong>java.io.FileWriter</strong> </em>的部分笔记，这两个类实现了对文件的字符级别的读写操作。FileReader和FileWriter中对于文件的读写操作方法全部来自于继承的父类中，自身仅包含了对于底层输入流的初始化方法。本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;FileReader和FileWriter用来完成关于文件字符流的读写操作。在读写文件时，采用的都是默认的字符街编码格式。而且，这两个类仅仅用来处理字符流的操作，若要采用字节流的处理方式，那么需要使用FileInputStream和FileOutputStream来完成操作。</p>
<p>&emsp;&emsp;需要注意的是，FileWriter在打开文件时依赖于底层平台的特性，某些平台仅允许一个文件同时只能被一个FileWriter打开，所以如果当前某个文件已经被一个FileWriter打开，再次尝试通过一个新的FileWriter打开同一个文件时会打开失败且抛出异常。</p>
<p>&emsp;</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FileReader</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.io.Reader</span><br><span class="line">    --java.io.InputStreamReader</span><br><span class="line">      --java.io.FileReader</span><br><span class="line"></span><br><span class="line"><span class="comment">// FileWriter</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.io.Writer</span><br><span class="line">    --java.io.OutputStreamWriter</span><br><span class="line">      --java.io.FileWriter</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类名</th>
<th style="text-align:center">实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">FileReader</td>
<td style="text-align:center">Closeable, AutoCloseable,Readable</td>
</tr>
<tr>
<td style="text-align:center">FileWriter</td>
<td style="text-align:center">Closeable, Flushable, AutoCloseable, Appendable</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h2><h3 id="Constructor-Summary"><a href="#Constructor-Summary" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="public-FileReader-String-fileName"><a href="#public-FileReader-String-fileName" class="headerlink" title="public FileReader(String fileName)"></a>public FileReader(String fileName)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileReader</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">new</span> FileInputStream(fileName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个文件字符输入流。参数是一个包含路径的文件名，首先通过文件名初始化一个文件字节输入流，然后在通过父类的构造方法完成底层输入流的初始化操作。FileReader中不包含任何字符流操作，所以FileReader中没有底层输入流的存在，底层输入流在其父类InputStreamReader中。</p>
<h4 id="public-FileReader-File-file"><a href="#public-FileReader-File-file" class="headerlink" title="public FileReader(File file)"></a>public FileReader(File file)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileReader</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个文件字符输入流。参数是一个文件对象，首先初始化一个文件字节输入流，然后在通过父类的构造方法完成底层输入流的初始化操作。</p>
<h4 id="public-FileReader-FileDescriptor-fd"><a href="#public-FileReader-FileDescriptor-fd" class="headerlink" title="public FileReader(FileDescriptor fd)"></a>public FileReader(FileDescriptor fd)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileReader</span><span class="params">(FileDescriptor fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">new</span> FileInputStream(fd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个文件字符输入流。参数是一个文件描述符对象，首先初始化一个文件字节输入流，然后在通过父类的构造方法完成底层输入流的初始化操作。</p>
<h3 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h3><p>来自于java.io.InputStreamReader的方法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法声明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="/2018/java-InputStreamReader-OutputStreamWriter.html#publicVoidClose">public void close()</a></td>
<td>实现父类Reader的抽象方法</td>
</tr>
<tr>
<td><a href="/2018/java-InputStreamReader-OutputStreamWriter.html#publicStringGetEncoding">public String getEncoding()</a></td>
<td>InputStreamReader独有方法</td>
</tr>
<tr>
<td><a href="/2018/java-InputStreamReader-OutputStreamWriter.html#publicIntRead">public int read()</a></td>
<td>重写父类Reader的同名方法</td>
</tr>
<tr>
<td><a href="/2018/java-InputStreamReader-OutputStreamWriter.html#publicIntReadCII">public int read(char[] cbuf, int offset, int length)</a></td>
<td>实现父类Reader的抽象方法</td>
</tr>
<tr>
<td><a href="/2018/java-InputStreamReader-OutputStreamWriter.html#publicBooleanReady">public boolean ready()</a></td>
<td>重写父类Reader的同名方法</td>
</tr>
</tbody>
</table>
</div>
<p>来自于java.io.Reader的方法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法声明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="/2018/java-Reader-Writer.html#publicVoidMark">public void mark(int readAheadLimit)</a></td>
<td>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;</td>
</tr>
<tr>
<td><a href="/2018/java-Reader-Writer.html#publicBooleanMarkSupported">public boolean markSupported()</a></td>
<td></td>
</tr>
<tr>
<td><a href="/2018/java-Reader-Writer.html#publicIntReadCbuf">public int read(char[] cbuf)</a></td>
<td></td>
</tr>
<tr>
<td><a href="/2018/java-Reader-Writer.html#publicIntReadCharBuffer">public int read(CharBuffer target)</a></td>
<td></td>
</tr>
<tr>
<td><a href="/2018/java-Reader-Writer.html#publicVoidReset">public void reset()</a></td>
<td></td>
</tr>
<tr>
<td><a href="/2018/java-Reader-Writer.html#publicLongSkip">public long skip(long n)</a></td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h2><h3 id="Constructor-Summary-1"><a href="#Constructor-Summary-1" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="public-FileWriter-String-fileName"><a href="#public-FileWriter-String-fileName" class="headerlink" title="public FileWriter(String fileName)"></a>public FileWriter(String fileName)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileWriter</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">new</span> FileOutputStream(fileName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个文件字符输出流。参数是一个包含路径的文件名，首先通过文件名初始化一个文件字节输出流，然后在通过父类的构造方法完成底层输出流的初始化操作。FileWriter中不包含任何字符流操作，所以FileWriter中没有底层输入流的存在，底层输入流在其父类OutputStreamWriter中。</p>
<h4 id="public-FileWriter-String-fileName-boolean-append"><a href="#public-FileWriter-String-fileName-boolean-append" class="headerlink" title="public FileWriter(String fileName, boolean append)"></a>public FileWriter(String fileName, boolean append)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileWriter</span><span class="params">(String fileName, <span class="keyword">boolean</span> append)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">new</span> FileOutputStream(fileName, append));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个文件字符输出流。参数是一个包含路径的文件名，首先通过文件名初始化一个文件字节输出流，同时由参数append决定文件的写入方式是结尾追加写入还是从文件头部覆盖写入，然后在通过父类的构造方法完成底层输出流的初始化操作。</p>
<h4 id="public-FileWriter-File-file"><a href="#public-FileWriter-File-file" class="headerlink" title="public FileWriter(File file)"></a>public FileWriter(File file)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileWriter</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">new</span> FileOutputStream(file));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个文件字符输出流。参数是一个文件对象，首先初始化一个文件字节输出流，然后在通过父类的构造方法完成底层输出流的初始化操作。</p>
<h4 id="public-FileWriter-File-file-boolean-append"><a href="#public-FileWriter-File-file-boolean-append" class="headerlink" title="public FileWriter(File file, boolean append)"></a>public FileWriter(File file, boolean append)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileWriter</span><span class="params">(File file, <span class="keyword">boolean</span> append)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">new</span> FileOutputStream(file, append));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个文件字符输出流。参数是一个文件对象，首先初始化一个文件字节输出流，同时由参数append决定文件的写入方式是结尾追加写入还是从文件头部覆盖写入，然后在通过父类的构造方法完成底层输出流的初始化操作。</p>
<h4 id="public-FileWriter-FileDescriptor-fd"><a href="#public-FileWriter-FileDescriptor-fd" class="headerlink" title="public FileWriter(FileDescriptor fd)"></a>public FileWriter(FileDescriptor fd)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileWriter</span><span class="params">(FileDescriptor fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">new</span> FileOutputStream(fd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个文件字符输出流。参数是一个文件描述符，首先初始化一个文件字节输出流，然后在通过父类的构造方法完成底层输出流的初始化操作。</p>
<h3 id="部分方法-1"><a href="#部分方法-1" class="headerlink" title="部分方法"></a>部分方法</h3><p>来自于java.io.OutputStreamWriter的方法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法声明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="/2018/java-InputStreamReader-OutputStreamWriter.html#publicVoidWrite">public void write(int c)</a></td>
<td>重写父类Writer的同名方法</td>
</tr>
<tr>
<td><a href="/2018/java-InputStreamReader-OutputStreamWriter.html#publicVoidWriteCII">public void write(char[] cbuf, int off, int len)</a></td>
<td>重写父类Writer的同名方法</td>
</tr>
<tr>
<td><a href="/2018/java-InputStreamReader-OutputStreamWriter.html#publicVoidWriteSII">public void write(String str, int off, int len)</a></td>
<td>重写父类Writer的同名方法</td>
</tr>
<tr>
<td><a href="/2018/java-InputStreamReader-OutputStreamWriter.html#publicStringGetEncodingOut">public String getEncoding()</a></td>
<td>OutputStreamWriter独有方法</td>
</tr>
<tr>
<td><a href="/2018/java-InputStreamReader-OutputStreamWriter.html#publicVoidFlush">public void flush()</a></td>
<td>实现父类Writer的抽象方法</td>
</tr>
<tr>
<td><a href="/2018/java-InputStreamReader-OutputStreamWriter.html#publicVoidCloseOut">public void close()</a></td>
<td>实现父类Writer的抽象方法</td>
</tr>
</tbody>
</table>
</div>
<p>来自于java.io.Writer的方法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法声明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="/2018/java-Reader-Writer.html#publicWriteAppendCSC">public Writer append(CharSequence csq)</a></td>
<td>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;</td>
</tr>
<tr>
<td><a href="/2018/java-Reader-Writer.html#publicWriteAppendCCISIE">public Writer append(CharSequence csq, int start, int end)</a></td>
<td></td>
</tr>
<tr>
<td><a href="/2018/java-Reader-Writer.html#publicWriteAppendCC">public Writer append(char c)</a></td>
<td></td>
</tr>
<tr>
<td><a href="/2018/java-Reader-Writer.html#publicVoidWriteSS">public void write(String str)</a></td>
<td></td>
</tr>
<tr>
<td><a href="/2018/java-Reader-Writer.html#publicVoidWriteCC">public void write(char[] cbuf)</a></td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li>NIL</li>
</ol>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>NIL</li>
</ol>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java I/O 14 - InputStreamReader &amp; OutputStreamWriter</title>
    <url>/2018/java-InputStreamReader-OutputStreamWriter.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;关于<em> <strong>java.io.InputStreamReader</strong> </em> 和 <em> <strong>java.io.OutputStreamWriter</strong> </em>的部分笔记，这两个类完成了字节流和字符流之间的相互转化和读写操作，但是这两个类自身不负责任何操作，所有的操作均依赖于类StreamDecoder和StreamEncoder。本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;InputStreamReader和OutputStreamWriter是字节流和字符流之间进行相互转化的一个桥梁和媒介。InputStreamReader负责将字节流转成字符流，其底层是通过StreamDecoder来完成所有操作的。OutputStreamWriter则负责将字符流转换成对应的字节流，其底层的实现则依赖于StreamEncoder。换言之，InputStreamReader和OutputStreamWriter自身并不需要做什么操作和处理，所有的操作和实现都是在底层的调用StreamDecoder和StreamEncoder中，InputStreamReader和OutputStreamWriter只是起到了一个封装和调用的作用。</p>
<p>&emsp;</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// InputStreamReader</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.io.Reader</span><br><span class="line">    --java.io.InputStreamReader</span><br><span class="line"></span><br><span class="line"><span class="comment">// OutputStreamWriter</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.io.Writer</span><br><span class="line">    --java.io.OutputStreamWriter</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类名</th>
<th style="text-align:center">实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">InputStreamReader</td>
<td style="text-align:center">Closeable, AutoCloseable,Readable</td>
</tr>
<tr>
<td style="text-align:center">OutputStreamWriter</td>
<td style="text-align:center">Closeable, Flushable, Appendable,AutoCloseable</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h2><h3 id="Constructor-Summary"><a href="#Constructor-Summary" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="public-InputStreamReader-InputStream-in"><a href="#public-InputStreamReader-InputStream-in" class="headerlink" title="public InputStreamReader(InputStream in)"></a>public InputStreamReader(InputStream in)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InputStreamReader</span><span class="params">(InputStream in)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(in);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// ## check lock object</span></span><br><span class="line">        sd = StreamDecoder.forInputStreamReader(in, <span class="keyword">this</span>, (String)<span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        <span class="comment">// The default encoding should always be available</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个底层的StreamDecoder。在InputStreamReader中，所有的流读取和转换操作都是在流解码器（StreamDecoder）中完成的。所以在完成继承父类的构造函数后，即通过<strong>StreamDecoder</strong>的方法forInputStreamReader来完成StreamDecoder的初始化工作。StreamDecoder的相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Charset cs;</span><br><span class="line"><span class="keyword">private</span> CharsetDecoder decoder;</span><br><span class="line"><span class="keyword">private</span> ByteBuffer bb;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Exactly one of these is non-null</span></span><br><span class="line"><span class="keyword">private</span> InputStream in;</span><br><span class="line"><span class="keyword">private</span> ReadableByteChannel ch;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StreamDecoder <span class="title">forInputStreamReader</span><span class="params">(InputStream in, Object lock,</span></span></span><br><span class="line"><span class="function"><span class="params">			String charsetName)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">    String csn = charsetName;</span><br><span class="line">    <span class="keyword">if</span> (csn == <span class="keyword">null</span>)</span><br><span class="line">        csn = Charset.defaultCharset().name();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Charset.isSupported(csn))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> StreamDecoder(in, lock, Charset.forName(csn));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalCharsetNameException x) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedEncodingException(csn);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">StreamDecoder(InputStream in, Object lock, Charset cs) &#123;</span><br><span class="line">    <span class="keyword">this</span>(in, lock,</span><br><span class="line">         cs.newDecoder()</span><br><span class="line">         .onMalformedInput(CodingErrorAction.REPLACE)</span><br><span class="line">         .onUnmappableCharacter(CodingErrorAction.REPLACE));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StreamDecoder(InputStream in, Object lock, CharsetDecoder dec) &#123;</span><br><span class="line">    <span class="keyword">super</span>(lock);</span><br><span class="line">    <span class="keyword">this</span>.cs = dec.charset();</span><br><span class="line">    <span class="keyword">this</span>.decoder = dec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This path disabled until direct buffers are faster</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span> &amp;&amp; in <span class="keyword">instanceof</span> FileInputStream) &#123;</span><br><span class="line">        ch = getChannel((FileInputStream)in);</span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="keyword">null</span>)</span><br><span class="line">            bb = ByteBuffer.allocateDirect(DEFAULT_BYTE_BUFFER_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.in = in;</span><br><span class="line">        <span class="keyword">this</span>.ch = <span class="keyword">null</span>;</span><br><span class="line">        bb = ByteBuffer.allocate(DEFAULT_BYTE_BUFFER_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    bb.flip();                      <span class="comment">// So that bb is initially empty</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;StreamDecoder的路径信息如下：<strong>sun.nio.cs.StreamDecoder</strong>。方法forInputStreamReader( InputStream in, Object lock, String charsetName)完成StreamDecoder的初始化工作。第11 ~ 13行代码负责指定一个编码字符集。第16行代码则创建了一个StreamDecoder，并返回给方法调用方。第22 ~ 27行代码中，根据传入的字符集创建一个字符集解码器，然后调用方法StreamDecoder (InputStream in, Object lock, CharsetDecoder dec)完成相应的初始化操作。由于StreamDecoder继承了Reader，所以第30行代码会首先调用父类的有参构造方法。第31 ~ 32行指定了字符集和字符集解码器。第40 ~ 44行代码则指定了最终调用的输入流和用到的字节缓冲数组的大小，初始化大小为<strong>8192</strong>。第45行代码则表示缓冲数组目前为空，第一个可以写入的位置为0位置。</p>
<h4 id="public-InputStreamReader-InputStream-in-String-charsetName"><a href="#public-InputStreamReader-InputStream-in-String-charsetName" class="headerlink" title="public InputStreamReader(InputStream in, String charsetName)"></a>public InputStreamReader(InputStream in, String charsetName)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InputStreamReader</span><span class="params">(InputStream in, String charsetName)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(in);</span><br><span class="line">    <span class="keyword">if</span> (charsetName == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"charsetName"</span>);</span><br><span class="line">     sd = StreamDecoder.forInputStreamReader(in, <span class="keyword">this</span>, charsetName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个底层的StreamDecoder。这个方法中显示指定了需要使用的字符集编码。</p>
<h4 id="public-InputStreamReader-InputStream-in-Charset-cs"><a href="#public-InputStreamReader-InputStream-in-Charset-cs" class="headerlink" title="public InputStreamReader(InputStream in, Charset cs)"></a>public InputStreamReader(InputStream in, Charset cs)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InputStreamReader</span><span class="params">(InputStream in, Charset cs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(in);</span><br><span class="line">    <span class="keyword">if</span> (cs == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"charset"</span>);</span><br><span class="line">    sd = StreamDecoder.forInputStreamReader(in, <span class="keyword">this</span>, cs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个底层的StreamDecoder。这个方法中显示指定了需要使用的字符集编码。创建StreamDecoder调用的方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StreamDecoder <span class="title">forInputStreamReader</span><span class="params">(InputStream in, Object lock,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 Charset cs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StreamDecoder(in, lock, cs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用的构造方法和<strong>public InputStreamReader(InputStream in)</strong>实际调用的方法一致。</p>
<h4 id="public-InputStreamReader-InputStream-in-CharsetDecoder-dec"><a href="#public-InputStreamReader-InputStream-in-CharsetDecoder-dec" class="headerlink" title="public InputStreamReader(InputStream in, CharsetDecoder dec)"></a>public InputStreamReader(InputStream in, CharsetDecoder dec)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InputStreamReader</span><span class="params">(InputStream in, CharsetDecoder dec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(in);</span><br><span class="line">    <span class="keyword">if</span> (dec == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"charset decoder"</span>);</span><br><span class="line">    sd = StreamDecoder.forInputStreamReader(in, <span class="keyword">this</span>, dec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个底层的StreamDecoder。这个方法中显示指定了需要使用的字符集解码器。CharsetDecoder可以将一个字节序列按照特定的字符集转换成一个16位的Unicode序列。创建StreamDecoder调用的方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StreamDecoder <span class="title">forInputStreamReader</span><span class="params">(InputStream in, Object lock,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 CharsetDecoder dec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StreamDecoder(in, lock, dec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用的构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StreamDecoder(InputStream in, Object lock, CharsetDecoder dec) &#123;</span><br><span class="line">    <span class="keyword">super</span>(lock);</span><br><span class="line">    <span class="keyword">this</span>.cs = dec.charset();</span><br><span class="line">    <span class="keyword">this</span>.decoder = dec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This path disabled until direct buffers are faster</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span> &amp;&amp; in <span class="keyword">instanceof</span> FileInputStream) &#123;</span><br><span class="line">        ch = getChannel((FileInputStream)in);</span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="keyword">null</span>)</span><br><span class="line">            bb = ByteBuffer.allocateDirect(DEFAULT_BYTE_BUFFER_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.in = in;</span><br><span class="line">        <span class="keyword">this</span>.ch = <span class="keyword">null</span>;</span><br><span class="line">        bb = ByteBuffer.allocate(DEFAULT_BYTE_BUFFER_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    bb.flip();                      <span class="comment">// So that bb is initially empty</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="public-String-getEncoding"><a href="#public-String-getEncoding" class="headerlink" title="public String getEncoding()"></a><span id="publicStringGetEncoding">public String getEncoding()</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getEncoding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sd.getEncoding();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;获取当前流使用的编码字符集信息，如果当前流已经被关闭，那么会返回null给接口调用方。具体实现位于StreamDecoder中，相关代码段如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getEncoding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isOpen())</span><br><span class="line">        <span class="keyword">return</span> encodingName();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 流是否开启，默认为true，由close方法赋值为false</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isOpen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">encodingName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((cs <span class="keyword">instanceof</span> HistoricallyNamedCharset)</span><br><span class="line">            ? ((HistoricallyNamedCharset)cs).historicalName()</span><br><span class="line">            : cs.name());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在StreamDecoder的getEncoding()方法中，首先检查了当前输入流的开闭状态，如果当前输入流已经关闭，那么就返回null，否则就通过调用encodingName()来获取当前流采用的编码字符集信息。在encodingName()方法中，会判断当前编码字符集的种类，如果当前编码字符集是一个HistoricallyNamedCharset，那么就返回对应的historicalName，否则就返回对应的编码字符集名称。</p>
<h4 id="public-int-read"><a href="#public-int-read" class="headerlink" title="public int read()"></a><span id="publicIntRead">public int read()</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sd.read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从底层输入流中读取一个字节的内容并返回给调用方。具体实现位于StreamDecoder中，相关代码段如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> read0();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> haveLeftoverChar = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">char</span> leftoverChar;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">read0</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return the leftover char, if there is one</span></span><br><span class="line">        <span class="keyword">if</span> (haveLeftoverChar) &#123;</span><br><span class="line">            haveLeftoverChar = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> leftoverChar;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Convert more bytes</span></span><br><span class="line">        <span class="keyword">char</span> cb[] = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> n = read(cb, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">            <span class="keyword">case</span> -<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                leftoverChar = cb[<span class="number">1</span>];</span><br><span class="line">                haveLeftoverChar = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// FALL THROUGH</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> cb[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">assert</span> <span class="keyword">false</span> : n;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;StreamDecoder中的方法read()中所有的逻辑操作都位于方法read0()中。在StreamDecoder中，为了支持对由两个字符构成的字符进行编解码的处理，每次都需要从底层输入流中读取两个字符的数据。但是方法只会返回一个字符，所以需要通过haveLeftoverChar来标记是否存储了一个高位字符，如果存储了一个高位字符的话，则需要通过leftoverChar来返回存储的高位字符。</p>
<p>&emsp;&emsp;底层方法read0()完成数据的读取操作，且该方法内部整个方法体由synchronized关键字完成多线程环境下的锁操作。第11 ~ 15行代码中，如果存储了一个高位字符（haveLeftoverChar = true），那么就返回其存储的高位字符。第19行代码则从方法read(char cbuf[], int offset, int length)中读取两个字符。第20 ~ 32行则分情况向接口调用方返回读取到的字符信息。</p>
<h4 id="public-int-read-char-cbuf-int-offset-int-length"><a href="#public-int-read-char-cbuf-int-offset-int-length" class="headerlink" title="public int read(char cbuf[], int offset, int length)"></a><span id="publicIntReadCII">public int read(char cbuf[], int offset, int length)</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> cbuf[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sd.read(cbuf, offset, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;底层输入流中将读取的内容存储到入参数组cbuf中并返回实际读取到的数据长度给调用方。具体实现位于StreamDecoder中，相关代码段如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureOpen</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isOpen)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Stream closed"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> cbuf[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> off = offset;</span><br><span class="line">    <span class="keyword">int</span> len = length;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line">        <span class="keyword">if</span> ((off &lt; <span class="number">0</span>) || (off &gt; cbuf.length) || (len &lt; <span class="number">0</span>) ||</span><br><span class="line">            ((off + len) &gt; cbuf.length) || ((off + len) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (haveLeftoverChar) &#123;</span><br><span class="line">            <span class="comment">// Copy the leftover char into the buffer</span></span><br><span class="line">            cbuf[off] = leftoverChar;</span><br><span class="line">            off++; len--;</span><br><span class="line">            haveLeftoverChar = <span class="keyword">false</span>;</span><br><span class="line">            n = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> ((len == <span class="number">0</span>) || !implReady())</span><br><span class="line">                <span class="comment">// Return now if this is all we can produce w/o blocking</span></span><br><span class="line">                <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// Treat single-character array reads just like read()</span></span><br><span class="line">            <span class="keyword">int</span> c = read0();</span><br><span class="line">            <span class="keyword">if</span> (c == -<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> (n == <span class="number">0</span>) ? -<span class="number">1</span> : n;</span><br><span class="line">            cbuf[off] = (<span class="keyword">char</span>)c;</span><br><span class="line">            <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n + implRead(cbuf, off, off + len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;该方法会读取入参length指定长度的数据内容并存储到入参cbuf中。方法体被synchronized包围保证了多线程环境的锁操作。第10行代码判断当前输入流的开闭状态，如果关闭则直接抛出一个流关闭异常给方法调用方。第11 ~ 14行代码负责参数的有效性校验，防止出现越界溢出的情况。第18行代码初始化一个计数器n，用来标记实际读取的字符数。第20 ~ 29行代码中，如果当前环境已经存储了一个高位字符，那么就取出存储的高位字符保存到cbuf中，这个字符会作为读取到到的第一个字符被返回。之后更新了off，len和n的值。如果len已经变为0，或者底层输入流中已经没有可读的数据内容，那么就认为读取结束，直接返回当前记录的实际读取的字符数内容。第31 ~ 38行代码中，如果剩余需要读取的字符长度为1，那么就调用上面提到的read0()方法，该方法会直接读取并返回一个字符内容。最后返回实际读取的字符数。第40行代码则继续从底层输入流中读取字符内容，并返回最终实际读取的字符长度。其调用的方法<strong>implRead()</strong>处理逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> CharsetDecoder decoder;</span><br><span class="line"><span class="keyword">private</span> ByteBuffer bb;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">implRead</span><span class="params">(<span class="keyword">char</span>[] cbuf, <span class="keyword">int</span> off, <span class="keyword">int</span> end)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// In order to handle surrogate pairs, this method requires that</span></span><br><span class="line">    <span class="comment">// the invoker attempt to read at least two characters.  Saving the</span></span><br><span class="line">    <span class="comment">// extra character, if any, at a higher level is easier than trying</span></span><br><span class="line">    <span class="comment">// to deal with it here.</span></span><br><span class="line">    <span class="keyword">assert</span> (end - off &gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    CharBuffer cb = CharBuffer.wrap(cbuf, off, end - off);</span><br><span class="line">    <span class="keyword">if</span> (cb.position() != <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// Ensure that cb[0] == cbuf[off]</span></span><br><span class="line">        cb = cb.slice();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> eof = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        CoderResult cr = decoder.decode(bb, cb, eof);</span><br><span class="line">        <span class="keyword">if</span> (cr.isUnderflow()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eof)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (!cb.hasRemaining())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> ((cb.position() &gt; <span class="number">0</span>) &amp;&amp; !inReady())</span><br><span class="line">                <span class="keyword">break</span>;          <span class="comment">// Block at most once</span></span><br><span class="line">            <span class="keyword">int</span> n = readBytes();</span><br><span class="line">            <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                eof = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> ((cb.position() == <span class="number">0</span>) &amp;&amp; (!bb.hasRemaining()))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                decoder.reset();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cr.isOverflow()) &#123;</span><br><span class="line">            <span class="keyword">assert</span> cb.position() &gt; <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cr.throwException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eof) &#123;</span><br><span class="line">        <span class="comment">// ## Need to flush decoder</span></span><br><span class="line">        decoder.reset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cb.position() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eof)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cb.position();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;该方法用来把从底层输入流读取到的字节流转成字符流，然后再保存到数组cbuf中。第9行代码做了一个关于入参off和end的大小关系，避免越界溢出的情况发生，需要注意的是，这里的参数end和off一样，为下标值，而不是需要读取的长度值。第11 ~ 14行代码将入参cbuf封装到一个字符buffer中，对cbuf和字符buffer中任意一个的修改都会导致另外一个同时发生变更。第17 ~ 40行代码完成实际的字节数据转字符数据的操作，具体操作逻辑如下：</p>
<ol>
<li>第18行代码将当前字节buffer中的数据转成字符数据，并存储到字符buffer中；</li>
<li>第19 ~ 21行代码中，如果字节buffer中的数据已经全部解码并存储到字符buffer中且已经读到了文件结束位置（eof = true），那么退出循环；</li>
<li>第22 ~ 23行代码中，如果字节buffer中的数据已经全部解码并存储到字符buffer中且字符buffer中已经没有空余空间来容纳新的字符数据，那么退出循环；</li>
<li>第24 ~ 25行代码中，如果字节buffer中的数据已经全部解码并存储到字符buffer中且底层输入流已经不再支持通过read方法获取数据，那么退出循环；</li>
<li>通过readBytes()方法从底层输入流中获取字节数据，数据会被存储在字节buffer中，并返回实际读取的数据长度；</li>
<li>如果通过readBytes()方法未读取到至少一个数据，那么设置eof = true，同时如果字节buffer中所有数据都已经读取完毕，那么退出循环；</li>
<li>继续循环，将字节buffer中的内容解码存储到字符buffer中；</li>
<li>第35 ~ 38行代码表示如果字符buffer中空间已满，那么退出循环。</li>
</ol>
<p>最后返回字符buffer中实际读取的数据长度。其中涉及到的readBytes()方法的相关实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ByteBuffer bb;</span><br><span class="line"><span class="keyword">private</span> ReadableByteChannel ch;</span><br><span class="line"><span class="keyword">private</span> InputStream in;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">readBytes</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    bb.compact();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Read from the channel</span></span><br><span class="line">            <span class="keyword">int</span> n = ch.read(bb);</span><br><span class="line">            <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> n;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Read from the input stream, and then update the buffer</span></span><br><span class="line">            <span class="keyword">int</span> lim = bb.limit();</span><br><span class="line">            <span class="keyword">int</span> pos = bb.position();</span><br><span class="line">            <span class="keyword">assert</span> (pos &lt;= lim);</span><br><span class="line">            <span class="keyword">int</span> rem = (pos &lt;= lim ? lim - pos : <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">assert</span> rem &gt; <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> n = in.read(bb.array(), bb.arrayOffset() + pos, rem);</span><br><span class="line">            <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> n;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Underlying input stream returned zero bytes"</span>);</span><br><span class="line">            <span class="keyword">assert</span> (n &lt;= rem) : <span class="string">"n = "</span> + n + <span class="string">", rem = "</span> + rem;</span><br><span class="line">            bb.position(pos + n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// Flip even when an IOException is thrown,</span></span><br><span class="line">        <span class="comment">// otherwise the stream will stutter</span></span><br><span class="line">        bb.flip();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rem = bb.remaining();</span><br><span class="line">    <span class="keyword">assert</span> (rem != <span class="number">0</span>) : rem;</span><br><span class="line">    <span class="keyword">return</span> rem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;该方法完成从底层输入流中读取字节数据到字节buffer中的操作处理。第6行代码会将字节buffer中未读取的数据全部移到buffer左端，这样右端会留出空间来容纳新数据。第8 ~ 12行代码通过ReadableByteChannel来获取数据，第14 ~ 27行代码则通过输入流来获取数据，其中，第15 ~ 19行代码完成可用空间的计算，第20行代码则会从底层输入流中读取数据并存储在字节buffer中。第26行代码则更新字节buffer中下一个可以新数据的位置值。第31行代码负责读写转换，会将position置为0，同时将limit移动到存储的最后一个字节数据的位置。最后返回字节buffer中包含的未读取的字节数据的长度。</p>
<h4 id="public-boolean-ready"><a href="#public-boolean-ready" class="headerlink" title="public boolean ready()"></a><span id="publicBooleanReady">public boolean ready()</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">ready</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sd.ready();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回当前输入流是否可以通过read方法得到字符数据。具体实现位于StreamDecoder中，相关代码段如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ByteBuffer bb;</span><br><span class="line"><span class="keyword">private</span> InputStream in;</span><br><span class="line"><span class="keyword">private</span> ReadableByteChannel ch;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">ready</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line">        <span class="keyword">return</span> haveLeftoverChar || implReady();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">implReady</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bb.hasRemaining() || inReady();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">inReady</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (((in != <span class="keyword">null</span>) &amp;&amp; (in.available() &gt; <span class="number">0</span>))</span><br><span class="line">                || (ch <span class="keyword">instanceof</span> FileChannel)); <span class="comment">// ## RBC.available()?</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在StreamDecoder中，ready方法体被synchronized关键字包围，保证了多线程环境下一次只能被一个线程访问和操作。为了确认是否可以对外提供数据，首先会通过ensureOpen()判断当前流是否开启，只有在开启情况下才能对外提供数据。如果在之前的read方法调用过程中存储了高位字符，那么haveLeftoverChar的值就为true，可以继续通过read方法返回存储的高位字符，或者通过implReady()方法判断底层输入流中是否有未读取的数据流信息。</p>
<p>&emsp;&emsp;在implReady()方法中，如果字节buffer中有数据，那么认为当前流是可对外提供数据的，或者通过inReady()方法来判断底层输入流中是否有可读取的数据内容。</p>
<h4 id="public-void-close"><a href="#public-void-close" class="headerlink" title="public void close()"></a><span id="publicVoidClose">public void close()</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    sd.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;关闭当前输入流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> InputStream in;</span><br><span class="line"><span class="keyword">private</span> ReadableByteChannel ch;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isOpen)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        implClose();</span><br><span class="line">        isOpen = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">implClose</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ch != <span class="keyword">null</span>)</span><br><span class="line">        ch.close();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        in.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;关闭当前输入流，释放占用资源。</p>
<p>&emsp;</p>
<h2 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a>OutputStreamWriter</h2><h3 id="Constructor-Summary-1"><a href="#Constructor-Summary-1" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="public-OutputStreamWriter-OutputStream-out-String-charsetName"><a href="#public-OutputStreamWriter-OutputStream-out-String-charsetName" class="headerlink" title="public OutputStreamWriter(OutputStream out, String charsetName)"></a>public OutputStreamWriter(OutputStream out, String charsetName)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OutputStreamWriter</span><span class="params">(OutputStream out, String charsetName)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(out);</span><br><span class="line">    <span class="keyword">if</span> (charsetName == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"charsetName"</span>);</span><br><span class="line">    se = StreamEncoder.forOutputStreamWriter(out, <span class="keyword">this</span>, charsetName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个底层的StreamEncoder。在OutputStreamWriter中，所有的流写入和转换操作都是在流编码器（StreamEncoder）中完成的。所以在完成继承父类的构造函数后，即通过<strong>StreamEncoder</strong>的方法forOutputStreamWriter来完成StreamEncoder的初始化工作。StreamEncoder的相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Charset cs;</span><br><span class="line"><span class="keyword">private</span> CharsetEncoder encoder;</span><br><span class="line"><span class="keyword">private</span> ByteBuffer bb;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OutputStream out;</span><br><span class="line"><span class="keyword">private</span> WritableByteChannel ch;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StreamEncoder <span class="title">forOutputStreamWriter</span><span class="params">(OutputStream out, Object lock,</span></span></span><br><span class="line"><span class="function"><span class="params">    String charsetName)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">    String csn = charsetName;</span><br><span class="line">    <span class="keyword">if</span> (csn == <span class="keyword">null</span>)</span><br><span class="line">        csn = Charset.defaultCharset().name();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Charset.isSupported(csn))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> StreamEncoder(out, lock, Charset.forName(csn));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalCharsetNameException x) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedEncodingException(csn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">StreamEncoder</span><span class="params">(OutputStream out, Object lock, Charset cs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(out, lock,</span><br><span class="line">         cs.newEncoder()</span><br><span class="line">         .onMalformedInput(CodingErrorAction.REPLACE)</span><br><span class="line">         .onUnmappableCharacter(CodingErrorAction.REPLACE));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">StreamEncoder</span><span class="params">(OutputStream out, Object lock, CharsetEncoder enc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(lock);</span><br><span class="line">    <span class="keyword">this</span>.out = out;</span><br><span class="line">    <span class="keyword">this</span>.ch = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.cs = enc.charset();</span><br><span class="line">    <span class="keyword">this</span>.encoder = enc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This path disabled until direct buffers are faster</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span> &amp;&amp; out <span class="keyword">instanceof</span> FileOutputStream) &#123;</span><br><span class="line">        ch = ((FileOutputStream)out).getChannel();</span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="keyword">null</span>)</span><br><span class="line">            bb = ByteBuffer.allocateDirect(DEFAULT_BYTE_BUFFER_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="keyword">null</span>) &#123;</span><br><span class="line">        bb = ByteBuffer.allocate(DEFAULT_BYTE_BUFFER_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;StreamEncoder的路径信息如下：<strong>sun.nio.cs.StreamEncoder</strong>。方法forOutputStreamWriter( OutputStream out, Object lock, String charsetName)完成StreamEncoder的初始化工作。第10 ~ 11行代码负责指定一个编码字符集。第14行代码则创建了一个StreamEncoder，并返回给方法调用方。第22 ~ 24行代码中，根据传入的字符集创建一个字符集解码器，然后调用方法StreamEncoder(OutputStream out, Object lock, CharsetEncoder enc)完成相应的初始化操作。由于StreamEncoder继承了Writer，所以第30行代码会首先调用父类的有参构造方法。第29 ~ 32行指定了字符集和字符集解码器。第40 ~ 42行代码则指定了最终调用的输入流和用到的字节缓冲数组的大小，初始化大小为<strong>8192</strong>。第45行代码则表示缓冲数组目前为空，第一个可以写入的位置为0位置。</p>
<h4 id="public-OutputStreamWriter-OutputStream-out"><a href="#public-OutputStreamWriter-OutputStream-out" class="headerlink" title="public OutputStreamWriter(OutputStream out)"></a>public OutputStreamWriter(OutputStream out)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OutputStreamWriter</span><span class="params">(OutputStream out)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(out);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        se = StreamEncoder.forOutputStreamWriter(out, <span class="keyword">this</span>, (String)<span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个底层的StreamEncoder。这个方法中采用默认的字符集编码。</p>
<h4 id="public-OutputStreamWriter-OutputStream-out-Charset-cs"><a href="#public-OutputStreamWriter-OutputStream-out-Charset-cs" class="headerlink" title="public OutputStreamWriter(OutputStream out, Charset cs)"></a>public OutputStreamWriter(OutputStream out, Charset cs)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OutputStreamWriter</span><span class="params">(OutputStream out, Charset cs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(out);</span><br><span class="line">    <span class="keyword">if</span> (cs == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"charset"</span>);</span><br><span class="line">    se = StreamEncoder.forOutputStreamWriter(out, <span class="keyword">this</span>, cs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个底层的StreamEncoder。这个方法中显示指定了需要使用的字符集。创建StreamEncoder调用的方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StreamEncoder <span class="title">forOutputStreamWriter</span><span class="params">(OutputStream out,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  Object lock,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  Charset cs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StreamEncoder(out, lock, cs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="public-OutputStreamWriter-OutputStream-out-CharsetEncoder-enc"><a href="#public-OutputStreamWriter-OutputStream-out-CharsetEncoder-enc" class="headerlink" title="public OutputStreamWriter(OutputStream out, CharsetEncoder enc)"></a>public OutputStreamWriter(OutputStream out, CharsetEncoder enc)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OutputStreamWriter</span><span class="params">(OutputStream out, CharsetEncoder enc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(out);</span><br><span class="line">    <span class="keyword">if</span> (enc == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"charset encoder"</span>);</span><br><span class="line">    se = StreamEncoder.forOutputStreamWriter(out, <span class="keyword">this</span>, enc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个底层的StreamEncoder。这个方法中显示指定了需要使用的字符集编码器。创建StreamEncoder调用的方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StreamEncoder <span class="title">forOutputStreamWriter</span><span class="params">(OutputStream out,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  Object lock,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  CharsetEncoder enc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StreamEncoder(out, lock, enc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="部分方法-1"><a href="#部分方法-1" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="public-String-getEncoding-1"><a href="#public-String-getEncoding-1" class="headerlink" title="public String getEncoding()"></a><span id="publicStringGetEncodingOut">public String getEncoding()</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getEncoding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> se.getEncoding();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;获取当前流使用的编码字符集信息，如果当前流已经被关闭，那么会返回null给接口调用方。具体实现位于StreamEncoder中，相关代码段如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getEncoding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isOpen())</span><br><span class="line">        <span class="keyword">return</span> encodingName();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isOpen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">encodingName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((cs <span class="keyword">instanceof</span> HistoricallyNamedCharset)</span><br><span class="line">            ? ((HistoricallyNamedCharset)cs).historicalName()</span><br><span class="line">            : cs.name());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在StreamEncoder的getEncoding()方法中，首先检查了当前输出流的开闭状态，如果当前输出流已经关闭，那么就返回null，否则就通过调用encodingName()来获取当前流采用的编码字符集信息。在encodingName()方法中，会判断当前编码字符集的种类，如果当前编码字符集是一个HistoricallyNamedCharset，那么就返回对应的historicalName，否则就返回对应的编码字符集名称。</p>
<h4 id="void-flushBuffer"><a href="#void-flushBuffer" class="headerlink" title="void flushBuffer()"></a><span id="voidFlushBuffer">void flushBuffer()</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flushBuffer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    se.flushBuffer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;把输出缓冲区buffer的数据推送到底层字节输出流中。具体实现位于StreamEncoder中，相关代码段如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flushBuffer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isOpen())</span><br><span class="line">            implFlushBuffer();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Stream closed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">implFlushBuffer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bb.position() &gt; <span class="number">0</span>)</span><br><span class="line">        writeBytes();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeBytes</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    bb.flip();</span><br><span class="line">    <span class="keyword">int</span> lim = bb.limit();</span><br><span class="line">    <span class="keyword">int</span> pos = bb.position();</span><br><span class="line">    <span class="keyword">assert</span> (pos &lt;= lim);</span><br><span class="line">    <span class="keyword">int</span> rem = (pos &lt;= lim ? lim - pos : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rem &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch.write(bb) != rem)</span><br><span class="line">                <span class="keyword">assert</span> <span class="keyword">false</span> : rem;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            out.write(bb.array(), bb.arrayOffset() + pos, rem);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bb.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在flushBuffer()方法中，整个方法体被synchronized包围，保证了多线程环境下的同时只有一个线程可以获得资源的访问控制。如果当前流是开启的，那么调用implFlushBuffer()方法完成数据向底层输出流的推送。在第11 ~ 13行代码中，此时字节buffer<strong>bb</strong>处于写状态，所以一旦有内容写入，那么position满足大于0的条件，那么就调用writeBytes()方法完成具体的数据推送处理。</p>
<p>&emsp;&emsp;在writeBytes()方法中，第16行代码将字节buffer由写状态转变成读状态。第17 ~ 20行代码完成空间和起始位置的相关计算。第23 ~ 28行代码则会将字节buffer中的内容实际写入到对应的底层输出流中。最后将字节buffer的内容清空，完成所有操作。</p>
<h4 id="public-void-write-int-c"><a href="#public-void-write-int-c" class="headerlink" title="public void write(int c)"></a><span id="publicVoidWrite">public void write(int c)</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> c)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    se.write(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;向底层输出流中写入一个字节的数据。因为在实际写入时，会首先将字符数据转成字节数据，然后将转换后的字节数据存储在一个字节buffer中，此时数据并没有真正的被写出去，所以需要通过调用 flushBuffer()或者close()方法将字节buffer的数据真正写入到某个输出流中，否则会发生数据丢失无法获取的情况。具体实现位于StreamEncoder中，相关代码段如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> CharsetEncoder encoder;</span><br><span class="line"><span class="keyword">private</span> ByteBuffer bb;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> c)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> cbuf[] = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">    cbuf[<span class="number">0</span>] = (<span class="keyword">char</span>) c;</span><br><span class="line">    write(cbuf, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureOpen</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isOpen)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Stream closed"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> cbuf[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line">        <span class="keyword">if</span> ((off &lt; <span class="number">0</span>) || (off &gt; cbuf.length) || (len &lt; <span class="number">0</span>) ||</span><br><span class="line">            ((off + len) &gt; cbuf.length) || ((off + len) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        implWrite(cbuf, off, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">implWrite</span><span class="params">(<span class="keyword">char</span> cbuf[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    CharBuffer cb = CharBuffer.wrap(cbuf, off, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (haveLeftoverChar)</span><br><span class="line">        flushLeftoverChar(cb, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cb.hasRemaining()) &#123;</span><br><span class="line">        CoderResult cr = encoder.encode(cb, bb, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (cr.isUnderflow()) &#123;</span><br><span class="line">            <span class="keyword">assert</span> (cb.remaining() &lt;= <span class="number">1</span>) : cb.remaining();</span><br><span class="line">            <span class="keyword">if</span> (cb.remaining() == <span class="number">1</span>) &#123;</span><br><span class="line">                haveLeftoverChar = <span class="keyword">true</span>;</span><br><span class="line">                leftoverChar = cb.get();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cr.isOverflow()) &#123;</span><br><span class="line">            <span class="keyword">assert</span> bb.position() &gt; <span class="number">0</span>;</span><br><span class="line">            writeBytes();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cr.throwException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;write(int c)最终依赖方法write(char cbuf[], int off, int len)完成字符数据向字节数据的转换以及写入操作。write(char cbuf[], int off, int len)底层直接依赖implWrite(char cbuf[], int off, int len)方法完成相关操作。第31 ~ 32行代码中，如果之前的写入操作中检测到了高位字符，那么就把保存下来的高位字符连同本次的字符数组中的内容一起写入到字节buffer中。第34 ~ 50行代码完成字符数据向字节数据的转换，将数据写入到底层的字节buffer中，最后将字节buffer中的数据写入到底层输出流中。第35行代码将字符数组中的内容转换成字节数据，并保存到字节buffer中。第36 ~ 43行代码如果最后字符数组中还留有一个字符，那么就标记高位字符并保存这个剩余的字符。第44 ~ 48行代码如果字节buffer没有空间来容纳新的字节数据，那么就将字节buffer中的内容输出到底层输出流中，清空字节buffer来容纳新的字节数据。下面的代码演示了如何处理高位字符的场景：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> haveLeftoverChar = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">char</span> leftoverChar;</span><br><span class="line"><span class="keyword">private</span> CharBuffer lcb = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> ByteBuffer bb;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushLeftoverChar</span><span class="params">(CharBuffer cb, <span class="keyword">boolean</span> endOfInput)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!haveLeftoverChar &amp;&amp; !endOfInput)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (lcb == <span class="keyword">null</span>)</span><br><span class="line">        lcb = CharBuffer.allocate(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        lcb.clear();</span><br><span class="line">    <span class="keyword">if</span> (haveLeftoverChar)</span><br><span class="line">        lcb.put(leftoverChar);</span><br><span class="line">    <span class="keyword">if</span> ((cb != <span class="keyword">null</span>) &amp;&amp; cb.hasRemaining())</span><br><span class="line">        lcb.put(cb.get());</span><br><span class="line">    lcb.flip();</span><br><span class="line">    <span class="keyword">while</span> (lcb.hasRemaining() || endOfInput) &#123;</span><br><span class="line">        CoderResult cr = encoder.encode(lcb, bb, endOfInput);</span><br><span class="line">        <span class="keyword">if</span> (cr.isUnderflow()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lcb.hasRemaining()) &#123;</span><br><span class="line">                leftoverChar = lcb.get();</span><br><span class="line">                <span class="keyword">if</span> (cb != <span class="keyword">null</span> &amp;&amp; cb.hasRemaining())</span><br><span class="line">                    flushLeftoverChar(cb, endOfInput);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cr.isOverflow()) &#123;</span><br><span class="line">            <span class="keyword">assert</span> bb.position() &gt; <span class="number">0</span>;</span><br><span class="line">            writeBytes();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cr.throwException();</span><br><span class="line">    &#125;</span><br><span class="line">    haveLeftoverChar = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;第11 ~ 18行代码将保留的高位字符和入参字符buffer的内容都获取到，然后在第19行将字节buffer转成读模式。第21行代码将字符数据编码成字节数据并存入字节buffer中。如果仍有留余，继续调用自身直至数据全部换成完成。如果字节buffer没有空间容纳新数据，那么将字节buffer中的数据全部写入到底层输出流中清空字节buffer继续循环过程。</p>
<h4 id="public-void-write-char-cbuf-int-off-int-len"><a href="#public-void-write-char-cbuf-int-off-int-len" class="headerlink" title="public void write(char cbuf[], int off, int len)"></a><span id="publicVoidWriteCII">public void write(char cbuf[], int off, int len)</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> cbuf[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    se.write(cbuf, off, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将一个字符数组cbuf中的内容写入到底层输出流中。</p>
<h4 id="public-void-write-String-str-int-off-int-len"><a href="#public-void-write-String-str-int-off-int-len" class="headerlink" title="public void write(String str, int off, int len)"></a><span id="publicVoidWriteSII">public void write(String str, int off, int len)</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String str, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    se.write(str, off, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将一个String字符串写入到底层输出流中。具体实现位于StreamEncoder中，相关代码段如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String str, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">/* Check the len before creating a char buffer */</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    <span class="keyword">char</span> cbuf[] = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">    str.getChars(off, off + len, cbuf, <span class="number">0</span>);</span><br><span class="line">    write(cbuf, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在方法中，会将String字符串先转成一个char数组，然后再调用上面提到的write(char cbuf[], int off, int len)将数据写入到底层输出流中。</p>
<h4 id="public-void-flush"><a href="#public-void-flush" class="headerlink" title="public void flush()"></a><span id="publicVoidFlush">public void flush()</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    se.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将底层字节buffer的数据输出到底层输出流中。具体实现位于StreamEncoder中，相关代码段如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line">        implFlush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">implFlushBuffer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bb.position() &gt; <span class="number">0</span>)</span><br><span class="line">        writeBytes();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">implFlush</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    implFlushBuffer();</span><br><span class="line">    <span class="keyword">if</span> (out != <span class="keyword">null</span>)</span><br><span class="line">        out.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在StreamEncoder的flush()方法，最终由方法implFlush()完成推送操作。在该方法中，首先调用方法implFlushBuffer()将底层字节buffer的内容输出到底层输出流中，输出完毕后关闭当前输出流，释放占用的资源。</p>
<h4 id="public-void-close-1"><a href="#public-void-close-1" class="headerlink" title="public void close()"></a><span id="publicVoidCloseOut">public void close()</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    se.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;关闭当前输入流。具体实现位于StreamEncoder中，相关代码段如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isOpen)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        implClose();</span><br><span class="line">        isOpen = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">implClose</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    flushLeftoverChar(<span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            CoderResult cr = encoder.flush(bb);</span><br><span class="line">            <span class="keyword">if</span> (cr.isUnderflow())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (cr.isOverflow()) &#123;</span><br><span class="line">                <span class="keyword">assert</span> bb.position() &gt; <span class="number">0</span>;</span><br><span class="line">                writeBytes();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cr.throwException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bb.position() &gt; <span class="number">0</span>)</span><br><span class="line">            writeBytes();</span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="keyword">null</span>)</span><br><span class="line">            ch.close();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            out.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">        encoder.reset();</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li><p>StreamDecoder的其他构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StreamDecoder <span class="title">forDecoder</span><span class="params">(ReadableByteChannel ch, CharsetDecoder dec, <span class="keyword">int</span> minBufferCap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StreamDecoder(ch, dec, minBufferCap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StreamDecoder(ReadableByteChannel ch, CharsetDecoder dec, <span class="keyword">int</span> mbc) &#123;</span><br><span class="line">    <span class="keyword">this</span>.in = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.ch = ch;</span><br><span class="line">    <span class="keyword">this</span>.decoder = dec;</span><br><span class="line">    <span class="keyword">this</span>.cs = dec.charset();</span><br><span class="line">    <span class="keyword">this</span>.bb = ByteBuffer.allocate(mbc &lt; <span class="number">0</span> ? DEFAULT_BYTE_BUFFER_SIZE</span><br><span class="line">                                  : (mbc &lt; MIN_BYTE_BUFFER_SIZE</span><br><span class="line">                                     ? MIN_BYTE_BUFFER_SIZE : mbc));</span><br><span class="line">    bb.flip();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>StreamEncoder的其他构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StreamEncoder <span class="title">forEncoder</span><span class="params">(WritableByteChannel ch, CharsetEncoder enc, <span class="keyword">int</span> minBufferCap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StreamEncoder(ch, enc, minBufferCap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">StreamEncoder</span><span class="params">(WritableByteChannel ch, CharsetEncoder enc, <span class="keyword">int</span> mbc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.out = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.ch = ch;</span><br><span class="line">    <span class="keyword">this</span>.cs = enc.charset();</span><br><span class="line">    <span class="keyword">this</span>.encoder = enc;</span><br><span class="line">    <span class="keyword">this</span>.bb = ByteBuffer.allocate(mbc &lt; <span class="number">0</span> ? DEFAULT_BYTE_BUFFER_SIZE : mbc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>黄亿华. <a href="https://my.oschina.net/flashsword/blog/159613" target="_blank" rel="noopener">Java NIO学习笔记之二-图解ByteBuffer</a> [E]</li>
<li>咕噜是个大胖子. <a href="https://blog.csdn.net/ai_bao_zi/article/details/81205286" target="_blank" rel="noopener">JAVA基础知识之StreamDecoder流</a> [E]</li>
<li>咕噜是个大胖子. <a href="https://blog.csdn.net/ai_bao_zi/article/details/81181198" target="_blank" rel="noopener">JAVA基础知识之StreamEncoder流</a> [E]</li>
<li>江湖人称小白哥. <a href="https://blog.csdn.net/dd864140130/article/details/50318977" target="_blank" rel="noopener">通俗编程——白话NIO之Buffer</a> [E]</li>
</ol>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java I/O 24 - ObjectInputStream内部类</title>
    <url>/2018/java-ObjectInputStream-InternalClass.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;关于<em> <strong>java.io.ObjectInputStream</strong> </em>内部类的部分笔记，里面涉及到了HandleTable、ValidationList、GetField及其实现等几个内部类的声明和实现。本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;HandleTable是一个非同步表，用来跟踪对象映射的连接句柄，以及反序列对象过程中发生的ClassNotFoundException异常。这个类实现了一个异常传播算法来决定哪些对象应该被认为是属于异常ClassNotFoundException的。</p>
<p>&emsp;&emsp;关于该表的使用场景，大致可分为如下几种：在反序列过程中，一个给定对象通过assign方法第一次被分配了一个句柄，此时该句柄属于“开放”状态。其中对其他句柄的异常状态的依赖关系可以通过调用markDependency方法注册，或者通过调用markException直接与句柄关联一个异常。如果当前句柄被指向了一个异常，那么根据异常传播机制和当前句柄有关联的其他对象都会被标记为异常态。一旦所有的异常信息/依赖都被注册了，那么当前句柄就可以通过close()被“关闭”了。通过finish()方法允许异常传播算法删除相关的依赖链，减少性能和内存损耗。</p>
<p>&emsp;&emsp;ValidationList是一个优先级队列集合，用来存储在对象引用图谱被完全反序列化恢复之后需要执行的回调方法。</p>
<p>&emsp;&emsp;GetFieldImpl实现了GetField（ObjectInputStream的静态抽象类）声明的所有方法。提供了从输入流中读取字段数据内容的方法。</p>
<p>&emsp;</p>
<h2 id="HandleTable"><a href="#HandleTable" class="headerlink" title="HandleTable"></a>HandleTable</h2><h3 id="Constructor-Summary"><a href="#Constructor-Summary" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="HandleTable-int-initialCapacity"><a href="#HandleTable-int-initialCapacity" class="headerlink" title="HandleTable(int initialCapacity)"></a>HandleTable(int initialCapacity)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HandleTable(<span class="keyword">int</span> initialCapacity) &#123;</span><br><span class="line">    status = <span class="keyword">new</span> <span class="keyword">byte</span>[initialCapacity];</span><br><span class="line">    entries = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    deps = <span class="keyword">new</span> HandleList[initialCapacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个句柄表。status维护了句柄-&gt;对象状态信息，entries维护了句柄-&gt;对象/异常实体信息（该过程依赖于status），deps维护了句柄-&gt;依赖的句柄列表信息。</p>
<h3 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="int-assign-Object-obj"><a href="#int-assign-Object-obj" class="headerlink" title="int assign(Object obj)"></a>int assign(Object obj)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">assign</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size &gt;= entries.length) &#123;</span><br><span class="line">        grow();</span><br><span class="line">    &#125;</span><br><span class="line">    status[size] = STATUS_UNKNOWN;</span><br><span class="line">    entries[size] = obj;</span><br><span class="line">    <span class="keyword">return</span> size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;分配下一个可用的句柄给入参对象obj，并返回分配的句柄信息。一旦对象彻底完成了反序列操作，句柄应该通过finish()方法置为“结束”状态。</p>
<p>&emsp;&emsp;如果数组空间不够，就执行扩容处理。</p>
<h4 id="private-void-grow"><a href="#private-void-grow" class="headerlink" title="private void grow()"></a>private void grow()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = (entries.length &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] newStatus = <span class="keyword">new</span> <span class="keyword">byte</span>[newCapacity];</span><br><span class="line">    Object[] newEntries = <span class="keyword">new</span> Object[newCapacity];</span><br><span class="line">    HandleList[] newDeps = <span class="keyword">new</span> HandleList[newCapacity];</span><br><span class="line"></span><br><span class="line">    System.arraycopy(status, <span class="number">0</span>, newStatus, <span class="number">0</span>, size);</span><br><span class="line">    System.arraycopy(entries, <span class="number">0</span>, newEntries, <span class="number">0</span>, size);</span><br><span class="line">    System.arraycopy(deps, <span class="number">0</span>, newDeps, <span class="number">0</span>, size);</span><br><span class="line"></span><br><span class="line">    status = newStatus;</span><br><span class="line">    entries = newEntries;</span><br><span class="line">    deps = newDeps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;按照当前数组容量的两倍进行扩容处理。</p>
<h4 id="void-markDependency-int-dependent-int-target"><a href="#void-markDependency-int-dependent-int-target" class="headerlink" title="void markDependency(int dependent, int target)"></a>void markDependency(int dependent, int target)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">markDependency</span><span class="params">(<span class="keyword">int</span> dependent, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dependent == NULL_HANDLE || target == NULL_HANDLE) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (status[dependent]) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> STATUS_UNKNOWN:</span><br><span class="line">            <span class="keyword">switch</span> (status[target]) &#123;</span><br><span class="line">                <span class="keyword">case</span> STATUS_OK:</span><br><span class="line">                    <span class="comment">// ignore dependencies on objs with no exception</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> STATUS_EXCEPTION:</span><br><span class="line">                    <span class="comment">// eagerly propagate exception</span></span><br><span class="line">                    markException(dependent,</span><br><span class="line">                                  (ClassNotFoundException) entries[target]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> STATUS_UNKNOWN:</span><br><span class="line">                    <span class="comment">// add to dependency list of target</span></span><br><span class="line">                    <span class="keyword">if</span> (deps[target] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        deps[target] = <span class="keyword">new</span> HandleList();</span><br><span class="line">                    &#125;</span><br><span class="line">                    deps[target].add(dependent);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// remember lowest unresolved target seen</span></span><br><span class="line">                    <span class="keyword">if</span> (lowDep &lt; <span class="number">0</span> || lowDep &gt; target) &#123;</span><br><span class="line">                        lowDep = target;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> STATUS_EXCEPTION:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;完成句柄依赖绑定。dependent句柄必须是处于“开启”状态的句柄，如果dependent句柄或target句柄都为空，那么直接返回不做处理。</p>
<p>&emsp;&emsp;如果dependent句柄处于“开启”状态（status = 2），那么检查target句柄。如果target的状态为OK，不做处理，如果状态为STATUS_EXCEPTION，那么需要将target句柄指向的异常传递给dependent句柄，调用的是<strong>markException(int handle, ClassNotFoundException ex)</strong>方法。如果状态为STATUS_UNKNOWN，那么就把dependent指向给target。</p>
<h4 id="void-markException-int-handle-ClassNotFoundException-ex"><a href="#void-markException-int-handle-ClassNotFoundException-ex" class="headerlink" title="void markException(int handle, ClassNotFoundException ex)"></a>void markException(int handle, ClassNotFoundException ex)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">markException</span><span class="params">(<span class="keyword">int</span> handle, ClassNotFoundException ex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (status[handle]) &#123;</span><br><span class="line">        <span class="keyword">case</span> STATUS_UNKNOWN:</span><br><span class="line">            status[handle] = STATUS_EXCEPTION;</span><br><span class="line">            entries[handle] = ex;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// propagate exception to dependents</span></span><br><span class="line">            HandleList dlist = deps[handle];</span><br><span class="line">            <span class="keyword">if</span> (dlist != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> ndeps = dlist.size();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ndeps; i++) &#123;</span><br><span class="line">                    markException(dlist.get(i), ex);</span><br><span class="line">                &#125;</span><br><span class="line">                deps[handle] = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> STATUS_EXCEPTION:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将ClassNotFoundException异常关联到当前活动句柄上。</p>
<h4 id="void-finish-int-handle"><a href="#void-finish-int-handle" class="headerlink" title="void finish(int handle)"></a>void finish(int handle)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finish</span><span class="params">(<span class="keyword">int</span> handle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> end;</span><br><span class="line">    <span class="keyword">if</span> (lowDep &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// no pending unknowns, only resolve current handle</span></span><br><span class="line">        end = handle + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lowDep &gt;= handle) &#123;</span><br><span class="line">        <span class="comment">// pending unknowns now clearable, resolve all upward handles</span></span><br><span class="line">        end = size;</span><br><span class="line">        lowDep = -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// unresolved backrefs present, can't resolve anything yet</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// change STATUS_UNKNOWN -&gt; STATUS_OK in selected span of handles</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = handle; i &lt; end; i++) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (status[i]) &#123;</span><br><span class="line">            <span class="keyword">case</span> STATUS_UNKNOWN:</span><br><span class="line">                status[i] = STATUS_OK;</span><br><span class="line">                deps[i] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> STATUS_OK:</span><br><span class="line">            <span class="keyword">case</span> STATUS_EXCEPTION:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将指定句柄标记为结束状态，标记完成后不会有新的依赖会指向到当前句柄上。</p>
<h4 id="void-setObject-int-handle-Object-obj"><a href="#void-setObject-int-handle-Object-obj" class="headerlink" title="void setObject(int handle, Object obj)"></a>void setObject(int handle, Object obj)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setObject</span><span class="params">(<span class="keyword">int</span> handle, Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (status[handle]) &#123;</span><br><span class="line">        <span class="keyword">case</span> STATUS_UNKNOWN:</span><br><span class="line">        <span class="keyword">case</span> STATUS_OK:</span><br><span class="line">            entries[handle] = obj;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> STATUS_EXCEPTION:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将handle句柄指向的对象替换为obj。</p>
<h4 id="Object-lookupObject-int-handle"><a href="#Object-lookupObject-int-handle" class="headerlink" title="Object lookupObject(int handle)"></a>Object lookupObject(int handle)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">lookupObject</span><span class="params">(<span class="keyword">int</span> handle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (handle != NULL_HANDLE &amp;&amp;</span><br><span class="line">            status[handle] != STATUS_EXCEPTION) ? entries[handle] : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;根据handle句柄查找对象。如果存在就从entries数组中返回对应的对象，否则返回null。</p>
<h4 id="ClassNotFoundException-lookupException-int-handle"><a href="#ClassNotFoundException-lookupException-int-handle" class="headerlink" title="ClassNotFoundException lookupException(int handle)"></a>ClassNotFoundException lookupException(int handle)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ClassNotFoundException <span class="title">lookupException</span><span class="params">(<span class="keyword">int</span> handle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (handle != NULL_HANDLE &amp;&amp;</span><br><span class="line">            status[handle] == STATUS_EXCEPTION) ?</span><br><span class="line">        (ClassNotFoundException) entries[handle] : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;根据handle句柄查找对应的异常。如果存在就从entries数组中返回对应的异常，否则返回null。</p>
<h4 id="void-clear"><a href="#void-clear" class="headerlink" title="void clear()"></a>void clear()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Arrays.fill(status, <span class="number">0</span>, size, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">    Arrays.fill(entries, <span class="number">0</span>, size, <span class="keyword">null</span>);</span><br><span class="line">    Arrays.fill(deps, <span class="number">0</span>, size, <span class="keyword">null</span>);</span><br><span class="line">    lowDep = -<span class="number">1</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将所有内容全部清空。</p>
<h4 id="int-size"><a href="#int-size" class="headerlink" title="int size()"></a>int size()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回表中存储注册的句柄数量。</p>
<h4 id="private-static-class-HandleList"><a href="#private-static-class-HandleList" class="headerlink" title="private static class HandleList"></a>private static class HandleList</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HandleList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] list = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandleList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> handle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size &gt;= list.length) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] newList = <span class="keyword">new</span> <span class="keyword">int</span>[list.length &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            System.arraycopy(list, <span class="number">0</span>, newList, <span class="number">0</span>, list.length);</span><br><span class="line">            list = newList;</span><br><span class="line">        &#125;</span><br><span class="line">        list[size++] = handle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;一个内部使用的长度可增长的句柄List集合实现。在HandleTable中用来维护句柄依赖信息。</p>
<p>&emsp;</p>
<h2 id="ValidationList"><a href="#ValidationList" class="headerlink" title="ValidationList"></a>ValidationList</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidationList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ObjectInputValidation obj;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> priority;</span><br><span class="line">        Callback next;</span><br><span class="line">        <span class="keyword">final</span> AccessControlContext acc;</span><br><span class="line"></span><br><span class="line">        Callback(ObjectInputValidation obj, <span class="keyword">int</span> priority, Callback next,</span><br><span class="line">                 AccessControlContext acc)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.obj = obj;</span><br><span class="line">            <span class="keyword">this</span>.priority = priority;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">            <span class="keyword">this</span>.acc = acc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** linked list of callbacks */</span></span><br><span class="line">    <span class="keyword">private</span> Callback list;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates new (empty) ValidationList.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ValidationList() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Registers callback.  Throws InvalidObjectException if callback</span></span><br><span class="line"><span class="comment">     * object is null.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(ObjectInputValidation obj, <span class="keyword">int</span> priority)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InvalidObjectException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"null callback"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Callback prev = <span class="keyword">null</span>, cur = list;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> &amp;&amp; priority &lt; cur.priority) &#123;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        AccessControlContext acc = AccessController.getContext();</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">            prev.next = <span class="keyword">new</span> Callback(obj, priority, cur, acc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            list = <span class="keyword">new</span> Callback(obj, priority, list, acc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Invokes all registered callbacks and clears the callback list.</span></span><br><span class="line"><span class="comment">     * Callbacks with higher priorities are called first; those with equal</span></span><br><span class="line"><span class="comment">     * priorities may be called in any order.  If any of the callbacks</span></span><br><span class="line"><span class="comment">     * throws an InvalidObjectException, the callback process is terminated</span></span><br><span class="line"><span class="comment">     * and the exception propagated upwards.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doCallbacks</span><span class="params">()</span> <span class="keyword">throws</span> InvalidObjectException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">                AccessController.doPrivileged(</span><br><span class="line">                    <span class="keyword">new</span> PrivilegedExceptionAction&lt;Void&gt;()</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> InvalidObjectException </span>&#123;</span><br><span class="line">                            list.obj.validateObject();</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, list.acc);</span><br><span class="line">                list = list.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (PrivilegedActionException ex) &#123;</span><br><span class="line">            list = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">throw</span> (InvalidObjectException) ex.getException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Resets the callback list to its initial (empty) state.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="ObjectInputStream-GetField"><a href="#ObjectInputStream-GetField" class="headerlink" title="ObjectInputStream.GetField"></a>ObjectInputStream.GetField</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GetField</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ObjectStreamClass <span class="title">getObjectStreamClass</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">defaulted</span><span class="params">(String name)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">get</span><span class="params">(String name, <span class="keyword">boolean</span> val)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">(String name, <span class="keyword">byte</span> val)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">char</span> <span class="title">get</span><span class="params">(String name, <span class="keyword">char</span> val)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">short</span> <span class="title">get</span><span class="params">(String name, <span class="keyword">short</span> val)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(String name, <span class="keyword">int</span> val)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">(String name, <span class="keyword">long</span> val)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">get</span><span class="params">(String name, <span class="keyword">float</span> val)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">get</span><span class="params">(String name, <span class="keyword">double</span> val)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title">get</span><span class="params">(String name, Object val)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="GetFieldImpl"><a href="#GetFieldImpl" class="headerlink" title="GetFieldImpl"></a>GetFieldImpl</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">GetFieldImpl</span> <span class="keyword">extends</span> <span class="title">GetField</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 带有被序列化了的字段内容的类描述符 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ObjectStreamClass desc;</span><br><span class="line">    <span class="comment">/** 基础数据类型字段 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] primVals;</span><br><span class="line">    <span class="comment">/** 对象类型字段 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] objVals;</span><br><span class="line">    <span class="comment">/** 字段值内容句柄 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] objHandles;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 构造方法，完成初始化操作 */</span></span><br><span class="line">    GetFieldImpl(ObjectStreamClass desc) &#123;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">        primVals = <span class="keyword">new</span> <span class="keyword">byte</span>[desc.getPrimDataSize()];</span><br><span class="line">        objVals = <span class="keyword">new</span> Object[desc.getNumObjFields()];</span><br><span class="line">        objHandles = <span class="keyword">new</span> <span class="keyword">int</span>[objVals.length];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ObjectStreamClass <span class="title">getObjectStreamClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 如果name字段的值是默认的，那么返回true */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">defaulted</span><span class="params">(String name)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (getFieldOffset(name, <span class="keyword">null</span>) &lt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 获取name字段的boolean值，如果没有值，那么就用val替换 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">get</span><span class="params">(String name, <span class="keyword">boolean</span> val)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> off = getFieldOffset(name, Boolean.TYPE);</span><br><span class="line">        <span class="keyword">return</span> (off &gt;= <span class="number">0</span>) ? Bits.getBoolean(primVals, off) : val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 获取name字段的byte值，如果没有值，那么就用val替换 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">(String name, <span class="keyword">byte</span> val)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> off = getFieldOffset(name, Byte.TYPE);</span><br><span class="line">        <span class="keyword">return</span> (off &gt;= <span class="number">0</span>) ? primVals[off] : val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 获取name字段的char值，如果没有值，那么就用val替换 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">get</span><span class="params">(String name, <span class="keyword">char</span> val)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> off = getFieldOffset(name, Character.TYPE);</span><br><span class="line">        <span class="keyword">return</span> (off &gt;= <span class="number">0</span>) ? Bits.getChar(primVals, off) : val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 获取name字段的short值，如果没有值，那么就用val替换 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">short</span> <span class="title">get</span><span class="params">(String name, <span class="keyword">short</span> val)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> off = getFieldOffset(name, Short.TYPE);</span><br><span class="line">        <span class="keyword">return</span> (off &gt;= <span class="number">0</span>) ? Bits.getShort(primVals, off) : val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 获取name字段的int值，如果没有值，那么就用val替换 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(String name, <span class="keyword">int</span> val)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> off = getFieldOffset(name, Integer.TYPE);</span><br><span class="line">        <span class="keyword">return</span> (off &gt;= <span class="number">0</span>) ? Bits.getInt(primVals, off) : val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 获取name字段的float值，如果没有值，那么就用val替换 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">get</span><span class="params">(String name, <span class="keyword">float</span> val)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> off = getFieldOffset(name, Float.TYPE);</span><br><span class="line">        <span class="keyword">return</span> (off &gt;= <span class="number">0</span>) ? Bits.getFloat(primVals, off) : val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 获取name字段的long值，如果没有值，那么就用val替换 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">(String name, <span class="keyword">long</span> val)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> off = getFieldOffset(name, Long.TYPE);</span><br><span class="line">        <span class="keyword">return</span> (off &gt;= <span class="number">0</span>) ? Bits.getLong(primVals, off) : val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 获取name字段的double值，如果没有值，那么就用val替换 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">get</span><span class="params">(String name, <span class="keyword">double</span> val)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> off = getFieldOffset(name, Double.TYPE);</span><br><span class="line">        <span class="keyword">return</span> (off &gt;= <span class="number">0</span>) ? Bits.getDouble(primVals, off) : val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 获取name字段的Object值，如果没有值，那么就用val替换 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String name, Object val)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> off = getFieldOffset(name, Object.class);</span><br><span class="line">        <span class="keyword">if</span> (off &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> objHandle = objHandles[off];</span><br><span class="line">            handles.markDependency(passHandle, objHandle);</span><br><span class="line">            <span class="keyword">return</span> (handles.lookupException(objHandle) == <span class="keyword">null</span>) ?</span><br><span class="line">                objVals[off] : <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 从流里读取基本数据类型和对象类型的字段值内容 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">readFields</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        bin.readFully(primVals, <span class="number">0</span>, primVals.length, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> oldHandle = passHandle;</span><br><span class="line">        ObjectStreamField[] fields = desc.getFields(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">int</span> numPrimFields = fields.length - objVals.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objVals.length; i++) &#123;</span><br><span class="line">            objVals[i] = readObject0(fields[numPrimFields + i].isUnshared());</span><br><span class="line">            objHandles[i] = passHandle;</span><br><span class="line">        &#125;</span><br><span class="line">        passHandle = oldHandle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 得到指定类型和名字的字段的偏移量 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getFieldOffset</span><span class="params">(String name, Class type)</span> </span>&#123;</span><br><span class="line">        ObjectStreamField field = desc.getField(name, type);</span><br><span class="line">        <span class="keyword">if</span> (field != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> field.getOffset();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (desc.getLocalDesc().getField(name, type) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"no such field "</span> + name +</span><br><span class="line">                                               <span class="string">" with type "</span> + type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li>NIL</li>
</ol>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>NIL</li>
</ol>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java I/O 26 - ObjectOutputStream</title>
    <url>/2018/java-ObjectOutputStream.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java I/O 10 - PipedInputStream &amp; PipedOutputStream</title>
    <url>/2018/java-PipedInputStream-PipedOutputStream.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;关于<em> <strong>java.io.PipedInputStream</strong> </em> 和 <em> <strong>java.io.PipedOutputStream</strong> </em>的部分笔记，这两个类需要在两个不同的线程中同时使用来完成数据的读取和写入操作。本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;PipedInputStream和PipedOutputStream两个类需要共同使用才能完成数据的读写操作，且输入流和输出流需要在不同的线程中执行，否则容易发生死锁现象。在PipedInputStream中维护了一个缓冲区数组，PipedOutputStream的写数据操作实际上调用的是PipedInputStream的方法向缓冲区数组中写入数据，PipedInputStream中的read()方法则从缓冲区数组中读取所需要的数据。PipedInputStream中的缓冲区数组按照环形数组的设计来读取和写入，根据读取位置等于写入位置来判断缓冲区数组中是否还有未读取的数据。</p>
<p>&emsp;</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PipedInputStream</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.io.InputStream</span><br><span class="line">    --java.io.PipedInputStream</span><br><span class="line"></span><br><span class="line"><span class="comment">// PipedOutputStream</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.io.InputStream</span><br><span class="line">    --java.io.PipedOutputStream</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类名</th>
<th style="text-align:center">实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PipedInputStream</td>
<td style="text-align:center">Closeable, AutoCloseable</td>
</tr>
<tr>
<td style="text-align:center">PipedOutputStream</td>
<td style="text-align:center">Closeable, Flushable, AutoCloseable</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="PipedInputStream"><a href="#PipedInputStream" class="headerlink" title="PipedInputStream"></a>PipedInputStream</h2><h3 id="Constructor-Summary"><a href="#Constructor-Summary" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="public-PipedInputStream-PipedOutputStream-src-int-pipeSize"><a href="#public-PipedInputStream-PipedOutputStream-src-int-pipeSize" class="headerlink" title="public PipedInputStream(PipedOutputStream src, int pipeSize)"></a>public PipedInputStream(PipedOutputStream src, int pipeSize)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PipedInputStream</span><span class="params">(PipedOutputStream src)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(src, DEFAULT_PIPE_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PipedInputStream</span><span class="params">(PipedOutputStream src, <span class="keyword">int</span> pipeSize)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    initPipe(pipeSize);</span><br><span class="line">    connect(src);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;参数是一个PipedOutputStream的构造函数，在初始化过程中完成了两件事情：初始化缓冲区数组容量大小和建立一个管道输入流和输出流之间的连接，最后会将输入流的<strong>connected</strong>字段标识为true。</p>
<h4 id="public-PipedInputStream-int-pipeSize"><a href="#public-PipedInputStream-int-pipeSize" class="headerlink" title="public PipedInputStream(int pipeSize)"></a>public PipedInputStream(int pipeSize)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PipedInputStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    initPipe(DEFAULT_PIPE_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PipedInputStream</span><span class="params">(<span class="keyword">int</span> pipeSize)</span> </span>&#123;</span><br><span class="line">    initPipe(pipeSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果是通过不依赖PipedOutputStream的方式初始化实例，那么在初始化过程中就只负责初始化缓冲区数组容量大小这一件事情了。默认大小是1024。</p>
<h3 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="private-void-initPipe-int-pipeSize"><a href="#private-void-initPipe-int-pipeSize" class="headerlink" title="private void initPipe(int pipeSize)"></a>private void initPipe(int pipeSize)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initPipe</span><span class="params">(<span class="keyword">int</span> pipeSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pipeSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Pipe Size &lt;= 0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[pipeSize];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化缓冲区数组容量大小。</p>
<h4 id="public-void-connect-PipedOutputStream-src"><a href="#public-void-connect-PipedOutputStream-src" class="headerlink" title="public void connect(PipedOutputStream src)"></a>public void connect(PipedOutputStream src)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(PipedOutputStream src)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    src.connect(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里实际上是通过管道输出流完成连接工作的。在建立连接的过程中，把输入流的写入标志位和读取标志位都归零（in = -1，out = 0），同时将输入流的connected字段标识为true完成连接工作。</p>
<h4 id="protected-synchronized-void-receive-int-b"><a href="#protected-synchronized-void-receive-int-b" class="headerlink" title="protected synchronized void receive(int b)"></a>protected synchronized void receive(int b)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    checkStateForReceive();</span><br><span class="line">    writeSide = Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> (in == out)</span><br><span class="line">        awaitSpace();</span><br><span class="line">    <span class="keyword">if</span> (in &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        in = <span class="number">0</span>;</span><br><span class="line">        out = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer[in++] = (<span class="keyword">byte</span>)(b &amp; <span class="number">0xFF</span>);</span><br><span class="line">    <span class="keyword">if</span> (in &gt;= buffer.length) &#123;</span><br><span class="line">        in = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;接收一个字节的数据，并将之保存在输入流的缓冲区数组中。第2行代码用来检查当前管道的连接状态，需要保证管道的连通性且数据读取是正常的。第3行代码会把当前执行的现成切换到写线程并获取该线程。由于管道输入流中的缓冲区数组被设计成了环形数组，所以在写入数据的下标值逐渐达到读取数据的下标值时，认为缓冲区数组已经被待读取的数据填充完全，此时缓冲区数组中无法容纳新的数据。所以第4 ~ 6行代码表示如果当前缓冲区数组中已经填满了未读取的数据，那么就唤醒读线程来读取缓冲区数组中的数据内容。第6 ~ 9行代码如果发现数据写入位置<strong>in</strong>已经被归零了，那么会将<strong>in</strong>和<strong>out</strong>都归零。第10行代码用来向缓冲区数组中写入一个byte值的数据内容。第11 ~ 13行代码则在in到达缓冲区数组尾部时回到数组首部继续存储新数据（即环形设计）。</p>
<h4 id="synchronized-void-receive-byte-b-int-off-int-len"><a href="#synchronized-void-receive-byte-b-int-off-int-len" class="headerlink" title="synchronized void receive(byte b[], int off, int len)"></a>synchronized void receive(byte b[], int off, int len)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span>  <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    checkStateForReceive();</span><br><span class="line">    writeSide = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> bytesToTransfer = len;</span><br><span class="line">    <span class="keyword">while</span> (bytesToTransfer &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (in == out)</span><br><span class="line">            awaitSpace();</span><br><span class="line">        <span class="keyword">int</span> nextTransferAmount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (out &lt; in) &#123;</span><br><span class="line">            nextTransferAmount = buffer.length - in;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (in &lt; out) &#123;</span><br><span class="line">            <span class="keyword">if</span> (in == -<span class="number">1</span>) &#123;</span><br><span class="line">                in = out = <span class="number">0</span>;</span><br><span class="line">                nextTransferAmount = buffer.length - in;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nextTransferAmount = out - in;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nextTransferAmount &gt; bytesToTransfer)</span><br><span class="line">            nextTransferAmount = bytesToTransfer;</span><br><span class="line">        <span class="keyword">assert</span>(nextTransferAmount &gt; <span class="number">0</span>);</span><br><span class="line">        System.arraycopy(b, off, buffer, in, nextTransferAmount);</span><br><span class="line">        bytesToTransfer -= nextTransferAmount;</span><br><span class="line">        off += nextTransferAmount;</span><br><span class="line">        in += nextTransferAmount;</span><br><span class="line">        <span class="keyword">if</span> (in &gt;= buffer.length) &#123;</span><br><span class="line">            in = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;接收入参数组b的数据，并将之保存在输入流的缓冲区数组中。第2行代码用来检查当前管道的连接状态，需要保证管道的连通性且数据读取是正常的。第3行代码会把当前执行的现成切换到写线程并获取该线程。第5 ~ 29行代码则完成数据的写入操作。第6 ~ 7行代码处理缓冲区数组被写满的情况，此时会暂停写线程并切换到读线程读取缓冲区数组中的数据，之后缓冲区数组就会有新的空间来容纳新数据内容。第9 ~ 10行代码则计算图1情境中可用的可以容纳新数据的缓冲区空间大小。</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1540899912/BlogImages/PipedInputStream-PipedOutputStream/pipedInputStream_receive_scene-1.png" alt></p>
<div align="center">
<div align="center">图 - 1</div>
&emsp;
</div>

<p>第11 ~ 18行代码则计算读取位置在写入位置前面的情境。第12 ~ 15行代码说明在之前的某一步操作中写入和读取位置都被做了归零处理，所以整个缓冲区数组都可以用来容纳新数据。第15 ~ 17行代码则计算图2情境中可以容纳新数据的缓冲区空间大小。</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1540899912/BlogImages/PipedInputStream-PipedOutputStream/pipedInputStream_receive_scene-2.png" alt></p>
<div align="center">
<div align="center">图 - 2</div>
&emsp;
</div>

<p>第19 ~ 20行代码判断当前缓冲区可用空间和入参长度的大小关系，如果可用空间大于入参长度，那么当前入参数据都可以被保存到缓冲区数组中。第22 ~ 25行代码完成数据从入参数组到缓冲区数组之间的复制和结果计算过程。如果in到达了缓冲区数组尾部，那么in会被调整到缓冲区数组头部继续写入新数据。</p>
<h4 id="synchronized-void-receivedLast"><a href="#synchronized-void-receivedLast" class="headerlink" title="synchronized void receivedLast()"></a>synchronized void receivedLast()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">receivedLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    closedByWriter = <span class="keyword">true</span>;</span><br><span class="line">    notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;数据写入完成，唤醒读线程开始读取缓冲区数组中的数据。</p>
<h4 id="private-void-checkStateForReceive"><a href="#private-void-checkStateForReceive" class="headerlink" title="private void checkStateForReceive()"></a>private void checkStateForReceive()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkStateForReceive</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!connected) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Pipe not connected"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (closedByWriter || closedByReader) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Pipe closed"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readSide != <span class="keyword">null</span> &amp;&amp; !readSide.isAlive()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Read end dead"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;检查状态，判断当前管道是否处于连接状态、数据读取侧是否正常。</p>
<h4 id="private-void-awaitSpace"><a href="#private-void-awaitSpace" class="headerlink" title="private void awaitSpace()"></a>private void awaitSpace()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">awaitSpace</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (in == out) &#123;</span><br><span class="line">        checkStateForReceive();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* full: kick any waiting readers */</span></span><br><span class="line">        notifyAll();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.io.InterruptedIOException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;首先检查状态，然后唤醒所有线程。因为管道输入流和管道输出流的使用场景中大多数时候只有两个线程，一个负责写一个负责读。所以如果当前线程是读线程，那么会唤醒写线程，同时将当前（读）线程置于阻塞状态，释放资源，由写线程获得执行机会开始向缓冲区数组中写入新数据，反之亦然。</p>
<h4 id="public-synchronized-int-read"><a href="#public-synchronized-int-read" class="headerlink" title="public synchronized int read()"></a>public synchronized int read()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span>  <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!connected) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Pipe not connected"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (closedByReader) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Pipe closed"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (writeSide != <span class="keyword">null</span> &amp;&amp; !writeSide.isAlive()</span><br><span class="line">               &amp;&amp; !closedByWriter &amp;&amp; (in &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Write end dead"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    readSide = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> trials = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (in &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (closedByWriter) &#123;</span><br><span class="line">            <span class="comment">/* closed by writer, return EOF */</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((writeSide != <span class="keyword">null</span>) &amp;&amp; (!writeSide.isAlive()) &amp;&amp; (--trials &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Pipe broken"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* might be a writer waiting */</span></span><br><span class="line">        notifyAll();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.io.InterruptedIOException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = buffer[out++] &amp; <span class="number">0xFF</span>;</span><br><span class="line">    <span class="keyword">if</span> (out &gt;= buffer.length) &#123;</span><br><span class="line">        out = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (in == out) &#123;</span><br><span class="line">        <span class="comment">/* now empty */</span></span><br><span class="line">        in = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从缓冲区数组中读取一个字节的新数据。第2 ~ 10行代码用来完成管道的状态校验（管道是否连通、数据读取端是否尚未关闭、缓冲区数组中无内容时数据写入端是否开启）。第11行代码将当前执行线程切换到读线程。第12 ~ 28行代码用来在缓冲区数组中无内容时启用写线程来向缓冲区数组中写入新内容。第14 ~ 17行代码如果数据写入端被关闭了，且缓冲区数组中没有待读取的数据，那么就返回<strong>-1</strong>表示数据读取已经结束。第18 ~ 20行代码则检查写线程的状态，这里做了重复检查，重复两次得到最终判定结果。第22行代码用来唤醒写线程并准备向缓冲区数组中写入新数据。第24行代码则暂停当前读线程，使得写线程获取资源开始工作。第29行代码获取一个字节的数据并返回。第30 ~ 32行代码如果已经读到了缓冲区数组的最后一个位置，那么将out移到缓冲区数组首部继续读取新数据。第33 ~ 36行代码如果out到达了in的位置，那么缓冲区数组中已经不存在任何待读取的数据了，那么就将in和out全部归零。</p>
<h4 id="public-synchronized-int-read-byte-b-int-off-int-len"><a href="#public-synchronized-int-read-byte-b-int-off-int-len" class="headerlink" title="public synchronized int read(byte b[], int off, int len)"></a>public synchronized int read(byte b[], int off, int len)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span>  <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (off &lt; <span class="number">0</span> || len &lt; <span class="number">0</span> || len &gt; b.length - off) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* possibly wait on the first character */</span></span><br><span class="line">    <span class="keyword">int</span> c = read();</span><br><span class="line">    <span class="keyword">if</span> (c &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    b[off] = (<span class="keyword">byte</span>) c;</span><br><span class="line">    <span class="keyword">int</span> rlen = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((in &gt;= <span class="number">0</span>) &amp;&amp; (len &gt; <span class="number">1</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> available;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (in &gt; out) &#123;</span><br><span class="line">            available = Math.min((buffer.length - out), (in - out));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            available = buffer.length - out;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// A byte is read beforehand outside the loop</span></span><br><span class="line">        <span class="keyword">if</span> (available &gt; (len - <span class="number">1</span>)) &#123;</span><br><span class="line">            available = len - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.arraycopy(buffer, out, b, off + rlen, available);</span><br><span class="line">        out += available;</span><br><span class="line">        rlen += available;</span><br><span class="line">        len -= available;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (out &gt;= buffer.length) &#123;</span><br><span class="line">            out = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (in == out) &#123;</span><br><span class="line">            <span class="comment">/* now empty */</span></span><br><span class="line">            in = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rlen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从缓冲区数组中读出长度为len个字节的内容到数组b中。第2 ~ 8行代码用来完成入参的有效性校验，防止越界。第11 ~ 16行代码“尝试性”的从缓冲区数组中读取一个字节的内容。如果当前缓冲区数组中无内容，那么就会切换到写线程向缓冲区数组中填充新内容，如果成功的读取到了一个字节，那么就将读取到的内容保存到数组b中。第19 ~ 30行代码用来确定最终需要读取的字节数。其中，第19 ~ 26行代码用来确定缓冲区数组中剩余的未读的内容长度，而第28 ~ 30行代码则用来比较缓冲区数组中剩余的未读内容长度和调用请求的长度之间的大小关系并确定最终的需要读取的字节数。第31行代码完成数据在缓冲区数组和入参b之前的复制。第32 ~ 35行代码则维护入参需求长度len、实际读取长度rlen和缓冲区数组下一个读取位置out的值。第36 ~ 38行代码执行时，如果out已经到达缓冲区数组尾部，那么将out置于缓冲区数组头部，循环读取数据。第39 ~ 42行代码如果out已经移动到了in的位置，那么说明缓冲区数组中已经没有未读取的数据了，那么就将写入位置in重新归零。最后返回实际读取的长度rlen。</p>
<h4 id="public-synchronized-int-available"><a href="#public-synchronized-int-available" class="headerlink" title="public synchronized int available()"></a>public synchronized int available()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">available</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(in &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(in == out)</span><br><span class="line">        <span class="keyword">return</span> buffer.length;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (in &gt; out)</span><br><span class="line">        <span class="keyword">return</span> in - out;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> in + buffer.length - out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;计算当前缓冲区数组中剩余的未读取的字节内容数。第2 ~ 3行代码对应图3中的场景(1)，第 4 ~ 5行代码对应场景(2)， 第6 ~7 行代码对应场景(3)，第8 ~ 9 行代码对应场景(4)。<br><img src="https://res.cloudinary.com/jknight/image/upload/v1540899913/BlogImages/PipedInputStream-PipedOutputStream/pipedInputStream_receive_scene-3.png" alt></p>
<div align="center">
<div align="center">图 - 3</div>
&emsp;
</div>

<h4 id="public-void-close"><a href="#public-void-close" class="headerlink" title="public void close()"></a>public void close()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span>  <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    closedByReader = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        in = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;关闭当前输入流。</p>
<p>&emsp;</p>
<h2 id="PipedOutputStream"><a href="#PipedOutputStream" class="headerlink" title="PipedOutputStream"></a>PipedOutputStream</h2><h3 id="Constructor-Summary-1"><a href="#Constructor-Summary-1" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="public-PipedOutputStream-PipedInputStream-snk"><a href="#public-PipedOutputStream-PipedInputStream-snk" class="headerlink" title="public PipedOutputStream(PipedInputStream snk)"></a>public PipedOutputStream(PipedInputStream snk)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PipedOutputStream</span><span class="params">(PipedInputStream snk)</span>  <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    connect(snk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个输出流并完成输入流和输出流的连接过程。在connect()方法中，会把缓冲区数组的in和out全部归零，同时将输入流标记为连接状态（connect = true）。</p>
<h3 id="部分方法-1"><a href="#部分方法-1" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="public-synchronized-void-connect-PipedInputStream-snk"><a href="#public-synchronized-void-connect-PipedInputStream-snk" class="headerlink" title="public synchronized void connect(PipedInputStream snk)"></a>public synchronized void connect(PipedInputStream snk)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(PipedInputStream snk)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (snk == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sink != <span class="keyword">null</span> || snk.connected) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Already connected"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sink = snk;</span><br><span class="line">    snk.in = -<span class="number">1</span>;</span><br><span class="line">    snk.out = <span class="number">0</span>;</span><br><span class="line">    snk.connected = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;完成输入流和输出流的连接过程。</p>
<h4 id="public-void-write-int-b"><a href="#public-void-write-int-b" class="headerlink" title="public void write(int b)"></a>public void write(int b)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span>  <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sink == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Pipe not connected"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sink.receive(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;向缓冲区数组中写入一个字节的数据。实际上是通过PipedInputStream的receive()方法来完成的。</p>
<h4 id="public-void-write-byte-b-int-off-int-len"><a href="#public-void-write-byte-b-int-off-int-len" class="headerlink" title="public void write(byte b[], int off, int len)"></a>public void write(byte b[], int off, int len)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sink == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Pipe not connected"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((off &lt; <span class="number">0</span>) || (off &gt; b.length) || (len &lt; <span class="number">0</span>) ||</span><br><span class="line">               ((off + len) &gt; b.length) || ((off + len) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sink.receive(b, off, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;向缓冲区数组中将入参数组b的数据写入到缓冲区数组中。在方法刚开始便对入参数组b、偏移量off和长度len等参数做了有效性校验，在校验通过后，调用PipedInputStream的receive(b, off, len)方法来完成数据的写入和保存。</p>
<h4 id="public-synchronized-void-flush"><a href="#public-synchronized-void-flush" class="headerlink" title="public synchronized void flush()"></a>public synchronized void flush()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sink != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sink) &#123;</span><br><span class="line">            sink.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="public-void-close-1"><a href="#public-void-close-1" class="headerlink" title="public void close()"></a>public void close()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span>  <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sink != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sink.receivedLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li><p>管道输入(出)流的典型应用场景：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        PipedOutputStream pipedOutputStream = <span class="keyword">new</span> PipedOutputStream();</span><br><span class="line">        PipedInputStream pipedInputStream = <span class="keyword">new</span> PipedInputStream(pipedOutputStream, <span class="number">1</span>);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String data = <span class="string">"1234567asfa890"</span>;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        pipedOutputStream.write(data.getBytes());</span><br><span class="line">                        pipedOutputStream.flush();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">// print error logs</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        pipedInputStream.read(data);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">// print error logs</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// print error logs</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>ReggieDing. <a href="https://zhuanlan.zhihu.com/p/31352578" target="_blank" rel="noopener">PipedInputStream和PipedOutStream记录</a> [E]</li>
<li>Asslstne. <a href="https://www.jianshu.com/p/8aefeb3a12cf" target="_blank" rel="noopener">源码分析: PipedInputStream和PipedOutputStream</a> [E]<br>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java I/O 17 - PipedReader &amp; PipedWriter</title>
    <url>/2018/java-PipedReader-PipedWriter.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;关于<em> <strong>java.io.PipedReader</strong> </em> 和 <em> <strong>java.io.PipedWriter</strong> </em>的部分笔记，用来完成不同线程间的数据传送和通信。读写操作分别在不同的线程中向缓冲区buffer中写入数据、读取数据。本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;PipedReader和PipedWriter两个类可以同时使用用来满足线程间的数据传送和通信需求。读和写操作各自使用一个线程，向缓冲区buffer中写入字符内容，然后唤醒读线程读取内容，然后再唤醒写线程继续写入字符内容，然后再唤醒读线程读取内容，依次直到满足某个条件读取/写入操作结束。</p>
<p>&emsp;</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PipedReader</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.io.Reader</span><br><span class="line">    --java.io.PipedReader</span><br><span class="line"></span><br><span class="line"><span class="comment">// PipedWriter</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.io.Writer</span><br><span class="line">    --java.io.PipedWriter</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类名</th>
<th style="text-align:center">实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PipedReader</td>
<td style="text-align:center">Closeable, AutoCloseable,Readable</td>
</tr>
<tr>
<td style="text-align:center">PipedWriter</td>
<td style="text-align:center">Closeable, Flushable, AutoCloseable, Appendable</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="PipedReader"><a href="#PipedReader" class="headerlink" title="PipedReader"></a>PipedReader</h2><h3 id="Constructor-Summary"><a href="#Constructor-Summary" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="public-StringReader-String-s"><a href="#public-StringReader-String-s" class="headerlink" title="public StringReader(String s)"></a>public StringReader(String s)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PipedReader</span><span class="params">(PipedWriter src)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(src, DEFAULT_PIPE_SIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个管道输入流。底层调用的是方法public PipedReader(PipedWriter src, int pipeSize)，在初始化底层缓冲区buffer时，传入的是默认长度1024。</p>
<h4 id="public-PipedReader-PipedWriter-src-int-pipeSize"><a href="#public-PipedReader-PipedWriter-src-int-pipeSize" class="headerlink" title="public PipedReader(PipedWriter src, int pipeSize)"></a>public PipedReader(PipedWriter src, int pipeSize)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PipedReader</span><span class="params">(PipedWriter src, <span class="keyword">int</span> pipeSize)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    initPipe(pipeSize);</span><br><span class="line">    connect(src);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个管道输入流。首先初始化管道缓冲区buffer，在初始化完成后，调用方法connect(PipedWriter src)完成输入、输出管道的互联。</p>
<h4 id="public-PipedReader"><a href="#public-PipedReader" class="headerlink" title="public PipedReader()"></a>public PipedReader()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PipedReader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    initPipe(DEFAULT_PIPE_SIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个管道输入流。由于入参中没有管道输出流，所以只需要初始化缓冲区buffer即可，buffer的长度为默认1024。</p>
<h4 id="public-PipedReader-int-pipeSize"><a href="#public-PipedReader-int-pipeSize" class="headerlink" title="public PipedReader(int pipeSize)"></a>public PipedReader(int pipeSize)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PipedReader</span><span class="params">(<span class="keyword">int</span> pipeSize)</span> </span>&#123;</span><br><span class="line">    initPipe(pipeSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个管道输入流。由于入参中没有管道输出流，所以只需要初始化缓冲区buffer即可，buffer的长度为入参pipeSize指定的长度。</p>
<h4 id="private-void-initPipe-int-pipeSize"><a href="#private-void-initPipe-int-pipeSize" class="headerlink" title="private void initPipe(int pipeSize)"></a>private void initPipe(int pipeSize)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initPipe</span><span class="params">(<span class="keyword">int</span> pipeSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pipeSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Pipe size &lt;= 0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    buffer = <span class="keyword">new</span> <span class="keyword">char</span>[pipeSize];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化管道缓冲区buffer，长度由参数pipeSize确定。</p>
<h3 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="public-void-connect-PipedWriter-src"><a href="#public-void-connect-PipedWriter-src" class="headerlink" title="public void connect(PipedWriter src)"></a>public void connect(PipedWriter src)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(PipedWriter src)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    src.connect(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;建立一个reader端到writer端之间的管道连接。如果当前reader未曾与其他管道连接，那么该方法会建立一个有效的连接，否则会抛出一个IOException异常。具体实现在<a href="#publicSyncVoidConnect">PipedWriter.connect(PipedReader snk)</a>中。</p>
<h4 id="synchronized-void-receive-int-c"><a href="#synchronized-void-receive-int-c" class="headerlink" title="synchronized void receive(int c)"></a><span id="SyncVoidReceiveIC">synchronized void receive(int c)</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(<span class="keyword">int</span> c)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!connected) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Pipe not connected"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (closedByWriter || closedByReader) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Pipe closed"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readSide != <span class="keyword">null</span> &amp;&amp; !readSide.isAlive()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Read end dead"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    writeSide = Thread.currentThread();</span><br><span class="line">    <span class="keyword">while</span> (in == out) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((readSide != <span class="keyword">null</span>) &amp;&amp; !readSide.isAlive()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Pipe broken"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* full: kick any waiting readers */</span></span><br><span class="line">        notifyAll();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.io.InterruptedIOException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (in &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        in = <span class="number">0</span>;</span><br><span class="line">        out = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer[in++] = (<span class="keyword">char</span>) c;</span><br><span class="line">    <span class="keyword">if</span> (in &gt;= buffer.length) &#123;</span><br><span class="line">        in = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;接收一个字符数据并存入到底层缓冲区buffer中。第2 ~ 3行代码判断当前输入/输出管道是否正在连接，第4 ~ 5行代码判断输入/输出管道是否关闭，第6 ~ 7行代码判断输出管道(PipedReader)是否正常。</p>
<p>&emsp;&emsp;第10行代码将当前线程切换到输入线程（写线程），如果当前缓冲区buffer已满（in == out），那么唤醒读线程（输出线程），暂停写线程，让读线程运行并读取缓冲区buffer中的内容并释放缓冲区buffer空间。第23 ~ 26行代码中则将buffer清空，所有读写标记位都归零。第27行代码将入参字符写入到缓冲区buffer中。第28 ~ 30行代码，如果写标记到达缓冲区buffer尾部，那么将其置于buffer头部，继续写数据。</p>
<h4 id="synchronized-void-receive-char-c-int-off-int-len"><a href="#synchronized-void-receive-char-c-int-off-int-len" class="headerlink" title="synchronized void receive(char c[], int off, int len)"></a><span id="SyncVoidReceiveCCIFIL">synchronized void receive(char c[], int off, int len)</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(<span class="keyword">char</span> c[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span>  <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (--len &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        receive(c[off++]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;接收一个字符数组的数据并存入到底层缓冲区buffer中。底层调用方法是receive(int c)。</p>
<h4 id="synchronized-void-receivedLast"><a href="#synchronized-void-receivedLast" class="headerlink" title="synchronized void receivedLast()"></a>synchronized void receivedLast()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">receivedLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    closedByWriter = <span class="keyword">true</span>;</span><br><span class="line">    notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通知所有等待的线程（读线程）所有内容都已经写入到缓冲区buffer中，同时关闭输入线程（写线程），即PipedWriter。</p>
<h4 id="public-synchronized-int-read"><a href="#public-synchronized-int-read" class="headerlink" title="public synchronized int read()"></a>public synchronized int read()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span>  <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!connected) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Pipe not connected"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (closedByReader) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Pipe closed"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (writeSide != <span class="keyword">null</span> &amp;&amp; !writeSide.isAlive()</span><br><span class="line">               &amp;&amp; !closedByWriter &amp;&amp; (in &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Write end dead"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    readSide = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> trials = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (in &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (closedByWriter) &#123;</span><br><span class="line">            <span class="comment">/* closed by writer, return EOF */</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((writeSide != <span class="keyword">null</span>) &amp;&amp; (!writeSide.isAlive()) &amp;&amp; (--trials &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Pipe broken"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* might be a writer waiting */</span></span><br><span class="line">        notifyAll();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.io.InterruptedIOException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = buffer[out++];</span><br><span class="line">    <span class="keyword">if</span> (out &gt;= buffer.length) &#123;</span><br><span class="line">        out = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (in == out) &#123;</span><br><span class="line">        <span class="comment">/* now empty */</span></span><br><span class="line">        in = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;读一个字符内容并返回。第2 ~ 3行代码判断当前输入/输出管道是否正在连接，第4 ~ 5行代码判断输出管道是否关闭，第6 ~ 9行代码判断输入管道(PipedWriter)是否正常。</p>
<p>&emsp;&emsp;第11行代码将当前线程切换到读线程。如果缓冲区buffer为空，那么检查写线程是否可用，如果写线程关闭则返回-1标识已读取到文件结束位置。重试最多两次检查写线程是否正常可用，唤醒所有线程，同时暂停当前读线程以便让写线程工作向缓冲区buffer中写入新的字符数据内容。</p>
<p>&emsp;&emsp;之后读取新的内容并返回给方法调用方，如果已经读到了buffer尾部，那么将回到头部继续读取。如果已经读完了缓冲区中的所有内容，那么将in标记为-1标识当前缓冲区buffer中已经没有未读取的数据了。</p>
<h4 id="public-synchronized-int-read-char-cbuf-int-off-int-len"><a href="#public-synchronized-int-read-char-cbuf-int-off-int-len" class="headerlink" title="public synchronized int read(char cbuf[], int off, int len)"></a>public synchronized int read(char cbuf[], int off, int len)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> cbuf[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span>  <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!connected) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Pipe not connected"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (closedByReader) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Pipe closed"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (writeSide != <span class="keyword">null</span> &amp;&amp; !writeSide.isAlive()</span><br><span class="line">               &amp;&amp; !closedByWriter &amp;&amp; (in &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Write end dead"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((off &lt; <span class="number">0</span>) || (off &gt; cbuf.length) || (len &lt; <span class="number">0</span>) ||</span><br><span class="line">        ((off + len) &gt; cbuf.length) || ((off + len) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* possibly wait on the first character */</span></span><br><span class="line">    <span class="keyword">int</span> c = read();</span><br><span class="line">    <span class="keyword">if</span> (c &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cbuf[off] =  (<span class="keyword">char</span>)c;</span><br><span class="line">    <span class="keyword">int</span> rlen = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((in &gt;= <span class="number">0</span>) &amp;&amp; (--len &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">        cbuf[off + rlen] = buffer[out++];</span><br><span class="line">        rlen++;</span><br><span class="line">        <span class="keyword">if</span> (out &gt;= buffer.length) &#123;</span><br><span class="line">            out = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (in == out) &#123;</span><br><span class="line">            <span class="comment">/* now empty */</span></span><br><span class="line">            in = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rlen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;读取字符内容并保存到入参字符数组cbuf中。第2 ~ 3行代码判断当前输入/输出管道是否正在连接，第4 ~ 5行代码判断输出管道是否关闭，第6 ~ 9行代码判断输入管道(PipedWriter)是否正常。第11 ~ 16行代码完成入参的有效性校验，避免发生越界溢出。</p>
<p>&emsp;&emsp;第19 ~ 22行代码中尝试性的从缓冲区buffer中读取一个字符内容，并判断是否为EOF状态。这个操作个人猜测是用来检查缓冲区buffer中是否有可供读取的内容的，如果没有可读取的字符，那么会直接切换到写线程向缓冲区buffer中写入新的字符数据。第23 ~ 35行代码则从缓冲区buffer中依次读取字符内容，并将读取到的内容保存到cbuf中。最后返回实际读取的字符长度。</p>
<h4 id="public-synchronized-boolean-ready"><a href="#public-synchronized-boolean-ready" class="headerlink" title="public synchronized boolean ready()"></a>public synchronized boolean ready()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">ready</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!connected) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Pipe not connected"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (closedByReader) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Pipe closed"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (writeSide != <span class="keyword">null</span> &amp;&amp; !writeSide.isAlive()</span><br><span class="line">               &amp;&amp; !closedByWriter &amp;&amp; (in &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Write end dead"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (in &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通知方法调用方是否可以通过read方法读取字符数据。第2 ~ 3行代码判断当前输入/输出管道是否正在连接，第4 ~ 5行代码判断输出管道是否关闭，第6 ~ 9行代码判断输入管道(PipedWriter)是否正常。如果in &gt;= 0，那么则表示缓冲区buffer中已有未读取的字符内容，否则缓冲区buffer为空。</p>
<h4 id="public-void-close"><a href="#public-void-close" class="headerlink" title="public void close()"></a>public void close()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span>  <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    in = -<span class="number">1</span>;</span><br><span class="line">    closedByReader = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;关闭当前输出管道。</p>
<p>&emsp;</p>
<h2 id="PipedWriter"><a href="#PipedWriter" class="headerlink" title="PipedWriter"></a>PipedWriter</h2><h3 id="Constructor-Summary-1"><a href="#Constructor-Summary-1" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="public-PipedWriter-PipedReader-snk"><a href="#public-PipedWriter-PipedReader-snk" class="headerlink" title="public PipedWriter(PipedReader snk)"></a>public PipedWriter(PipedReader snk)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PipedWriter</span><span class="params">(PipedReader snk)</span>  <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    connect(snk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个管道输入流。该流用于向缓冲区buffer中写入字符数据内容。初始化过程中，当前流会和管道输出流建立一个连接。</p>
<h4 id="public-PipedWriter"><a href="#public-PipedWriter" class="headerlink" title="public PipedWriter()"></a>public PipedWriter()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PipedWriter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个管道输入流。</p>
<h3 id="部分方法-1"><a href="#部分方法-1" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="public-synchronized-void-connect-PipedReader-snk"><a href="#public-synchronized-void-connect-PipedReader-snk" class="headerlink" title="public synchronized void connect(PipedReader snk)"></a><span id="publicSyncVoidConnect">public synchronized void connect(PipedReader snk)</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(PipedReader snk)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (snk == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sink != <span class="keyword">null</span> || snk.connected) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Already connected"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (snk.closedByReader || closed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Pipe closed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sink = snk;</span><br><span class="line">    snk.in = -<span class="number">1</span>;</span><br><span class="line">    snk.out = <span class="number">0</span>;</span><br><span class="line">    snk.connected = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;建立一个管道输出流和输入流的连接。第2 ~ 3行代码用来判断管道输出流（读管道）是否存在，第4 ~ 5行代码用来判断当前管道输入流是否已经和其他管道输出流建立了连接，或者入参管道输出流是否已经处于连接状态；第6 ~ 7行代码则检查管道流的开启状态。</p>
<p>&emsp;&emsp;第10 ~ 13行代码用来建立并维系一个入参管道输出流和当前管道输入流的连接关系，并初始化管道输出流的读写标记位值。</p>
<h4 id="public-void-write-int-c"><a href="#public-void-write-int-c" class="headerlink" title="public void write(int c)"></a>public void write(int c)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> c)</span>  <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sink == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Pipe not connected"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sink.receive(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;向缓冲区buf中写入一个字符数据。第2 ~ 4行代码完成管道状态的有效性校验。实际上调用管道输出流的方法<a href="#SyncVoidReceiveIC">PipedReader.receive(int c)</a>来实现功能的。</p>
<h4 id="public-void-write-char-cbuf-int-off-int-len"><a href="#public-void-write-char-cbuf-int-off-int-len" class="headerlink" title="public void write(char cbuf[], int off, int len)"></a>public void write(char cbuf[], int off, int len)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> cbuf[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sink == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Pipe not connected"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((off | len | (off + len) | (cbuf.length - (off + len))) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125;</span><br><span class="line">    sink.receive(cbuf, off, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;向缓冲区buf中写入入参cbuf中含有的字符数据。第2 ~ 6行代码完成管道状态和参数的有效性校验。底层通过调用方法<a href="#SyncVoidReceiveCCIFIL">PipedReader.receive(char c[], int off, int len)</a>来实现功能。</p>
<h4 id="public-synchronized-void-flush"><a href="#public-synchronized-void-flush" class="headerlink" title="public synchronized void flush()"></a>public synchronized void flush()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sink != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sink.closedByReader || closed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Pipe closed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (sink) &#123;</span><br><span class="line">            sink.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将缓冲区buffer中的数据推到目标输出位置上。这里实际上是唤醒所有的读线程，通过读线程去读取缓冲区buffer中的内容。</p>
<h4 id="public-void-close-1"><a href="#public-void-close-1" class="headerlink" title="public void close()"></a>public void close()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span>  <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    closed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (sink != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sink.receivedLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;关闭当前输出流。</p>
<p>&emsp;</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li>NIL</li>
</ol>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>NIL</li>
</ol>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java I/O 08 - PrintStream</title>
    <url>/2018/java-PrintStream.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;关于<em> <strong>java.io.PrintStream</strong> </em>的部分笔记，这个类除了实现了继承自FilterOutputStream的基本的write方法外，还提供了打印输出内容的方法来打印当前输出的内容。本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;PrintStream提供了打印输出内容的便捷方法，这样可以直接调用其提供的方法来完成输出内容的输出和打印显示两个操作。所有通过PrintStream输出打印的内容都会被转成字节流然后输出到目标位置。除此之外，PrintStream也不会抛出IOException，而是通过内置字段<strong>trouble</strong>来判断是否在调用过程中抛出了IOException。</p>
<p>&emsp;</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PushbackInputStream</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.io.OutputStream</span><br><span class="line">    --java.io.FilterOutputStream</span><br><span class="line">      --java.io.PrintStream</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类名</th>
<th style="text-align:center">实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PrintStream</td>
<td style="text-align:center">Closeable, Flushable, Appendable, AutoCloseable</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h2><h4 id="public-boolean-checkError"><a href="#public-boolean-checkError" class="headerlink" title="public boolean checkError()"></a>public boolean checkError()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (out != <span class="keyword">null</span>)</span><br><span class="line">        flush();</span><br><span class="line">    <span class="keyword">if</span> (out <span class="keyword">instanceof</span> java.io.PrintStream) &#123;</span><br><span class="line">        PrintStream ps = (PrintStream) out;</span><br><span class="line">        <span class="keyword">return</span> ps.checkError();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> trouble;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;检查当前时间点之前是否存在过数据输出异常的情况，如果存在，那么返回true。这里仅针对在方法调用过程中抛出的IOException，或者setError方法被显式调用。如果在过程中出现了InterruptedIOException，那么则通过<strong>Thread.currentThread().interrupt()</strong>进行处理。</p>
<h4 id="protected-void-setError"><a href="#protected-void-setError" class="headerlink" title="protected void setError()"></a>protected void setError()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    trouble = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="protected-void-clearError"><a href="#protected-void-clearError" class="headerlink" title="protected void clearError()"></a>protected void clearError()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">clearError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    trouble = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="public-void-write-int-b"><a href="#public-void-write-int-b" class="headerlink" title="public void write(int b)"></a>public void write(int b)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            ensureOpen();</span><br><span class="line">            out.write(b);</span><br><span class="line">            <span class="keyword">if</span> ((b == <span class="string">'\n'</span>) &amp;&amp; autoFlush)</span><br><span class="line">                out.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InterruptedIOException x) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">        trouble = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;向底层输出流中写入一个字节。如果入参是换行符，那么就根据autoFlush的值来决定是否需要把写入的数据推到目标输出位置。</p>
<h4 id="public-void-write-byte-buf-int-off-int-len"><a href="#public-void-write-byte-buf-int-off-int-len" class="headerlink" title="public void write(byte buf[], int off, int len)"></a>public void write(byte buf[], int off, int len)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> buf[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            ensureOpen();</span><br><span class="line">            out.write(buf, off, len);</span><br><span class="line">            <span class="keyword">if</span> (autoFlush)</span><br><span class="line">                out.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InterruptedIOException x) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">        trouble = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;向底层输出流中写入一个字节数组。在向底层输出流无异常写完那么就根据autoFlush的值来决定是否需要把写入的数据推到目标输出位置。</p>
<h4 id="private-void-write-char-buf"><a href="#private-void-write-char-buf" class="headerlink" title="private void write(char buf[])"></a>private void write(char buf[])</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> buf[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            ensureOpen();</span><br><span class="line">            textOut.write(buf);</span><br><span class="line">            textOut.flushBuffer();</span><br><span class="line">            charOut.flushBuffer();</span><br><span class="line">            <span class="keyword">if</span> (autoFlush) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buf.length; i++)</span><br><span class="line">                    <span class="keyword">if</span> (buf[i] == <span class="string">'\n'</span>)</span><br><span class="line">                        out.flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InterruptedIOException x) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">        trouble = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将字符数组输出到底层输出流中。首先将内容写入到textOut的缓冲区中（BufferedWriter），然后把数据强制刷新到textOut的底层输出流charOut （OutputStreamWriter）中。最后再把charOut的数据强制刷新到其中包含的底层输出流（StreamEncoder）。采用OutputStreamWriter的目的是因为这是一个字符流转字节流的类，可以实现把各种类型的数据转成对应的字节流输出。而BufferedWriter带有缓冲区，所以其效率相对来说会高一点。如果支持自动刷新，那么就判断入参字符数组中是否含有换行符“\n”，如果有就底层输出流的flush方法，将数据推到目标输出位置。</p>
<h4 id="private-void-write-String-s"><a href="#private-void-write-String-s" class="headerlink" title="private void write(String s)"></a>private void write(String s)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            ensureOpen();</span><br><span class="line">            textOut.write(s);</span><br><span class="line">            textOut.flushBuffer();</span><br><span class="line">            charOut.flushBuffer();</span><br><span class="line">            <span class="keyword">if</span> (autoFlush &amp;&amp; (s.indexOf(<span class="string">'\n'</span>) &gt;= <span class="number">0</span>))</span><br><span class="line">                out.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InterruptedIOException x) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">        trouble = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将字符串输出到底层输出流中。执行逻辑同方法<strong>write(char buf[]) </strong>，故不予赘述。</p>
<h4 id="private-void-newLine"><a href="#private-void-newLine" class="headerlink" title="private void newLine()"></a>private void newLine()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">newLine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            ensureOpen();</span><br><span class="line">            textOut.newLine();</span><br><span class="line">            textOut.flushBuffer();</span><br><span class="line">            charOut.flushBuffer();</span><br><span class="line">            <span class="keyword">if</span> (autoFlush)</span><br><span class="line">                out.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InterruptedIOException x) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">        trouble = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;跳转到下一行。执行逻辑同方法<strong>write(char buf[]) </strong>，故不予赘述。</p>
<h4 id="打印方法集合"><a href="#打印方法集合" class="headerlink" title="打印方法集合"></a>打印方法集合</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印布尔值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    write(b ? <span class="string">"true"</span> : <span class="string">"false"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印一个字符</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    write(String.valueOf(c));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印一个int型数值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    write(String.valueOf(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印一个long型数值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">    write(String.valueOf(l));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印一个float型数值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">float</span> f)</span> </span>&#123;</span><br><span class="line">    write(String.valueOf(f));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印一个double型数值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">    write(String.valueOf(d));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印一个字符数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> s[])</span> </span>&#123;</span><br><span class="line">    write(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印一个字符串值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">        s = <span class="string">"null"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    write(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    write(String.valueOf(obj));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另起一行打印</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    newLine();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印一个布尔值并换行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">boolean</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        print(x);</span><br><span class="line">        newLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印一个字符并换行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        print(x);</span><br><span class="line">        newLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印一个int型数值并换行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        print(x);</span><br><span class="line">        newLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印一个long型数值并换行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        print(x);</span><br><span class="line">        newLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印一个float型数值并换行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        print(x);</span><br><span class="line">        newLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印一个double型数值并换行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        print(x);</span><br><span class="line">        newLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印一个字符数组并换行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">char</span> x[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        print(x);</span><br><span class="line">        newLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印一个字符串并换行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        print(x);</span><br><span class="line">        newLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印一个对象并换行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">    String s = String.valueOf(x);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        print(s);</span><br><span class="line">        newLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="public-PrintStream-printf-Locale-l-String-format-Object-…-args"><a href="#public-PrintStream-printf-Locale-l-String-format-Object-…-args" class="headerlink" title="public PrintStream printf(Locale l, String format, Object … args)"></a>public PrintStream printf(Locale l, String format, Object … args)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PrintStream <span class="title">printf</span><span class="params">(Locale l, String format, Object ... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> format(l, format, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> PrintStream <span class="title">format</span><span class="params">(Locale l, String format, Object ... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            ensureOpen();</span><br><span class="line">            <span class="keyword">if</span> ((formatter == <span class="keyword">null</span>)</span><br><span class="line">                || (formatter.locale() != l))</span><br><span class="line">                formatter = <span class="keyword">new</span> Formatter(<span class="keyword">this</span>, l);</span><br><span class="line">            formatter.format(l, format, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedIOException x) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">        trouble = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;按照指定的输出格式打印入参内容。printf方法和单独调用format方法的执行结果是一致的。在format方法中，如果指定Locale，那么就会按照该区域的风格打印指定格式的内容。否则就会按照默认的区域风格打印。format字段用来指定具体的打印格式和结构。args则包含了具体填充的实际内容。在format方法中，实际发挥作用的是Formatter.format的方法。其内部处理逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Formatter <span class="title">format</span><span class="params">(Locale l, String format, Object ... args)</span> </span>&#123;</span><br><span class="line">    ensureOpen();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// index of last argument referenced</span></span><br><span class="line">    <span class="keyword">int</span> last = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// last ordinary index</span></span><br><span class="line">    <span class="keyword">int</span> lasto = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    FormatString[] fsa = parse(format);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fsa.length; i++) &#123;</span><br><span class="line">        FormatString fs = fsa[i];</span><br><span class="line">        <span class="keyword">int</span> index = fs.index();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (index) &#123;</span><br><span class="line">                <span class="keyword">case</span> -<span class="number">2</span>:  <span class="comment">// fixed string, "%n", or "%%"</span></span><br><span class="line">                    fs.print(<span class="keyword">null</span>, l);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> -<span class="number">1</span>:  <span class="comment">// relative index</span></span><br><span class="line">                    <span class="keyword">if</span> (last &lt; <span class="number">0</span> || (args != <span class="keyword">null</span> &amp;&amp; last &gt; args.length - <span class="number">1</span>))</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> MissingFormatArgumentException(fs.toString());</span><br><span class="line">                    fs.print((args == <span class="keyword">null</span> ? <span class="keyword">null</span> : args[last]), l);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:  <span class="comment">// ordinary index</span></span><br><span class="line">                    lasto++;</span><br><span class="line">                    last = lasto;</span><br><span class="line">                    <span class="keyword">if</span> (args != <span class="keyword">null</span> &amp;&amp; lasto &gt; args.length - <span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> MissingFormatArgumentException(fs.toString());</span><br><span class="line">                    fs.print((args == <span class="keyword">null</span> ? <span class="keyword">null</span> : args[lasto]), l);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:  <span class="comment">// explicit index</span></span><br><span class="line">                    last = index - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (args != <span class="keyword">null</span> &amp;&amp; last &gt; args.length - <span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> MissingFormatArgumentException(fs.toString());</span><br><span class="line">                    fs.print((args == <span class="keyword">null</span> ? <span class="keyword">null</span> : args[last]), l);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">            lastException = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> FormatString[] parse(String s) &#123;</span><br><span class="line">    ArrayList&lt;FormatString&gt; al = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Matcher m = fsPattern.matcher(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, len = s.length(); i &lt; len; ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m.find(i)) &#123;</span><br><span class="line">            <span class="comment">// Anything between the start of the string and the beginning</span></span><br><span class="line">            <span class="comment">// of the format specifier is either fixed text or contains</span></span><br><span class="line">            <span class="comment">// an invalid format string.</span></span><br><span class="line">            <span class="keyword">if</span> (m.start() != i) &#123;</span><br><span class="line">                <span class="comment">// Make sure we didn't miss any invalid format specifiers</span></span><br><span class="line">                checkText(s, i, m.start());</span><br><span class="line">                <span class="comment">// Assume previous characters were fixed text</span></span><br><span class="line">                al.add(<span class="keyword">new</span> FixedString(s.substring(i, m.start())));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            al.add(<span class="keyword">new</span> FormatSpecifier(m));</span><br><span class="line">            i = m.end();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// No more valid format specifiers.  Check for possible invalid</span></span><br><span class="line">            <span class="comment">// format specifiers.</span></span><br><span class="line">            checkText(s, i, len);</span><br><span class="line">            <span class="comment">// The rest of the string is fixed text</span></span><br><span class="line">            al.add(<span class="keyword">new</span> FixedString(s.substring(i)));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> al.toArray(<span class="keyword">new</span> FormatString[al.size()]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;format(Locale l, String format, Object … args)方法用来打印一个格式化了的内容。第9行代码用来识别出入参format中含有的有效的和无效的占位符，具体逻辑可浏览第44 ~ 71行代码。第10 ~ 40则遍历识别的占位符结果，并根据每个特定的占位符从参数集合args中取出对应位置的数据放入占位符所处的位置完成内容的格式化和输出打印。</p>
<h4 id="public-PrintStream-append-CharSequence-csq"><a href="#public-PrintStream-append-CharSequence-csq" class="headerlink" title="public PrintStream append(CharSequence csq)"></a>public PrintStream append(CharSequence csq)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在当前输出内容尾部追加新内容，如果入参为null，那么就输出“null”这四个字符到目标位置。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PrintStream <span class="title">append</span><span class="params">(CharSequence csq)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (csq == <span class="keyword">null</span>)</span><br><span class="line">        print(<span class="string">"null"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        print(csq.toString());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在当前输出内容尾部追加新内容，如果入参为null，那么就输出“null”这四个字符到目标位置，否则就输出从start开始，end - 1位置结束的子序列到目标输出位置。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PrintStream <span class="title">append</span><span class="params">(CharSequence csq, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    CharSequence cs = (csq == <span class="keyword">null</span> ? <span class="string">"null"</span> : csq);</span><br><span class="line">    write(cs.subSequence(start, end).toString());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在当前输出内容尾部追加一个新字符。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PrintStream <span class="title">append</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    print(c);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="public-int-flush"><a href="#public-int-flush" class="headerlink" title="public int flush()"></a>public int flush()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ensureOpen();</span><br><span class="line">            out.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">            trouble = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;把数据强制刷新到输出流中。这是一个线程安全的方法，需要注意的是，如果在方法调用过程中出现了异常，那么异常不会被向上抛出，而是将trouble字段标记为true，以此来判定方法执行过程中是否出现了异常。</p>
<p>&emsp;</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li>NIL</li>
</ol>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>NIL        </li>
</ol>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java I/O 23 - ObjectInputStream</title>
    <url>/2018/java-ObjectInputStream.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;关于<em> <strong>java.io.ObjectInputStream</strong> </em>的部分笔记，ObjectInputStream是Java反序列化操作的实现类，通过该类可以完成默认的或者自定义的对象反序列化操作。本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;ObjectInputStream对来自于ObjectOutputStream的基础数据类型和对象数据做反序列化操作。ObjectInputStream和ObjectOutputStream被用于持久化存储对象数据（只有支持<strong>java.io.Serializable</strong>和<strong>java.io.Externalizable</strong>的对象才会拥有这个能力）的场景中。<strong>java.io.Serializable</strong>和<strong>java.io.Externalizable</strong>这两个接口决定了序列化和反序列化的执行过程。用来将数据序列化处理之后通过网络等途径传输到目标持久化位置，而ObjectInputStream则会将序列化之后的数据反序列之后传入内存中供计算机程序处理，保证了从流中得到的对象还原成JVM支持的数据类型。</p>
<p>&emsp;&emsp;ObjectInputStream中的<strong>readObject()</strong>方法会从流中读取被序列化的对象数据。基础数据类型可以通过readXX()方法得到。默认的反序列化机制会计算并返回对象的每个字段被序列化之前的类型和存储的内容。如果字段声明中含有<strong>transient</strong>或者<strong>static</strong>，那么这些字段在反序列化的过程中不会被恢复。如果在一个对象中引用了其他对象，那么这些被引用的对象也会被序列化且ObjectInputStream会从流中尝试反序列这些对象。在反序列化的过程中，新的对象和原有对象分别占用不同的内存空间，所以对原有对象的修改不会影响到新对象，反之亦然。</p>
<p>&emsp;&emsp;前面说过共有两个接口来标识可序列化的类：java.io.Serializable和java.io.Externalizable。实现了java.io.Serializable接口的对象可以被对象序列化机制自动地存储和恢复类的所有内容和状态，并且允许类在对象被写入流和从流中读取的时间段内发生变化。如果说某个实现了java.io.Serializable接口的类需要自定义序列化和反序列操作，那么就需要实现<strong>readObjectNoData()</strong>、<strong>writeObject(java.io.ObjectOutputStream stream)</strong>、<strong>readObject(java.io.ObjectInputStream stream)</strong>方法。readObject方法负责从流中读取数据并且恢复类的各个状态，恢复的基础是依据通过对应的writeObject方法向流中写入的对象已经被序列化了的数据内容。被反序列之后的新对象通过从ObjectInputStream中读取数据并且完成对象中各个字段的赋值操作。如果在读书序列化数据执行反序列操作时数据读取越界，那么就会抛出一个<strong>OptionalDataException</strong>异常。</p>
<p>&emsp;&emsp;序列化操作不会对没有实现Serializable接口的对象进行操作，如果父类没有序列化，那么其子类依旧可以做序列化操作，这种情况下子类需要对没有不支持序列化的父类的保存和还原负责，这时需要父类的字段属性的权限类型是public, package, 或者protected，以及提供用来还原字段内容的get/set方法。</p>
<p>&emsp;</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ObjectInputStream</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.io.InputStream</span><br><span class="line">    --java.io.ObjectInputStream</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><div class="table-container">
<table>
<thead>
<tr>
<th>类名</th>
<th>实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>ObjectInputStream</td>
<td>Closeable, DataInput, ObjectInput, ObjectStreamConstants, AutoCloseable</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="ObjectInputStream"><a href="#ObjectInputStream" class="headerlink" title="ObjectInputStream"></a>ObjectInputStream</h2><h3 id="Constructor-Summary"><a href="#Constructor-Summary" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="public-ObjectInputStream-InputStream-in"><a href="#public-ObjectInputStream-InputStream-in" class="headerlink" title="public ObjectInputStream(InputStream in)"></a>public ObjectInputStream(InputStream in)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ObjectInputStream</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    verifySubclass();</span><br><span class="line">    bin = <span class="keyword">new</span> BlockDataInputStream(in);</span><br><span class="line">    handles = <span class="keyword">new</span> HandleTable(<span class="number">10</span>);</span><br><span class="line">    vlist = <span class="keyword">new</span> ValidationList();</span><br><span class="line">    enableOverride = <span class="keyword">false</span>;</span><br><span class="line">    readStreamHeader();</span><br><span class="line">    bin.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;根据指定输入流初始化一个ObjectInputStream实例。在过程中会从流中读取一个序列化流头部信息，如果序列化尚未将流头部信息写入到流中那么该过程会阻塞。之后会执行security manager。</p>
<p>如果有子类继承了当前ObjectInputStream，那么<strong>verifySubclass()</strong>方法需要检查子类是否违反安全限制：子类不能覆盖安全敏感的非final方法，否则将执行“支持子类实现”的序列化准许（”enableSubclassImplementation” SerializablePermission）检查。</p>
<p>&emsp;&emsp;之后初始化一个BlockDataInputStream完成数据读取。调用<strong>readStreamHeader()</strong>完成流头部信息读取操作。如果流头部信息不正确，抛出<strong>StreamCorruptedException</strong>异常，如果在读取流头部过程中发生I/O异常，那么抛出<strong>IOException</strong>。</p>
<h4 id="protected-ObjectInputStream"><a href="#protected-ObjectInputStream" class="headerlink" title="protected ObjectInputStream()"></a>protected ObjectInputStream()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ObjectInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException, SecurityException </span>&#123;</span><br><span class="line">    SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sm.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">    &#125;</span><br><span class="line">    bin = <span class="keyword">null</span>;</span><br><span class="line">    handles = <span class="keyword">null</span>;</span><br><span class="line">    vlist = <span class="keyword">null</span>;</span><br><span class="line">    enableOverride = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;为子类提供了一种可以完全重新实现ObjectInputStream的途径，这个方法不需要再单独分配私有字段而直接使用ObjectInputStream中的字段。如果存在security manager，那么首先需要调用<strong>checkPermission(Permission perm)</strong>完成检查，保证“支持子类实现”的序列化准许（”enableSubclassImplementation” SerializablePermission）检查适用于子类。</p>
<h3 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="private-void-verifySubclass"><a href="#private-void-verifySubclass" class="headerlink" title="private void verifySubclass()"></a>private void verifySubclass()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">verifySubclass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Class cl = getClass();</span><br><span class="line">    <span class="keyword">if</span> (cl == ObjectInputStream.class) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    processQueue(Caches.subclassAuditsQueue, Caches.subclassAudits);</span><br><span class="line">    WeakClassKey key = <span class="keyword">new</span> WeakClassKey(cl, Caches.subclassAuditsQueue);</span><br><span class="line">    Boolean result = Caches.subclassAudits.get(key);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = Boolean.valueOf(auditSubclass(cl));</span><br><span class="line">        Caches.subclassAudits.putIfAbsent(key, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result.booleanValue()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sm.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;检查子类是否违反安全限制：子类不能覆盖安全敏感的非final方法，否则将执行“支持子类实现”的序列化准许（”enableSubclassImplementation” SerializablePermission）检查。或者说，该方法会检查当前需要构造的类是不是ObjectInputStream自身或者其子类。</p>
<p>&emsp;&emsp;第2 ~ 5行代码获取当前运行的类，如果是ObjectInputStream自身，那么直接返回。第6 ~ 9行代码判断是否带有SecurityManager，如果没有直接返回。第10行代码通过如下方法移除Caches中已经失去引用的class对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">processQueue(ReferenceQueue&lt;Class&lt;?&gt;&gt; queue,</span><br><span class="line">                             ConcurrentMap&lt;? extends WeakReference&lt;Class&lt;?&gt;&gt;, ?&gt; map)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;第11行代码通过初始化一个弱引用将ObjectInputStream的子类存入Caches中。在第14行代码中检查当前子类是否覆盖了安全敏感的非final方法，如果是安全的（检查通过了），那么返回true，否则返回false标识检查未通过。然后在15行代码中将当前ObjectInputStream子类维护到Caches的subclassAudits集合中。</p>
<p>&emsp;&emsp;最后第20行代码完成当前实现类是否拥有SUBCLASS_IMPLEMENTATION_PERMISSION权限，如果没有，则需要抛出SecurityException异常。 </p>
<h4 id="private-static-boolean-auditSubclass-final-Class-lt-gt-subcl"><a href="#private-static-boolean-auditSubclass-final-Class-lt-gt-subcl" class="headerlink" title="private static boolean auditSubclass(final Class&lt;?&gt; subcl)"></a>private static boolean auditSubclass(final Class&lt;?&gt; subcl)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">auditSubclass</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; subcl)</span> </span>&#123;</span><br><span class="line">    Boolean result = AccessController.doPrivileged(</span><br><span class="line">        <span class="keyword">new</span> PrivilegedAction&lt;Boolean&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (Class&lt;?&gt; cl = subcl;</span><br><span class="line">                     cl != ObjectInputStream.class;</span><br><span class="line">                     cl = cl.getSuperclass())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        cl.getDeclaredMethod(</span><br><span class="line">                            <span class="string">"readUnshared"</span>, (Class[]) <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">return</span> Boolean.FALSE;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        cl.getDeclaredMethod(<span class="string">"readFields"</span>, (Class[]) <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">return</span> Boolean.FALSE;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> result.booleanValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;用来完成子类的安全检查。检查子类是否覆盖了安全敏感的非final方法，如果没有返回true表示检查通过，否则返回false。</p>
<p>&emsp;&emsp;第5 ~ 8行代码从入参subc1自身开始，依次得到其直接父类，直到到达ObjectInputStream，检查每个类是否存在”readUnshared”和”readFields”方法，如果有，返回false，否则抛出<strong>NoSuchMethodException</strong>异常最后返回true表示检查通过。</p>
<h4 id="protected-void-readStreamHeader"><a href="#protected-void-readStreamHeader" class="headerlink" title="protected void readStreamHeader()"></a>protected void readStreamHeader()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">readStreamHeader</span><span class="params">()</span> <span class="keyword">throws</span> IOException, StreamCorruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">short</span> s0 = bin.readShort();</span><br><span class="line">    <span class="keyword">short</span> s1 = bin.readShort();</span><br><span class="line">    <span class="keyword">if</span> (s0 != STREAM_MAGIC || s1 != STREAM_VERSION) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StreamCorruptedException(</span><br><span class="line">            String.format(<span class="string">"invalid stream header: %04X%04X"</span>, s0, s1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;协助子类读取和验证它们自己的流头部，过程中会读取和校验魔数和版本号。这两个数都是序列化过程中写入到流里的。</p>
<h4 id="public-final-Object-readObject"><a href="#public-final-Object-readObject" class="headerlink" title="public final Object readObject()"></a>public final Object readObject()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">readObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (enableOverride) &#123;</span><br><span class="line">        <span class="keyword">return</span> readObjectOverride();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if nested read, passHandle contains handle of enclosing object</span></span><br><span class="line">    <span class="keyword">int</span> outerHandle = passHandle;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object obj = readObject0(<span class="keyword">false</span>);</span><br><span class="line">        handles.markDependency(outerHandle, passHandle);</span><br><span class="line">        ClassNotFoundException ex = handles.lookupException(passHandle);</span><br><span class="line">        <span class="keyword">if</span> (ex != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (depth == <span class="number">0</span>) &#123;</span><br><span class="line">            vlist.doCallbacks();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        passHandle = outerHandle;</span><br><span class="line">        <span class="keyword">if</span> (closed &amp;&amp; depth == <span class="number">0</span>) &#123;</span><br><span class="line">            clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从ObjectInputStream中读取一个对象，final关键字表示该方法不可能被子类覆盖。对象的类型、类型签名、未被transient和static修饰的字段值以及该对象的所有父类型都会被读取到。对一个类对象的默认的反序列操作可通过readObject()和writeObject()方法覆盖以实现个性化需求。与该对象相关的所有对象都会被readObject()方法读取到以保证可以完整的完成反序列化。需要注意的是，只有当当前对象的所有字段以及其所有引用的其他对象都被恢复了以后，这个对象的反序列化过程才算完成。</p>
<p>&emsp;&emsp;第2 ~ 4行代码如果需要使用子类实现来完成数据读取，那么就调用readObjectOverride()。enableOverride字段会在<strong>protected ObjectInputStream()</strong>构造器中被指定为true，而该构造器是给ObjectInputStream的子类初始化用的，所以如果是子类实现，那么就用子类的读取方法来完成数据读取操作。如果类里面定义了非基本数据类型变量，需要进行嵌套读取，outerHandle用来存储上一层读取对象的句柄，所以第7行代码维护了上一层读取对象的句柄。然后调用<strong>readObject0</strong>读取生成对象（<strong>整个方法的核心！核心！核心！</strong>）。完成之后要记录句柄依赖（第10行代码），并检查有无异常产生（第11行代码）。第15 ~ 17行代码表示最上层读取完成之后要发起回调，最后返回反序列的对象obj。</p>
<p>&emsp;&emsp;第20 ~ 24行代码如果最上层调用结束后那么清空相关记录缓存（包含但不限于调用返回列表和句柄缓存）。</p>
<h4 id="protected-Object-readObjectOverride"><a href="#protected-Object-readObjectOverride" class="headerlink" title="protected Object readObjectOverride()"></a>protected Object readObjectOverride()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">readObjectOverride</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;ObjectInputStream的子类覆盖该方法以完成子类的反序列的操作。留给子类用的，ObjectInputStream自身无法使用该方法。</p>
<h4 id="private-Object-readObject0-boolean-unshared"><a href="#private-Object-readObject0-boolean-unshared" class="headerlink" title="private Object readObject0(boolean unshared)"></a>private Object readObject0(boolean unshared)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readObject0</span><span class="params">(<span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> oldMode = bin.getBlockDataMode();</span><br><span class="line">    <span class="keyword">if</span> (oldMode) &#123;</span><br><span class="line">        <span class="keyword">int</span> remain = bin.currentBlockRemaining();</span><br><span class="line">        <span class="keyword">if</span> (remain &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OptionalDataException(remain);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (defaultDataEnd) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Fix for 4360508: stream is currently at the end of a field</span></span><br><span class="line"><span class="comment">             * value block written via default serialization; since there</span></span><br><span class="line"><span class="comment">             * is no terminating TC_ENDBLOCKDATA tag, simulate</span></span><br><span class="line"><span class="comment">             * end-of-custom-data behavior explicitly.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OptionalDataException(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        bin.setBlockDataMode(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span> tc;</span><br><span class="line">    <span class="keyword">while</span> ((tc = bin.peekByte()) == TC_RESET) &#123;</span><br><span class="line">        bin.readByte();</span><br><span class="line">        handleReset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    depth++;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (tc) &#123;</span><br><span class="line">            <span class="keyword">case</span> TC_NULL:</span><br><span class="line">                <span class="keyword">return</span> readNull();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_REFERENCE:</span><br><span class="line">                <span class="keyword">return</span> readHandle(unshared);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_CLASS:</span><br><span class="line">                <span class="keyword">return</span> readClass(unshared);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_CLASSDESC:</span><br><span class="line">            <span class="keyword">case</span> TC_PROXYCLASSDESC:</span><br><span class="line">                <span class="keyword">return</span> readClassDesc(unshared);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_STRING:</span><br><span class="line">            <span class="keyword">case</span> TC_LONGSTRING:</span><br><span class="line">                <span class="keyword">return</span> checkResolve(readString(unshared));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_ARRAY:</span><br><span class="line">                <span class="keyword">return</span> checkResolve(readArray(unshared));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_ENUM:</span><br><span class="line">                <span class="keyword">return</span> checkResolve(readEnum(unshared));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_OBJECT:</span><br><span class="line">                <span class="keyword">return</span> checkResolve(readOrdinaryObject(unshared));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_EXCEPTION:</span><br><span class="line">                IOException ex = readFatalException();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> WriteAbortedException(<span class="string">"writing aborted"</span>, ex);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_BLOCKDATA:</span><br><span class="line">            <span class="keyword">case</span> TC_BLOCKDATALONG:</span><br><span class="line">                <span class="keyword">if</span> (oldMode) &#123;</span><br><span class="line">                    bin.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">                    bin.peek();             <span class="comment">// force header read</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> OptionalDataException(</span><br><span class="line">                        bin.currentBlockRemaining());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> StreamCorruptedException(</span><br><span class="line">                        <span class="string">"unexpected block data"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_ENDBLOCKDATA:</span><br><span class="line">                <span class="keyword">if</span> (oldMode) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> OptionalDataException(<span class="keyword">true</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> StreamCorruptedException(</span><br><span class="line">                        <span class="string">"unexpected end of block data"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> StreamCorruptedException(</span><br><span class="line">                    String.format(<span class="string">"invalid type code: %02X"</span>, tc));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        depth--;</span><br><span class="line">        bin.setBlockDataMode(oldMode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;readObject0必须在上一次反序列化操作彻底完成后（此时流内不存在任何数据）才能开始当前的读取和反序列化操作，否则会抛出异常。</p>
<p>&emsp;&emsp;第2 ~ 17行代码用来判断当前操作开始前流内是否存在上次反序列操作未处理的剩余数据，如果有，那么就抛出<strong>OptionalDataException</strong>异常。判断操作都执行完后执行<strong>bin.setBlockDataMode(false)</strong>标记本次读取和反序列操作开始。</p>
<p>&emsp;&emsp;第19 ~ 23行代码中，如果读取的下一个字节是“TC_RESET”，那么意味着所有写入到流中的数据都会被重置。所以读取一个字节内容，然后调用<strong>handleReset()</strong>完成重置操作。</p>
<p>&emsp;&emsp;第25行代码表示每调用一次readObject0方法，嵌套深度加一。</p>
<p>&emsp;&emsp;之后根据读取到的tc码来分场景反序列恢复数据内容：</p>
<ol>
<li>第28 ~ 30行代码表示如果恢复的是一个null元素引用，那么调用<strong>readNull()</strong>完成处理。</li>
<li>第31 ~ 33行代码表示如果恢复的是一个指向已经写入到流里的对象的引用，那么调用<strong>readHandle(boolean unshared)</strong>读取引用对象完成处理。</li>
<li>第34 ~ 36行代码表示如果恢复的是一个指向类的引用，那么调用<strong>readClass(boolean unshared)</strong>读取一个类完成处理。</li>
<li>第37 ~ 40行代码表示如果恢复的是一个指向类描述符或者代理类描述符的引用，那么调用<strong>readClassDesc(boolean unshared)</strong>读取一个类描述符完成处理。</li>
<li>第41 ~ 44行代码表示如果恢复的是一个String 或者long String（Unicode&gt;0xFF），那么调用<strong>checkResolve(Object obj)</strong>检查<strong>readString(boolean unshared)</strong>的返回内容。</li>
<li>第45 ~ 47行代码表示如果恢复的是一个数组，那么调用<strong>checkResolve(Object obj)</strong>检查<strong>readArray(boolean unshared)</strong>的返回内容。</li>
<li>第48 ~ 50行代码表示如果恢复的是一个枚举常量，那么调用<strong>checkResolve(Object obj)</strong>检查<strong>readEnum(boolean unshared)</strong>的返回内容。</li>
<li>第51 ~ 53行代码表示如果恢复的是一个Object，那么调用<strong>checkResolve(Object obj)</strong>检查<strong>readOrdinaryObject(boolean unshared)</strong>的返回内容。</li>
<li>第54 ~ 57行代码表示如果恢复的是一个写入过程中产生的异常，那么调用<strong>readFatalException()</strong>获取异常内容。</li>
<li>第58 ~ 69行代码表示如果恢复的是一个块数据，那么抛出异常内容。</li>
<li>第70 ~ 77行代码表示如果恢复的是一个块数据结束标志，那么抛出异常内容。</li>
</ol>
<p>&emsp;&emsp;如果都不符合上述十一个场景，那么抛出异常。最后将深度减一表示当前层次处理已经完成。</p>
<h4 id="private-void-handleReset"><a href="#private-void-handleReset" class="headerlink" title="private void handleReset()"></a>private void handleReset()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleReset</span><span class="params">()</span> <span class="keyword">throws</span> StreamCorruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StreamCorruptedException(</span><br><span class="line">            <span class="string">"unexpected reset; recursion depth: "</span> + depth);</span><br><span class="line">    &#125;</span><br><span class="line">    clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果发生了嵌套读取反序列操作，且当前操作不处于最顶层，那么抛出<strong>StreamCorruptedException</strong>异常。如果处于最顶层，则调用<strong>clear()</strong>方法完成内部数据结构的清空操作。</p>
<h4 id="private-void-clear"><a href="#private-void-clear" class="headerlink" title="private void clear()"></a>private void clear()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    handles.clear();</span><br><span class="line">    vlist.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;清空并使得句柄HandleTable处于初始态。清空并使得回调列表ValidationList处于初始态。</p>
<h4 id="private-Object-readNull"><a href="#private-Object-readNull" class="headerlink" title="private Object readNull()"></a>private Object readNull()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readNull</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bin.readByte() != TC_NULL) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">    &#125;</span><br><span class="line">    passHandle = NULL_HANDLE;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个方法处理的读取到的元素是null的场景，如果实际读到的不是null，那么抛出异常。反之，由于passHandle维护的是一个对象句柄，而此方法读取并返回的是一个null，所以句柄被置为null并返回null。</p>
<h4 id="private-Object-readHandle-boolean-unshared"><a href="#private-Object-readHandle-boolean-unshared" class="headerlink" title="private Object readHandle(boolean unshared)"></a>private Object readHandle(boolean unshared)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readHandle</span><span class="params">(<span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bin.readByte() != TC_REFERENCE) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">    &#125;</span><br><span class="line">    passHandle = bin.readInt() - baseWireHandle;</span><br><span class="line">    <span class="keyword">if</span> (passHandle &lt; <span class="number">0</span> || passHandle &gt;= handles.size()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StreamCorruptedException(</span><br><span class="line">            String.format(<span class="string">"invalid handle value: %08X"</span>, passHandle +</span><br><span class="line">                          baseWireHandle));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (unshared) &#123;</span><br><span class="line">        <span class="comment">// REMIND: what type of exception to throw here?</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(</span><br><span class="line">            <span class="string">"cannot read back reference as unshared"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object obj = handles.lookupObject(passHandle);</span><br><span class="line">    <span class="keyword">if</span> (obj == unsharedMarker) &#123;</span><br><span class="line">        <span class="comment">// REMIND: what type of exception to throw here?</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(</span><br><span class="line">            <span class="string">"cannot read back reference to unshared object"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从流里读取到一个对象句柄，将passHandle置为读取到的这个句柄，并返回一个关联到该句柄上的对象。如果当前读到的不是一个REFERENCE标识，那么抛出异常。因为在向流写入的过程中数据等于handle值加baseWireHandle的和，所以这里要减去还原。由于元素handle值在写入时是逐个增加的（实际上在写入过程中是依据写入环境的handle集合存储的元素个数作为handle存储的index下标的，最终实现效果就是在尾部加入元素）所以passHandle值不可能大于handles的长度，如果不满条件，那么抛出异常。</p>
<p>&emsp;&emsp;如果unshared为true，抛出异常。从缓存中寻找并取出对象。如果找到的对象带有unshared标记，抛出异常。反之向方法调用方返回找到的对象。</p>
<h4 id="private-Class-readClass-boolean-unshared"><a href="#private-Class-readClass-boolean-unshared" class="headerlink" title="private Class readClass(boolean unshared)"></a>private Class readClass(boolean unshared)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Class <span class="title">readClass</span><span class="params">(<span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bin.readByte() != TC_CLASS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">    &#125;</span><br><span class="line">    ObjectStreamClass desc = readClassDesc(<span class="keyword">false</span>);</span><br><span class="line">    Class cl = desc.forClass();</span><br><span class="line">    passHandle = handles.assign(unshared ? unsharedMarker : cl);</span><br><span class="line"></span><br><span class="line">    ClassNotFoundException resolveEx = desc.getResolveException();</span><br><span class="line">    <span class="keyword">if</span> (resolveEx != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handles.markException(passHandle, resolveEx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handles.finish(passHandle);</span><br><span class="line">    <span class="keyword">return</span> cl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从流里读取并返回一个类对象，将passHandle置为类对象分配的句柄。如果类无法被解析（ClassNotFoundException会被关联到类的句柄上），那么返回null。</p>
<p>&emsp;&emsp;如果当前读到的不是一个TC_CLASS标识，那么抛出异常。紧接着读取并返回一个类描述符。如果得到的类描述符无法正常解析出一个可以在本地VM运行的类，那么抛出异常。从返回的类描述符中返回一个来自于本地VM的类。然后根据unshared标记决定passHandle是指向一个unsharedMarker还是刚才得到的类。</p>
<p>&emsp;&emsp;第9行代码检查在解析本地类的过程中是否出现了异常，如果有异常，需要将当前passHandle与异常建立映射关系。结束当前passHandle的映射建立过程，该passHandle将不会与其他新的对象建立映射关系。最后返回得到的类。</p>
<h4 id="private-ObjectStreamClass-readClassDesc-boolean-unshared"><a href="#private-ObjectStreamClass-readClassDesc-boolean-unshared" class="headerlink" title="private ObjectStreamClass readClassDesc(boolean unshared)"></a>private ObjectStreamClass readClassDesc(boolean unshared)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ObjectStreamClass <span class="title">readClassDesc</span><span class="params">(<span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> tc = bin.peekByte();</span><br><span class="line">    <span class="keyword">switch</span> (tc) &#123;</span><br><span class="line">        <span class="keyword">case</span> TC_NULL:</span><br><span class="line">            <span class="keyword">return</span> (ObjectStreamClass) readNull();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> TC_REFERENCE:</span><br><span class="line">            <span class="keyword">return</span> (ObjectStreamClass) readHandle(unshared);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> TC_PROXYCLASSDESC:</span><br><span class="line">            <span class="keyword">return</span> readProxyDesc(unshared);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> TC_CLASSDESC:</span><br><span class="line">            <span class="keyword">return</span> readNonProxyDesc(unshared);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StreamCorruptedException(</span><br><span class="line">                String.format(<span class="string">"invalid type code: %02X"</span>, tc));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;读取并返回一个类描述符。将passHandle分给类描述符指定的句柄。如果类描述符无法正确解析成一个本地VM中的一个类，那么抛出<strong>ClassNotFoundException</strong>异常。</p>
<p>&emsp;&emsp;读取TC标识，如果TC标识为TC_NULL，那么调用readNull()返回一个null对象。</p>
<p>&emsp;&emsp;如果TC标识为TC_REFERENCE，那么调用readHandle(boolean unshared)返回一个句柄指向的对象。</p>
<p>&emsp;&emsp;如果TC标识为TC_PROXYCLASSDESC，那么调用readProxyDesc(boolean unshared)返回一个动态代理类的类描述符。</p>
<p>&emsp;&emsp;如果TC标识为TC_CLASSDESC，那么调用readNonProxyDesc(boolean unshared)返回一个非动态代理类的类描述符。</p>
<p>&emsp;&emsp;如果不是上述场景，抛出异常。</p>
<h4 id="private-ObjectStreamClass-readProxyDesc-boolean-unshared"><a href="#private-ObjectStreamClass-readProxyDesc-boolean-unshared" class="headerlink" title="private ObjectStreamClass readProxyDesc(boolean unshared)"></a>private ObjectStreamClass readProxyDesc(boolean unshared)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ObjectStreamClass <span class="title">readProxyDesc</span><span class="params">(<span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bin.readByte() != TC_PROXYCLASSDESC) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ObjectStreamClass desc = <span class="keyword">new</span> ObjectStreamClass();</span><br><span class="line">    <span class="keyword">int</span> descHandle = handles.assign(unshared ? unsharedMarker : desc);</span><br><span class="line">    passHandle = NULL_HANDLE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numIfaces = bin.readInt();</span><br><span class="line">    String[] ifaces = <span class="keyword">new</span> String[numIfaces];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numIfaces; i++) &#123;</span><br><span class="line">        ifaces[i] = bin.readUTF();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class cl = <span class="keyword">null</span>;</span><br><span class="line">    ClassNotFoundException resolveEx = <span class="keyword">null</span>;</span><br><span class="line">    bin.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((cl = resolveProxyClass(ifaces)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            resolveEx = <span class="keyword">new</span> ClassNotFoundException(<span class="string">"null class"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!Proxy.isProxyClass(cl)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidClassException(<span class="string">"Not a proxy"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ReflectUtil.checkProxyPackageAccess makes a test</span></span><br><span class="line">            <span class="comment">// equivalent to isCustomSubclass so there's no need</span></span><br><span class="line">            <span class="comment">// to condition this call to isCustomSubclass == true here.</span></span><br><span class="line">            ReflectUtil.checkProxyPackageAccess(getClass().getClassLoader(),</span><br><span class="line">                                                cl.getInterfaces());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        resolveEx = ex;</span><br><span class="line">    &#125;</span><br><span class="line">    skipCustomData();</span><br><span class="line"></span><br><span class="line">    desc.initProxy(cl, resolveEx, readClassDesc(<span class="keyword">false</span>));</span><br><span class="line"></span><br><span class="line">    handles.finish(descHandle);</span><br><span class="line">    passHandle = descHandle;</span><br><span class="line">    <span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;读取并返回一个动态代理类的类描述符。如果当前读到的不是一个TC_PROXYCLASSDESC标识，那么抛出异常。第6行代码用来初始化一个空的类描述符，该描述符包含有类描述符的名字和serialVersionUID。第10 ~ 15行代码获取动态代理类实现的接口内容。第20 ~ 21行代码试图返回一个实现了相关接口的动态代理类，如果返回失败，那么抛出异常。如果返回的不是动态代理类，那么抛出异常。紧接着利用类描述符初始化一个动态代理类，更新passHandle的值并返回初始化的动态代理类。</p>
<h4 id="protected-Class-lt-gt-resolveProxyClass-String-interfaces"><a href="#protected-Class-lt-gt-resolveProxyClass-String-interfaces" class="headerlink" title="protected Class&lt;?&gt; resolveProxyClass(String[] interfaces)"></a>protected Class&lt;?&gt; resolveProxyClass(String[] interfaces)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; resolveProxyClass(String[] interfaces)</span><br><span class="line">			<span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    ClassLoader latestLoader = latestUserDefinedLoader();</span><br><span class="line">    ClassLoader nonPublicLoader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> hasNonPublicInterface = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// define proxy in class loader of non-public interface(s), if any</span></span><br><span class="line">    Class[] classObjs = <span class="keyword">new</span> Class[interfaces.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interfaces.length; i++) &#123;</span><br><span class="line">        Class cl = Class.forName(interfaces[i], <span class="keyword">false</span>, latestLoader);</span><br><span class="line">        <span class="keyword">if</span> ((cl.getModifiers() &amp; Modifier.PUBLIC) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasNonPublicInterface) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nonPublicLoader != cl.getClassLoader()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalAccessError(</span><br><span class="line">                        <span class="string">"conflicting non-public interface class loaders"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nonPublicLoader = cl.getClassLoader();</span><br><span class="line">                hasNonPublicInterface = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        classObjs[i] = cl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.getProxyClass(</span><br><span class="line">            hasNonPublicInterface ? nonPublicLoader : latestLoader, classObjs);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="keyword">null</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回一个实现了代理类描述符中包含的所有接口的代理类。ObjectInputStream的子类可以实现这个方法来满足个性化的数据内容的读取需求，为开发人员提供了一种可供选择的接口和代理类的加载机制。第8 ~ 23行代码遍历每个接口信息，根据接口和得到的类加载器生成对应的实现类。如果生成的类是public修饰的，那么判断是否拥有非公共的类加载器。最后从生成的类对象中得到生成的代理类。</p>
<h4 id="private-static-ClassLoader-latestUserDefinedLoader"><a href="#private-static-ClassLoader-latestUserDefinedLoader" class="headerlink" title="private static ClassLoader latestUserDefinedLoader()"></a>private static ClassLoader latestUserDefinedLoader()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ClassLoader <span class="title">latestUserDefinedLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sun.misc.VM.latestUserDefinedLoader();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回第一个非null的类加载器到执行栈。</p>
<h4 id="private-void-skipCustomData"><a href="#private-void-skipCustomData" class="headerlink" title="private void skipCustomData()"></a>private void skipCustomData()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">skipCustomData</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldHandle = passHandle;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bin.getBlockDataMode()) &#123;</span><br><span class="line">            bin.skipBlockData();</span><br><span class="line">            bin.setBlockDataMode(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (bin.peekByte()) &#123;</span><br><span class="line">            <span class="keyword">case</span> TC_BLOCKDATA:</span><br><span class="line">            <span class="keyword">case</span> TC_BLOCKDATALONG:</span><br><span class="line">                bin.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_ENDBLOCKDATA:</span><br><span class="line">                bin.readByte();</span><br><span class="line">                passHandle = oldHandle;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                readObject0(<span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;跳过所有的块数据和对象直到遇到TC_ENDBLOCKDATA。</p>
<h4 id="private-ObjectStreamClass-readNonProxyDesc-boolean-unshared"><a href="#private-ObjectStreamClass-readNonProxyDesc-boolean-unshared" class="headerlink" title="private ObjectStreamClass readNonProxyDesc(boolean unshared)"></a>private ObjectStreamClass readNonProxyDesc(boolean unshared)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ObjectStreamClass <span class="title">readNonProxyDesc</span><span class="params">(<span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bin.readByte() != TC_CLASSDESC) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ObjectStreamClass desc = <span class="keyword">new</span> ObjectStreamClass();</span><br><span class="line">    <span class="keyword">int</span> descHandle = handles.assign(unshared ? unsharedMarker : desc);</span><br><span class="line">    passHandle = NULL_HANDLE;</span><br><span class="line"></span><br><span class="line">    ObjectStreamClass readDesc = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        readDesc = readClassDescriptor();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (IOException) <span class="keyword">new</span> InvalidClassException(</span><br><span class="line">            <span class="string">"failed to read class descriptor"</span>).initCause(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class cl = <span class="keyword">null</span>;</span><br><span class="line">    ClassNotFoundException resolveEx = <span class="keyword">null</span>;</span><br><span class="line">    bin.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> checksRequired = isCustomSubclass();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((cl = resolveClass(readDesc)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            resolveEx = <span class="keyword">new</span> ClassNotFoundException(<span class="string">"null class"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (checksRequired) &#123;</span><br><span class="line">            ReflectUtil.checkPackageAccess(cl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        resolveEx = ex;</span><br><span class="line">    &#125;</span><br><span class="line">    skipCustomData();</span><br><span class="line"></span><br><span class="line">    desc.initNonProxy(readDesc, cl, resolveEx, readClassDesc(<span class="keyword">false</span>));</span><br><span class="line"></span><br><span class="line">    handles.finish(descHandle);</span><br><span class="line">    passHandle = descHandle;</span><br><span class="line">    <span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;读取并返回一个不是动态代理类的类描述符。如果当前读到的不是一个TC_CLASSDESC标识，那么抛出异常。第6行代码生成一个类描述符实例，里面含有类名和接口名。第10 ~ 16行代码会从序列化流中读取一个类描述符。第21行代码判断当前类是否是ObjectInputStream的子类实现。第22 ~ 30行代码异常检查。第33行代码会初始化一个非动态代理类，最后返回生成的类描述符。</p>
<h4 id="protected-ObjectStreamClass-readClassDescriptor"><a href="#protected-ObjectStreamClass-readClassDescriptor" class="headerlink" title="protected ObjectStreamClass readClassDescriptor()"></a>protected ObjectStreamClass readClassDescriptor()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ObjectStreamClass <span class="title">readClassDescriptor</span><span class="params">()</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    ObjectStreamClass desc = <span class="keyword">new</span> ObjectStreamClass();</span><br><span class="line">    desc.readNonProxy(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从序列化流中读取一个类描述符。ObjectInputStream的子类可以覆盖这个方法以此实现可以以非标准化格式写入的类描述符。</p>
<h4 id="protected-Class-lt-gt-resolveClass-ObjectStreamClass-desc"><a href="#protected-Class-lt-gt-resolveClass-ObjectStreamClass-desc" class="headerlink" title="protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc)"></a>protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; resolveClass(ObjectStreamClass desc)</span><br><span class="line">			<span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    String name = desc.getName();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Class.forName(name, <span class="keyword">false</span>, latestUserDefinedLoader());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        Class&lt;?&gt; cl = primClasses.get(name);</span><br><span class="line">        <span class="keyword">if</span> (cl != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;加载本地的特定类描述符的类。</p>
<h4 id="private-Object-checkResolve-Object-obj"><a href="#private-Object-checkResolve-Object-obj" class="headerlink" title="private Object checkResolve(Object obj)"></a>private Object checkResolve(Object obj)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">checkResolve</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!enableResolve || handles.lookupException(passHandle) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    Object rep = resolveObject(obj);</span><br><span class="line">    <span class="keyword">if</span> (rep != obj) &#123;</span><br><span class="line">        handles.setObject(passHandle, rep);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在必要时执行对象替换。通过<strong>enableResolveObject(boolean enable)</strong>在初始化ObjectInputStream之后调用设置enableResolve的值。resolveObject(Object obj)方法没有对入参做任何处理，直接返回。第6 ~ 8行代码判断被替换后的对象是否和替换前一直，如果不一致，则用替换后的对象和passHandle建立映射关系，最后会直接返回被替换后的对象。</p>
<h4 id="protected-Object-resolveObject-Object-obj"><a href="#protected-Object-resolveObject-Object-obj" class="headerlink" title="protected Object resolveObject(Object obj)"></a>protected Object resolveObject(Object obj)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">resolveObject</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个方法提供给被ObjectInputStream信任的子类在反序列化过程中完成对象替换。通过方法<strong>enableResolveObject(boolean enable)</strong>可以得到子类是否能被ObjectInputStream信任。这个方法在对象读取后readObject()方法前被调用处理。默认方法的话直接返回不做任何处理。</p>
<h4 id="private-IOException-readFatalException"><a href="#private-IOException-readFatalException" class="headerlink" title="private IOException readFatalException()"></a>private IOException readFatalException()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> IOException <span class="title">readFatalException</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bin.readByte() != TC_EXCEPTION) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">    &#125;</span><br><span class="line">    clear();</span><br><span class="line">    <span class="keyword">return</span> (IOException) readObject0(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;读取并返回导致序列化操作取消的IOException。如果当前读到的不是一个TC_EXCEPTION标识，那么抛出异常。之后执行清空操作，清除所有内部数据结构。最后返回读取到的异常。</p>
<h4 id="private-String-readString-boolean-unshared"><a href="#private-String-readString-boolean-unshared" class="headerlink" title="private String readString(boolean unshared)"></a>private String readString(boolean unshared)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">readString</span><span class="params">(<span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String str;</span><br><span class="line">    <span class="keyword">byte</span> tc = bin.readByte();</span><br><span class="line">    <span class="keyword">switch</span> (tc) &#123;</span><br><span class="line">        <span class="keyword">case</span> TC_STRING:</span><br><span class="line">            str = bin.readUTF();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> TC_LONGSTRING:</span><br><span class="line">            str = bin.readLongUTF();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StreamCorruptedException(</span><br><span class="line">                String.format(<span class="string">"invalid type code: %02X"</span>, tc));</span><br><span class="line">    &#125;</span><br><span class="line">    passHandle = handles.assign(unshared ? unsharedMarker : str);</span><br><span class="line">    handles.finish(passHandle);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;读取并返回一个String。根据读取到的TC标记选择readUTF()或者readLongUTF()方法完成字符串读取。TC_STRING和TC_LONGSTRING由对应的writeString确定，根据字符串Unicode值是否小于等于0xFFFF来决定写入TC_STRING（&lt;= 0xFFFF）还是TC_LONGSTRING（&gt; 0xFFFF）。如果不是上述两种标识，那么就抛出异常。</p>
<p>&emsp;&emsp;然后建立passHandle句柄和读取到的字符串对象的映射关系。最后返回读取到的字符串。</p>
<h4 id="private-Object-readArray-boolean-unshared"><a href="#private-Object-readArray-boolean-unshared" class="headerlink" title="private Object readArray(boolean unshared)"></a>private Object readArray(boolean unshared)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readArray</span><span class="params">(<span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bin.readByte() != TC_ARRAY) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ObjectStreamClass desc = readClassDesc(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">int</span> len = bin.readInt();</span><br><span class="line"></span><br><span class="line">    Object array = <span class="keyword">null</span>;</span><br><span class="line">    Class cl, ccl = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> ((cl = desc.forClass()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ccl = cl.getComponentType();</span><br><span class="line">        array = Array.newInstance(ccl, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> arrayHandle = handles.assign(unshared ? unsharedMarker : array);</span><br><span class="line">    ClassNotFoundException resolveEx = desc.getResolveException();</span><br><span class="line">    <span class="keyword">if</span> (resolveEx != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handles.markException(arrayHandle, resolveEx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ccl == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            readObject0(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ccl.isPrimitive()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ccl == Integer.TYPE) &#123;</span><br><span class="line">            bin.readInts((<span class="keyword">int</span>[]) array, <span class="number">0</span>, len);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ccl == Byte.TYPE) &#123;</span><br><span class="line">            bin.readFully((<span class="keyword">byte</span>[]) array, <span class="number">0</span>, len, <span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ccl == Long.TYPE) &#123;</span><br><span class="line">            bin.readLongs((<span class="keyword">long</span>[]) array, <span class="number">0</span>, len);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ccl == Float.TYPE) &#123;</span><br><span class="line">            bin.readFloats((<span class="keyword">float</span>[]) array, <span class="number">0</span>, len);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ccl == Double.TYPE) &#123;</span><br><span class="line">            bin.readDoubles((<span class="keyword">double</span>[]) array, <span class="number">0</span>, len);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ccl == Short.TYPE) &#123;</span><br><span class="line">            bin.readShorts((<span class="keyword">short</span>[]) array, <span class="number">0</span>, len);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ccl == Character.TYPE) &#123;</span><br><span class="line">            bin.readChars((<span class="keyword">char</span>[]) array, <span class="number">0</span>, len);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ccl == Boolean.TYPE) &#123;</span><br><span class="line">            bin.readBooleans((<span class="keyword">boolean</span>[]) array, <span class="number">0</span>, len);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Object[] oa = (Object[]) array;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            oa[i] = readObject0(<span class="keyword">false</span>);</span><br><span class="line">            handles.markDependency(arrayHandle, passHandle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handles.finish(arrayHandle);</span><br><span class="line">    passHandle = arrayHandle;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;读取并返回一个array数组。如果当前读到的不是一个TC_ARRAY标识，那么抛出异常。第6行代码得到数组类的类描述符，并读取数组的长度大小。第9 ~ 14行代码获取到数组的类型信息，以及数组元素的类型信息，通过Array.newInstance(Class&lt;?&gt; componentType, int length)方法初始化一个数组对象。</p>
<p>&emsp;&emsp;第16 ~ 20行代码判断在当前写入和读取过程中是否出现了异常，如果有异常的话需要将passHandle和异常信息建立映射。第22 ~ 25行代码可能由于cl不是一个数组类，所以ccl为空，那么逐个获取长度为len的元素对象集合。如果数组元素类型为基本数据类型，那么就分类型从流中取数据填充到数组array中（即第26 ~ 45行代码）。如果数组元素为对象类型，那么递归调用readObject0()方法完成数组的填充。最后返回读取到的数据数据。</p>
<h4 id="private-Enum-readEnum-boolean-unshared"><a href="#private-Enum-readEnum-boolean-unshared" class="headerlink" title="private Enum readEnum(boolean unshared)"></a>private Enum readEnum(boolean unshared)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Enum <span class="title">readEnum</span><span class="params">(<span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bin.readByte() != TC_ENUM) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ObjectStreamClass desc = readClassDesc(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (!desc.isEnum()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidClassException(<span class="string">"non-enum class: "</span> + desc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> enumHandle = handles.assign(unshared ? unsharedMarker : <span class="keyword">null</span>);</span><br><span class="line">    ClassNotFoundException resolveEx = desc.getResolveException();</span><br><span class="line">    <span class="keyword">if</span> (resolveEx != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handles.markException(enumHandle, resolveEx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String name = readString(<span class="keyword">false</span>);</span><br><span class="line">    Enum en = <span class="keyword">null</span>;</span><br><span class="line">    Class cl = desc.forClass();</span><br><span class="line">    <span class="keyword">if</span> (cl != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            en = Enum.valueOf(cl, name);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (IOException) <span class="keyword">new</span> InvalidObjectException(<span class="string">"enum constant "</span></span><br><span class="line">                                                           + name + <span class="string">" does not exist in "</span> + cl).initCause(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!unshared) &#123;</span><br><span class="line">            handles.setObject(enumHandle, en);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handles.finish(enumHandle);</span><br><span class="line">    passHandle = enumHandle;</span><br><span class="line">    <span class="keyword">return</span> en;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;读取并返回枚举常量。如果当前读到的不是一个TC_ENUM标识，那么抛出异常。通过<strong>readClassDesc(boolean unshared)</strong>方法获取到类描述符，如果类描述符不是枚举类型，那么抛出异常。之后检查在恢复本地类时是否出现了异常，如果有异常需要建立句柄和异常的映射关系。</p>
<p>&emsp;&emsp;通过readString（boolean unshared)读取枚举类型的名字。然后在第22行代码会初始化一个Enum对象，之后更新passHandle的值并返回初始化的枚举对象。</p>
<h4 id="private-Object-readOrdinaryObject-boolean-unshared"><a href="#private-Object-readOrdinaryObject-boolean-unshared" class="headerlink" title="private Object readOrdinaryObject(boolean unshared)"></a>private Object readOrdinaryObject(boolean unshared)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readOrdinaryObject</span><span class="params">(<span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bin.readByte() != TC_OBJECT) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ObjectStreamClass desc = readClassDesc(<span class="keyword">false</span>);</span><br><span class="line">    desc.checkDeserialize();</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; cl = desc.forClass();</span><br><span class="line">    <span class="keyword">if</span> (cl == String.class || cl == Class.class</span><br><span class="line">        || cl == ObjectStreamClass.class) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidClassException(<span class="string">"invalid class descriptor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object obj;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        obj = desc.isInstantiable() ? desc.newInstance() : <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (IOException) <span class="keyword">new</span> InvalidClassException(desc.forClass()</span><br><span class="line">                                                      .getName(), <span class="string">"unable to create instance"</span>).initCause(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    passHandle = handles.assign(unshared ? unsharedMarker : obj);</span><br><span class="line">    ClassNotFoundException resolveEx = desc.getResolveException();</span><br><span class="line">    <span class="keyword">if</span> (resolveEx != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handles.markException(passHandle, resolveEx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (desc.isExternalizable()) &#123;</span><br><span class="line">        readExternalData((Externalizable) obj, desc);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        readSerialData(obj, desc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handles.finish(passHandle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="keyword">null</span> &amp;&amp; handles.lookupException(passHandle) == <span class="keyword">null</span></span><br><span class="line">        &amp;&amp; desc.hasReadResolveMethod()) &#123;</span><br><span class="line">        Object rep = desc.invokeReadResolve(obj);</span><br><span class="line">        <span class="keyword">if</span> (unshared &amp;&amp; rep.getClass().isArray()) &#123;</span><br><span class="line">            rep = cloneArray(rep);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rep != obj) &#123;</span><br><span class="line">            handles.setObject(passHandle, obj = rep);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;读取并返回一个自定义普通对象。如果对象类无法解析，返回一个null。如果当前读到的不是一个TC_OBJECT标识，那么抛出异常。调用<strong>readClassDesc(boolean unshared)</strong>方法完成类描述符的读取操作，如果该类被禁止反序列化，那么抛出<strong>InvalidClassException</strong>异常。第9 ~ 14行代码检查对象的类型，对象类型不应该为String，class，ObjectStreamClass等类，如果是的话就抛出异常。</p>
<p>&emsp;&emsp;第15 ~21行代码实例化一个Object对象，如果对象可以实例化，就完成实例化，否则对象被指定为null。第23 ~ 27行代码检查在转换本地类的过程中是否存在异常，如果有异常需要对异常进行记录处理。如果对象继承的接口是<strong>Externalizable</strong>那么就调用<strong>readExternalData(Externalizable obj, ObjectStreamClass desc)</strong>完成操作，否则就调用<strong>readSerialData(Object obj, ObjectStreamClass desc)</strong>完成操作。</p>
<p>&emsp;&emsp;如果当前已经实例化的对象存在替换对象，首先根据实例化的对象得到其对应的替换对象，如果替换对象的类型是数组，那么就执行数组克隆操作。用替换后的对象替换实例化对象并缓存起来。最后返回实例化的对象。</p>
<h4 id="private-static-Object-cloneArray-Object-array"><a href="#private-static-Object-cloneArray-Object-array" class="headerlink" title="private static Object cloneArray(Object array)"></a>private static Object cloneArray(Object array)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">cloneArray</span><span class="params">(Object array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array <span class="keyword">instanceof</span> Object[]) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((Object[]) array).clone();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array <span class="keyword">instanceof</span> <span class="keyword">boolean</span>[]) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">boolean</span>[]) array).clone();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array <span class="keyword">instanceof</span> <span class="keyword">byte</span>[]) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">byte</span>[]) array).clone();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array <span class="keyword">instanceof</span> <span class="keyword">char</span>[]) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">char</span>[]) array).clone();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array <span class="keyword">instanceof</span> <span class="keyword">double</span>[]) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">double</span>[]) array).clone();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array <span class="keyword">instanceof</span> <span class="keyword">float</span>[]) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">float</span>[]) array).clone();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array <span class="keyword">instanceof</span> <span class="keyword">int</span>[]) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">int</span>[]) array).clone();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array <span class="keyword">instanceof</span> <span class="keyword">long</span>[]) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">long</span>[]) array).clone();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array <span class="keyword">instanceof</span> <span class="keyword">short</span>[]) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">short</span>[]) array).clone();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在使用非共享读取场景中克隆一个数组。</p>
<h4 id="private-void-readExternalData-Externalizable-obj-ObjectStreamClass-desc"><a href="#private-void-readExternalData-Externalizable-obj-ObjectStreamClass-desc" class="headerlink" title="private void readExternalData(Externalizable obj, ObjectStreamClass desc)"></a>private void readExternalData(Externalizable obj, ObjectStreamClass desc)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readExternalData</span><span class="params">(Externalizable obj, ObjectStreamClass desc)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SerialCallbackContext oldContext = curContext;</span><br><span class="line">    curContext = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> blocked = desc.hasBlockExternalData();</span><br><span class="line">        <span class="keyword">if</span> (blocked) &#123;</span><br><span class="line">            bin.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                obj.readExternal(<span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * In most cases, the handle table has already propagated</span></span><br><span class="line"><span class="comment">                     * a CNFException to passHandle at this point; this mark</span></span><br><span class="line"><span class="comment">                     * call is included to address cases where the readExternal</span></span><br><span class="line"><span class="comment">                     * method has cons'ed and thrown a new CNFException of its</span></span><br><span class="line"><span class="comment">                     * own.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                handles.markException(passHandle, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (blocked) &#123;</span><br><span class="line">            skipCustomData();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        curContext = oldContext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * At this point, if the externalizable data was not written in</span></span><br><span class="line"><span class="comment">         * block-data form and either the externalizable class doesn't exist</span></span><br><span class="line"><span class="comment">         * locally (i.e., obj == null) or readExternal() just threw a</span></span><br><span class="line"><span class="comment">         * CNFException, then the stream is probably in an inconsistent state,</span></span><br><span class="line"><span class="comment">         * since some (or all) of the externalizable data may not have been</span></span><br><span class="line"><span class="comment">         * consumed.  Since there's no "correct" action to take in this case,</span></span><br><span class="line"><span class="comment">         * we mimic the behavior of past serialization implementations and</span></span><br><span class="line"><span class="comment">         * blindly hope that the stream is in sync; if it isn't and additional</span></span><br><span class="line"><span class="comment">         * externalizable data remains in the stream, a subsequent read will</span></span><br><span class="line"><span class="comment">         * most likely throw a StreamCorruptedException.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果obj非空，那么尝试通过readExternal()方法读取externalizable数据。</p>
<h4 id="private-void-readSerialData-Object-obj-ObjectStreamClass-desc"><a href="#private-void-readSerialData-Object-obj-ObjectStreamClass-desc" class="headerlink" title="private void readSerialData(Object obj, ObjectStreamClass desc)"></a>private void readSerialData(Object obj, ObjectStreamClass desc)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readSerialData</span><span class="params">(Object obj, ObjectStreamClass desc)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; slots.length; i++) &#123;</span><br><span class="line">        ObjectStreamClass slotDesc = slots[i].desc;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (slots[i].hasData) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obj != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                slotDesc.hasReadObjectMethod() &amp;&amp;</span><br><span class="line">                handles.lookupException(passHandle) == <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                SerialCallbackContext oldContext = curContext;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    curContext = <span class="keyword">new</span> SerialCallbackContext(obj, slotDesc);</span><br><span class="line"></span><br><span class="line">                    bin.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">                    slotDesc.invokeReadObject(obj, <span class="keyword">this</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         * In most cases, the handle table has already</span></span><br><span class="line"><span class="comment">                         * propagated a CNFException to passHandle at this</span></span><br><span class="line"><span class="comment">                         * point; this mark call is included to address cases</span></span><br><span class="line"><span class="comment">                         * where the custom readObject method has cons'ed and</span></span><br><span class="line"><span class="comment">                         * thrown a new CNFException of its own.</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                    handles.markException(passHandle, ex);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    curContext.setUsed();</span><br><span class="line">                    curContext = oldContext;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * defaultDataEnd may have been set indirectly by custom</span></span><br><span class="line"><span class="comment">                     * readObject() method when calling defaultReadObject() or</span></span><br><span class="line"><span class="comment">                     * readFields(); clear it to restore normal read behavior.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                defaultDataEnd = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                defaultReadFields(obj, slotDesc);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (slotDesc.hasWriteObjectData()) &#123;</span><br><span class="line">                skipCustomData();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                bin.setBlockDataMode(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (obj != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                slotDesc.hasReadObjectNoDataMethod() &amp;&amp;</span><br><span class="line">                handles.lookupException(passHandle) == <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                slotDesc.invokeReadObjectNoData(obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从流中读取每个实现了serializable接口的对象的实例化数据（从父类到子类全部）。第3行代码返回了类描述符desc指定的序列化的对象的数据层次（从父类开始）。遍历这些数据层次对象，如果obj有效，且数据层次有方法<strong>readObject</strong>且当前不存在异常，那么第18行代码就通过调用类的readObject方法来完成反序列化操作。如果数据层次无数据，那么第49行代码就通过调用类的readObjectNoData方法来完成反序列化操作。</p>
<h4 id="public-Object-readUnshared"><a href="#public-Object-readUnshared" class="headerlink" title="public Object readUnshared()"></a>public Object readUnshared()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">readUnshared</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// if nested read, passHandle contains handle of enclosing object</span></span><br><span class="line">    <span class="keyword">int</span> outerHandle = passHandle;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object obj = readObject0(<span class="keyword">true</span>);</span><br><span class="line">        handles.markDependency(outerHandle, passHandle);</span><br><span class="line">        ClassNotFoundException ex = handles.lookupException(passHandle);</span><br><span class="line">        <span class="keyword">if</span> (ex != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (depth == <span class="number">0</span>) &#123;</span><br><span class="line">            vlist.doCallbacks();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        passHandle = outerHandle;</span><br><span class="line">        <span class="keyword">if</span> (closed &amp;&amp; depth == <span class="number">0</span>) &#123;</span><br><span class="line">            clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从ObjectInputStream中读取含有私有类或者包内私有类的对象。这个方法被用在“保护不共享的反序列对象”场景中。如果一个类含有私有类的，或者包内私有类的对象引用字段，并且这些私有类或者包内私有类在当前类外（包外）不可用，那么这些引用对象需要作为反序列化过程的一部分来执行保护性复制（defensively copied）。或者通过调用ObjectOutputStream.writeUnshared 和ObjectInputStream.readUnshared保证内部对象的唯一引用。</p>
<p>&emsp;&emsp;在复制策略中，从流中反序列化得到的子类被认为是不信任的输入 — 新创建的、反序列化之后拥有相同值的子对象应该被根据readObject方法得到的子对象替换掉。这么做是为了适应如下场景：一个不可变的对象包含了一个可变的内部私有的子类引用。如果在反序列一个容器对象的过程中没有特殊的处理来应对子类复制，那么可能在通过向序列化流写入数据过程中夹杂着可能会违反容器类的不可变性的恶意执行。</p>
<h4 id="public-void-defaultReadObject"><a href="#public-void-defaultReadObject" class="headerlink" title="public void defaultReadObject()"></a>public void defaultReadObject()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">defaultReadObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    SerialCallbackContext ctx = curContext;</span><br><span class="line">    <span class="keyword">if</span> (ctx == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotActiveException(<span class="string">"not in call to readObject"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Object curObj = ctx.getObj();</span><br><span class="line">    ObjectStreamClass curDesc = ctx.getDesc();</span><br><span class="line">    bin.setBlockDataMode(<span class="keyword">false</span>);</span><br><span class="line">    defaultReadFields(curObj, curDesc);</span><br><span class="line">    bin.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (!curDesc.hasWriteObjectData()) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Fix for 4360508: since stream does not contain terminating</span></span><br><span class="line"><span class="comment">             * TC_ENDBLOCKDATA tag, set flag so that reading code elsewhere</span></span><br><span class="line"><span class="comment">             * knows to simulate end-of-custom-data behavior.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        defaultDataEnd = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ClassNotFoundException ex = handles.lookupException(passHandle);</span><br><span class="line">    <span class="keyword">if</span> (ex != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从流中读取非static、transient关键字修饰的内容。ObjectInputStream自身没有调用该方法，该方法被需要反序列化的类的readObject方法调用。通过<strong>defaultReadFields(Object obj, ObjectStreamClass desc)</strong>方法完成反序列内容的读取。</p>
<h4 id="private-void-defaultReadFields-Object-obj-ObjectStreamClass-desc"><a href="#private-void-defaultReadFields-Object-obj-ObjectStreamClass-desc" class="headerlink" title="private void defaultReadFields(Object obj, ObjectStreamClass desc)"></a>private void defaultReadFields(Object obj, ObjectStreamClass desc)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">defaultReadFields</span><span class="params">(Object obj, ObjectStreamClass desc)</span> </span></span><br><span class="line"><span class="function">    	<span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Class cl = desc.forClass();</span><br><span class="line">    <span class="keyword">if</span> (cl != <span class="keyword">null</span> &amp;&amp; obj != <span class="keyword">null</span> &amp;&amp; !cl.isInstance(obj)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> primDataSize = desc.getPrimDataSize();</span><br><span class="line">    <span class="keyword">if</span> (primVals == <span class="keyword">null</span> || primVals.length &lt; primDataSize) &#123;</span><br><span class="line">        primVals = <span class="keyword">new</span> <span class="keyword">byte</span>[primDataSize];</span><br><span class="line">    &#125;</span><br><span class="line">    bin.readFully(primVals, <span class="number">0</span>, primDataSize, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123;</span><br><span class="line">        desc.setPrimFieldValues(obj, primVals);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> objHandle = passHandle;</span><br><span class="line">    ObjectStreamField[] fields = desc.getFields(<span class="keyword">false</span>);</span><br><span class="line">    Object[] objVals = <span class="keyword">new</span> Object[desc.getNumObjFields()];</span><br><span class="line">    <span class="keyword">int</span> numPrimFields = fields.length - objVals.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objVals.length; i++) &#123;</span><br><span class="line">        ObjectStreamField f = fields[numPrimFields + i];</span><br><span class="line">        objVals[i] = readObject0(f.isUnshared());</span><br><span class="line">        <span class="keyword">if</span> (f.getField() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            handles.markDependency(objHandle, passHandle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123;</span><br><span class="line">        desc.setObjFieldValues(obj, objVals);</span><br><span class="line">    &#125;</span><br><span class="line">    passHandle = objHandle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;根据指定类描述符读取被序列化了的字段的内容。第3 ~ 6行代码得到需要反序列的对象的类信息。第8 ~ 15行代码得到对象中基础数据类型字段的数量和字段存储的具体值内容。第18行代码得到对象的所有字段，第19行代码得到对象的非基础数据类型的字段变量内容。第20 ~ 27行代码取得所有非基础数据类型字段存储的值内容。第28 ~ 30行代码完成字段赋值操作。最后更新passHandle。</p>
<h4 id="public-ObjectInputStream-GetField-readFields"><a href="#public-ObjectInputStream-GetField-readFields" class="headerlink" title="public ObjectInputStream.GetField readFields()"></a>public ObjectInputStream.GetField readFields()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ObjectInputStream.<span class="function">GetField <span class="title">readFields</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    SerialCallbackContext ctx = curContext;</span><br><span class="line">    <span class="keyword">if</span> (ctx == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotActiveException(<span class="string">"not in call to readObject"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Object curObj = ctx.getObj();</span><br><span class="line">    ObjectStreamClass curDesc = ctx.getDesc();</span><br><span class="line">    bin.setBlockDataMode(<span class="keyword">false</span>);</span><br><span class="line">    GetFieldImpl getField = <span class="keyword">new</span> GetFieldImpl(curDesc);</span><br><span class="line">    getField.readFields();</span><br><span class="line">    bin.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (!curDesc.hasWriteObjectData()) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Fix for 4360508: since stream does not contain terminating</span></span><br><span class="line"><span class="comment">             * TC_ENDBLOCKDATA tag, set flag so that reading code elsewhere</span></span><br><span class="line"><span class="comment">             * knows to simulate end-of-custom-data behavior.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        defaultDataEnd = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> getField;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从流中读取字段变量值（基础数据类型和对象类型），并返回一个GetField实例。</p>
<h4 id="public-void-registerValidation-ObjectInputValidation-obj-int-prio"><a href="#public-void-registerValidation-ObjectInputValidation-obj-int-prio" class="headerlink" title="public void registerValidation(ObjectInputValidation obj, int prio)"></a>public void registerValidation(ObjectInputValidation obj, int prio)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerValidation</span><span class="params">(ObjectInputValidation obj, <span class="keyword">int</span> prio)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NotActiveException, InvalidObjectException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotActiveException(<span class="string">"stream inactive"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vlist.register(obj, prio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="protected-boolean-enableResolveObject-boolean-enable"><a href="#protected-boolean-enableResolveObject-boolean-enable" class="headerlink" title="protected boolean enableResolveObject(boolean enable)"></a>protected boolean enableResolveObject(boolean enable)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">enableResolveObject</span><span class="params">(<span class="keyword">boolean</span> enable)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> SecurityException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (enable == enableResolve) &#123;</span><br><span class="line">        <span class="keyword">return</span> enable;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (enable) &#123;</span><br><span class="line">        SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sm.checkPermission(SUBSTITUTION_PERMISSION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enableResolve = enable;</span><br><span class="line">    <span class="keyword">return</span> !enableResolve;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="public-int-read"><a href="#public-int-read" class="headerlink" title="public int read()"></a>public int read()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bin.read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="String-readTypeString"><a href="#String-readTypeString" class="headerlink" title="String readTypeString()"></a>String readTypeString()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">readTypeString</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldHandle = passHandle;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">byte</span> tc = bin.peekByte();</span><br><span class="line">        <span class="keyword">switch</span> (tc) &#123;</span><br><span class="line">            <span class="keyword">case</span> TC_NULL:</span><br><span class="line">                <span class="keyword">return</span> (String) readNull();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_REFERENCE:</span><br><span class="line">                <span class="keyword">return</span> (String) readHandle(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_STRING:</span><br><span class="line">            <span class="keyword">case</span> TC_LONGSTRING:</span><br><span class="line">                <span class="keyword">return</span> readString(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> StreamCorruptedException(</span><br><span class="line">                    String.format(<span class="string">"invalid type code: %02X"</span>, tc));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        passHandle = oldHandle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;读取一个字符串且不允许被替换。在ObjectStreamClass.read()方法中被调用。</p>
<h4 id="private-boolean-isCustomSubclass"><a href="#private-boolean-isCustomSubclass" class="headerlink" title="private boolean isCustomSubclass()"></a>private boolean isCustomSubclass()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isCustomSubclass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Return true if this class is a custom subclass of ObjectInputStream</span></span><br><span class="line">    <span class="keyword">return</span> getClass().getClassLoader() != ObjectInputStream.class.getClassLoader();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果当前类是ObjectInputStream的一个定制子类实现，那么返回true。</p>
<h4 id="private-static-native-void-bytesToFloats-byte-src-int-srcpos-float-dst-int-dstpos-int-nfloats"><a href="#private-static-native-void-bytesToFloats-byte-src-int-srcpos-float-dst-int-dstpos-int-nfloats" class="headerlink" title="private static native void bytesToFloats(byte[] src, int srcpos, float[] dst, int dstpos, int nfloats);"></a>private static native void bytesToFloats(byte[] src, int srcpos, float[] dst, int dstpos, int nfloats);</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">bytesToFloats</span><span class="params">(<span class="keyword">byte</span>[] src, <span class="keyword">int</span> srcpos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">float</span>[] dst, <span class="keyword">int</span> dstpos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">int</span> nfloats)</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;完成byte向float的转换。native方法，由系统提供并完成处理。</p>
<h4 id="private-static-native-void-bytesToDoubles-byte-src-int-srcpos-double-dst-int-dstpos-int-ndoubles"><a href="#private-static-native-void-bytesToDoubles-byte-src-int-srcpos-double-dst-int-dstpos-int-ndoubles" class="headerlink" title="private static native void bytesToDoubles(byte[] src, int srcpos, double[] dst, int dstpos, int ndoubles);"></a>private static native void bytesToDoubles(byte[] src, int srcpos, double[] dst, int dstpos, int ndoubles);</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">bytesToDoubles</span><span class="params">(<span class="keyword">byte</span>[] src, <span class="keyword">int</span> srcpos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              <span class="keyword">double</span>[] dst, <span class="keyword">int</span> dstpos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              <span class="keyword">int</span> ndoubles)</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;完成byte向double的转换。native方法，由系统提供并完成处理。</p>
<p>&emsp;</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li><strong>Graphs of objects are restored correctly using a reference sharing mechanism.  </strong></li>
</ol>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://blog.csdn.net/kagoy/article/details/12000253" target="_blank" rel="noopener">https://blog.csdn.net/kagoy/article/details/12000253</a></li>
<li><a href="https://blog.csdn.net/abc123lzf/article/details/82318148" target="_blank" rel="noopener">https://blog.csdn.net/abc123lzf/article/details/82318148</a></li>
<li><a href="https://www.hollischuang.com/archives/1140" target="_blank" rel="noopener">https://www.hollischuang.com/archives/1140</a></li>
<li><a href="https://yq.aliyun.com/articles/646150" target="_blank" rel="noopener">https://yq.aliyun.com/articles/646150</a></li>
<li><a href="http://www.voidcn.com/article/p-xjvhzlxn-nx.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-xjvhzlxn-nx.html</a></li>
<li><a href="https://blog.csdn.net/abc123lzf/article/details/82318148" target="_blank" rel="noopener">https://blog.csdn.net/abc123lzf/article/details/82318148</a></li>
<li><a href="http://www.bubuko.com/infodetail-2129058.html" target="_blank" rel="noopener">http://www.bubuko.com/infodetail-2129058.html</a></li>
<li><a href="https://blog.csdn.net/shenchaohao12321/article/details/79521774" target="_blank" rel="noopener">https://blog.csdn.net/shenchaohao12321/article/details/79521774</a></li>
<li><a href="https://286.iteye.com/blog/2227942" target="_blank" rel="noopener">https://286.iteye.com/blog/2227942</a></li>
<li><a href="https://286.iteye.com/blog/2227950" target="_blank" rel="noopener">https://286.iteye.com/blog/2227950</a></li>
<li><a href="https://xz.aliyun.com/t/2223" target="_blank" rel="noopener">https://xz.aliyun.com/t/2223</a></li>
<li><a href="http://www.importnew.com/24490.html" target="_blank" rel="noopener">http://www.importnew.com/24490.html</a></li>
<li><a href="http://www.importnew.com/20125.html" target="_blank" rel="noopener">http://www.importnew.com/20125.html</a></li>
<li><a href="http://www.importnew.com/17964.html" target="_blank" rel="noopener">http://www.importnew.com/17964.html</a></li>
<li><a href="http://www.importnew.com/18024.html" target="_blank" rel="noopener">http://www.importnew.com/18024.html</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-serial/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-serial/</a></li>
<li>Java Object Serialization Specification 1.6</li>
</ol>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java I/O 07 - PushbackInputStream</title>
    <url>/2018/java-PushbackInputStream.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;关于<em> <strong>java.io.PushbackInputStream</strong> </em>的部分笔记，这个类可以完成对输入流数据的回退操作。也就是说，通过read方法从底层输入流中读出的数据可以在被退回到输入流中，这样下次read方法将会首先读取到被退回到输入流中的数据。本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;PushbackInputStream提供了unread方法来将已经从底层输入流中读出的字节数据再回退到输入流中，实现回退（push back）或者再读（re-read）操作。在调用unread方法后再次调用read方法时，获取的将会是被回退的数据，直到回退的数据被读取完毕，才会获取到新的输入流数据。</p>
<p>&emsp;</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PushbackInputStream</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.io.InputStream</span><br><span class="line">    --java.io.FilterInputStream</span><br><span class="line">      --java.io.PushbackInputStream</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类名</th>
<th style="text-align:center">实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PushbackInputStream</td>
<td style="text-align:center">Closeable,, AutoCloseable</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h2><h4 id="public-int-read"><a href="#public-int-read" class="headerlink" title="public int read()"></a>public int read()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ensureOpen();</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; buf.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> buf[pos++] &amp; <span class="number">0xff</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;读取一个字节数据并返回。因为在设计时，如果缓冲区数组buf是空的，那么pos的值等于buf的长度，所以如果第3行的判断满足，那么直接返回缓冲区数组buf中的下一个字节，此时缓冲区中尚有待读取的数据。否则，缓冲区中的数据已经全被读完，那么直接调用底层输入流的read方法返回一个字节数据。</p>
<h4 id="public-int-read-byte-b-int-off-int-len"><a href="#public-int-read-byte-b-int-off-int-len" class="headerlink" title="public int read(byte[] b, int off, int len)"></a>public int read(byte[] b, int off, int len)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ensureOpen();</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (off &lt; <span class="number">0</span> || len &lt; <span class="number">0</span> || len &gt; b.length - off) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> avail = buf.length - pos;</span><br><span class="line">    <span class="keyword">if</span> (avail &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; avail) &#123;</span><br><span class="line">            avail = len;</span><br><span class="line">        &#125;</span><br><span class="line">        System.arraycopy(buf, pos, b, off, avail);</span><br><span class="line">        pos += avail;</span><br><span class="line">        off += avail;</span><br><span class="line">        len -= avail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        len = <span class="keyword">super</span>.read(b, off, len);</span><br><span class="line">        <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> avail == <span class="number">0</span> ? -<span class="number">1</span> : avail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> avail + len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> avail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;读取数据存储到入参b中。第2行代码用于保证底层输入流可用。第3 ~ 9行代码用于判断各种边界条件和参数校验。第11行代码用来计算缓冲区数组是否还有未读取的数据，如果有，那么第12 ~ 20行代码将首先从缓冲区数组中读取数据。第13 ~ 15行的代码用来判断缓冲区数组的未读取数据量是否满足入参len的需求，如果满足，那么b中的数据将全部来源于缓冲区数组，否则b的数据将从缓冲区数组和底层输入流共同获得。第21 ~ 27行代码会从底层输入流中获取数据。如果未从底层输入流中获得任何数据（即返回-1），那么就根据是否从缓冲区数组中获得了一个及以上字节的数据来判断最终需要返回的已读取字节数。</p>
<h4 id="public-void-unread-int-b"><a href="#public-void-unread-int-b" class="headerlink" title="public void unread(int b)"></a>public void unread(int b)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unread</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ensureOpen();</span><br><span class="line">    <span class="keyword">if</span> (pos == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Push back buffer is full"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    buf[--pos] = (<span class="keyword">byte</span>)b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将已经读取出来的一个字节再退回到输入流中。这里会将入参数据b存储到缓冲区数组buf中，因为PushbackInputStream的read方法都是首先从缓冲区数组中获取数据，所以将b存储到缓冲区数组后，下一次调用read方法将会首先读取到先前存储到缓冲区数组中的数据b。</p>
<h4 id="public-void-unread-byte-b-int-off-int-len"><a href="#public-void-unread-byte-b-int-off-int-len" class="headerlink" title="public void unread(byte[] b, int off, int len)"></a>public void unread(byte[] b, int off, int len)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unread</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ensureOpen();</span><br><span class="line">    <span class="keyword">if</span> (len &gt; pos) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Push back buffer is full"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pos -= len;</span><br><span class="line">    System.arraycopy(b, off, buf, pos, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将数组b的数据回退到输入流中。基本思路和unread(int b)相同，不同的是这里调用了System.arraycopy()方法来完成数组与数组之间的数据复制。</p>
<h4 id="public-void-unread-byte-b"><a href="#public-void-unread-byte-b" class="headerlink" title="public void unread(byte[] b)"></a>public void unread(byte[] b)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unread</span><span class="params">(<span class="keyword">byte</span>[] b)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    unread(b, <span class="number">0</span>, b.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;将数组b的数据回退到输入流中。</p>
<h4 id="public-int-available"><a href="#public-int-available" class="headerlink" title="public int available()"></a>public int available()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">available</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ensureOpen();</span><br><span class="line">    <span class="keyword">int</span> n = buf.length - pos;</span><br><span class="line">    <span class="keyword">int</span> avail = <span class="keyword">super</span>.available();</span><br><span class="line">    <span class="keyword">return</span> n &gt; (Integer.MAX_VALUE - avail)</span><br><span class="line">        ? Integer.MAX_VALUE</span><br><span class="line">        : n + avail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回剩余可读取的字节数。这个结果涵盖了缓冲区数组中的剩余可读取的字节数和底层输入流中剩余刻度的字节数。第5行代码可以理解成如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> (n + avail)&gt; Integer.MAX_VALUE</span><br><span class="line">        ? Integer.MAX_VALUE</span><br><span class="line">        : n + avail;</span><br></pre></td></tr></table></figure>
<h4 id="public-long-skip-long-n"><a href="#public-long-skip-long-n" class="headerlink" title="public long skip(long n)"></a>public long skip(long n)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ensureOpen();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> pskip = buf.length - pos;</span><br><span class="line">    <span class="keyword">if</span> (pskip &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; pskip) &#123;</span><br><span class="line">            pskip = n;</span><br><span class="line">        &#125;</span><br><span class="line">        pos += pskip;</span><br><span class="line">        n -= pskip;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        pskip += <span class="keyword">super</span>.skip(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pskip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;跳过输入流的指定长度的数据内容。在具体执行时，会首先判断缓冲区数组中是否有待读取的数据，如果有，那么会首先跳过缓冲区数组中的内容，第8 ~ 14行代码执行的便是跳过缓冲区数组内容的操作。如果缓冲区数组的内容都已经被跳过，此时缓冲区数组中已经没有待读取的数据了，而实际跳过字节数尚未达到入参n的要求，那么会直接跳过底层输入流中的数据。第15 ~17行代码则是对底层输入流直接处理。最后返回实际跳过的字节数。需要注意的是，在一些比较特殊的场景中，比如在读到文件结束时，整个输入流中已经没有可供跳过的内容了，从而导致实际跳过的字节数可能小于入参n。</p>
<h4 id="public-synchronized-void-close"><a href="#public-synchronized-void-close" class="headerlink" title="public synchronized void close()"></a>public synchronized void close()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (in == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    in.close();</span><br><span class="line">    in = <span class="keyword">null</span>;</span><br><span class="line">    buf = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在结束调用后需要释放底层输入流的占用，同时释放缓冲区数组。</p>
<h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PushbackInputStream不支持标记下一个读取位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">markSupported</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PushbackInputStream的mark方法不做任何事情</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> readlimit)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PushbackInputStream的reset方法不做任何事情，仅发出异常提示信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"mark/reset not supported"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li>NIL</li>
</ol>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>LIUXUN1993728. <a href="https://blog.csdn.net/u013087513/article/details/52171078" target="_blank" rel="noopener">Java IO操作——回退流PushbackInputStream</a> [E]<br>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java I/O 21 - PrintWriter</title>
    <url>/2018/java-PrintWriter.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;关于<em> <strong>java.io.PrintWriter</strong> </em> 的部分笔记，PrintWriter属于处理流的一种，提供了丰富的打印方法用来向目标位置打印输出字符内容。本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;PrintWriter用来向文本输出流打印经过格式化处理的数据。它实现了PrintStream中提及的所有打印方法，且这个类处理的都是字符数据，没有提供对字节数据的处理方法。和PrintStream不同的是，PrintWriter只会在调用了<tt>println</tt>, <tt>printf</tt>, 和<tt>format</tt>方法之后才会自动将数据推送到目标输出位置上（如果autoFlush = true）。而且，换行所用的行分隔符也是基于具体的运行机器的。</p>
<p>&emsp;&emsp;PrintWriter还有一点特殊的地方就是，在调用其他方法都不会抛出I/O异常。如果要确认在调用PrintWriter处理输出数据的过程中是否产生了异常，可以通过调用<code>checkError()</code>进行确认。此这个过程中，如果流还没有关闭，会自动进行flush，同时返回错误状态标识位。</p>
<p>&emsp;</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PrintWriter</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.io.Writer</span><br><span class="line">    --java.io.PrintWriter</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类名</th>
<th style="text-align:center">实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PrintWriter</td>
<td style="text-align:center">Closeable, AutoCloseable,Flushable, Appendable</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="PushbackReader"><a href="#PushbackReader" class="headerlink" title="PushbackReader"></a>PushbackReader</h2><h3 id="Constructor-Summary"><a href="#Constructor-Summary" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="public-PrintWriter-Writer-out-boolean-autoFlush"><a href="#public-PrintWriter-Writer-out-boolean-autoFlush" class="headerlink" title="public PrintWriter(Writer out, boolean autoFlush)"></a>public PrintWriter(Writer out, boolean autoFlush)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span><span class="params">(Writer out, <span class="keyword">boolean</span> autoFlush)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(out);</span><br><span class="line">    <span class="keyword">this</span>.out = out;</span><br><span class="line">    <span class="keyword">this</span>.autoFlush = autoFlush;</span><br><span class="line">    lineSeparator = java.security.AccessController.doPrivileged(</span><br><span class="line">        <span class="keyword">new</span> sun.security.action.GetPropertyAction(<span class="string">"line.separator"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个打印输出流。入参是一个字符输出流和一个是否自动flush的标识位，在完成相关字段的赋值后根据代码运行环境初始化一个适用于当前运行机器环境的行分隔符。</p>
<h4 id="public-PrintWriter-File-file"><a href="#public-PrintWriter-File-file" class="headerlink" title="public PrintWriter(File file)"></a>public PrintWriter(File file)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(file))),</span><br><span class="line">         <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始一个打印输出流。将入参文件转成一个BufferWriter，之后调用构造器<strong>PrintWriter(Writer out, boolean autoFlush)</strong>完成初始化操作。</p>
<h4 id="public-PrintWriter-String-fileName"><a href="#public-PrintWriter-String-fileName" class="headerlink" title="public PrintWriter(String fileName)"></a>public PrintWriter(String fileName)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(fileName))),</span><br><span class="line">         <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始一个打印输出流。将入参文件路径字符串转成一个含有文件字节输出流的BufferWriter，之后调用构造器<strong>PrintWriter(Writer out, boolean autoFlush)</strong>完成初始化操作。</p>
<h4 id="public-PrintWriter-Writer-out"><a href="#public-PrintWriter-Writer-out" class="headerlink" title="public PrintWriter (Writer out)"></a>public PrintWriter (Writer out)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span> <span class="params">(Writer out)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(out, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始一个打印输出流。</p>
<h4 id="public-PrintWriter-OutputStream-out-boolean-autoFlush"><a href="#public-PrintWriter-OutputStream-out-boolean-autoFlush" class="headerlink" title="public PrintWriter(OutputStream out, boolean autoFlush)"></a>public PrintWriter(OutputStream out, boolean autoFlush)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span><span class="params">(OutputStream out, <span class="keyword">boolean</span> autoFlush)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(out)), autoFlush);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// save print stream for error propagation</span></span><br><span class="line">    <span class="keyword">if</span> (out <span class="keyword">instanceof</span> java.io.PrintStream) &#123;</span><br><span class="line">        psOut = (PrintStream) out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;依赖已有的字节输出流初始一个字符打印输出流。</p>
<h4 id="public-PrintWriter-OutputStream-out"><a href="#public-PrintWriter-OutputStream-out" class="headerlink" title="public PrintWriter(OutputStream out)"></a>public PrintWriter(OutputStream out)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span><span class="params">(OutputStream out)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(out, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;依赖已有的字节输出流初始一个字符打印输出流。通过调用构造器<strong>PrintWriter(OutputStream out, boolean autoFlush)</strong>完成初始化操作。</p>
<h4 id="private-PrintWriter-Charset-charset-File-file"><a href="#private-PrintWriter-Charset-charset-File-file" class="headerlink" title="private PrintWriter(Charset charset, File file)"></a>private PrintWriter(Charset charset, File file)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">PrintWriter</span><span class="params">(Charset charset, File file)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(file), charset)), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;根据指定的编码字符集和文件对象初始化一个字符打印输出流。私有方法，不对外暴露。</p>
<h4 id="public-PrintWriter-String-fileName-String-csn"><a href="#public-PrintWriter-String-fileName-String-csn" class="headerlink" title="public PrintWriter(String fileName, String csn)"></a>public PrintWriter(String fileName, String csn)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span><span class="params">(String fileName, String csn)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> FileNotFoundException, UnsupportedEncodingException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(toCharset(csn), <span class="keyword">new</span> File(fileName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;根据指定的编码字符集名称和文件路径字符串信息初始化一个字符打印输出流。通过调用构造器<strong>PrintWriter(Charset charset, File file)</strong>完成初始化操作。</p>
<h4 id="public-void-PrintWriter-File-file-String-csn"><a href="#public-void-PrintWriter-File-file-String-csn" class="headerlink" title="public void PrintWriter(File file, String csn)"></a>public void PrintWriter(File file, String csn)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintWriter</span><span class="params">(File file, String csn)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> FileNotFoundException, UnsupportedEncodingException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(toCharset(csn), file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;根据指定的编码字符集名称和文件对象初始化一个字符打印输出流。通过调用构造器<strong>PrintWriter(Charset charset, File file)</strong>完成初始化操作。</p>
<h3 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="private-static-Charset-toCharset-String-csn"><a href="#private-static-Charset-toCharset-String-csn" class="headerlink" title="private static Charset toCharset(String csn)"></a>private static Charset toCharset(String csn)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Charset <span class="title">toCharset</span><span class="params">(String csn)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">    Objects.requireNonNull(csn, <span class="string">"charsetName"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Charset.forName(csn);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalCharsetNameException | UnsupportedCharsetException unused) &#123;</span><br><span class="line">        <span class="comment">// UnsupportedEncodingException should be thrown</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedEncodingException(csn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;根据字符集名称取得对应的字符集Charset对象。</p>
<h4 id="private-void-ensureOpen"><a href="#private-void-ensureOpen" class="headerlink" title="private void ensureOpen()"></a>private void ensureOpen()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureOpen</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (out == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Stream closed"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;检查当前底层输出流是否开启且可用。</p>
<h4 id="public-boolean-checkError"><a href="#public-boolean-checkError" class="headerlink" title="public boolean checkError()"></a>public boolean checkError()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (out != <span class="keyword">null</span>) &#123;</span><br><span class="line">        flush();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (out <span class="keyword">instanceof</span> java.io.PrintWriter) &#123;</span><br><span class="line">        PrintWriter pw = (PrintWriter) out;</span><br><span class="line">        <span class="keyword">return</span> pw.checkError();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (psOut != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> psOut.checkError();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> trouble;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在当前输出流尚未关闭的情况下将当前输出流中的内容推送到目标输出位置，同时返回异常状态标志位。</p>
<h4 id="protected-void-setError"><a href="#protected-void-setError" class="headerlink" title="protected void setError()"></a>protected void setError()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    trouble = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;显示设置异常状态标志位为true。</p>
<h4 id="protected-void-clearError"><a href="#protected-void-clearError" class="headerlink" title="protected void clearError()"></a>protected void clearError()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">clearError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    trouble = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;清除异常状态标志位。</p>
<h4 id="public-void-write-int-c"><a href="#public-void-write-int-c" class="headerlink" title="public void write(int c)"></a>public void write(int c)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            ensureOpen();</span><br><span class="line">            out.write(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InterruptedIOException x) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">        trouble = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;向底层输出流中写入一个字符数据。通过使用synchronized关键字可以保证多线程环境下的线程安全。具体实现则是通过直接调用底层输出流的write()方法来完成写入操作。如果期间出现了IOException，那么异常不返回，设置异常状态标志位为true。</p>
<h4 id="public-void-write-char-buf-int-off-int-len"><a href="#public-void-write-char-buf-int-off-int-len" class="headerlink" title="public void write(char buf[], int off, int len)"></a>public void write(char buf[], int off, int len)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> buf[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            ensureOpen();</span><br><span class="line">            out.write(buf, off, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InterruptedIOException x) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">        trouble = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> buf[])</span> </span>&#123;</span><br><span class="line">    write(buf, <span class="number">0</span>, buf.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;向底层输出流中写入字符数组buf中自off位置起长度为len的内容。通过使用synchronized关键字可以保证多线程环境下的线程安全。具体实现则是通过直接调用底层输出流的write(char[] cbuf, int off, int len)方法来完成写入操作。如果期间出现了IOException，那么异常不返回，设置异常状态标志位为true。</p>
<h4 id="public-void-write-String-s-int-off-int-len"><a href="#public-void-write-String-s-int-off-int-len" class="headerlink" title="public void write(String s, int off, int len)"></a>public void write(String s, int off, int len)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String s, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            ensureOpen();</span><br><span class="line">            out.write(s, off, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InterruptedIOException x) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">        trouble = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    write(s, <span class="number">0</span>, s.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;向底层输出流中写入字符串s中自off位置起长度为len的内容。通过使用synchronized关键字可以保证多线程环境下的线程安全。具体实现则是通过直接调用底层输出流的write(String str, int off, int len)方法来完成写入操作。如果期间出现了IOException，那么异常不返回，设置异常状态标志位为true。</p>
<h4 id="private-void-newLine"><a href="#private-void-newLine" class="headerlink" title="private void newLine()"></a>private void newLine()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">newLine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            ensureOpen();</span><br><span class="line">            out.write(lineSeparator);</span><br><span class="line">            <span class="keyword">if</span> (autoFlush)</span><br><span class="line">                out.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InterruptedIOException x) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">        trouble = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;另起一行写内容。如果设置了自动推送数据，那么就将当前底层输出流中含有的字符数据推送到目标输出位置。</p>
<h4 id="public-void-print-args-…"><a href="#public-void-print-args-…" class="headerlink" title="public void print(args …)"></a>public void print(args …)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印boolean值，如果值为true，那么则打印“true”，否则打印“false”</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    write(b ? <span class="string">"true"</span> : <span class="string">"false"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印一个字符</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    write(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印一个数字</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    write(String.valueOf(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印一个long型数字</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">    write(String.valueOf(l));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印一个单精度浮点数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">float</span> f)</span> </span>&#123;</span><br><span class="line">    write(String.valueOf(f));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印一个双精度浮点数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">    write(String.valueOf(d));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印一个字符数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> s[])</span> </span>&#123;</span><br><span class="line">    write(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印一个字符串，如果入参字符串为null，则打印“null”</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">        s = <span class="string">"null"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    write(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印一个对象obj</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    write(String.valueOf(obj));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="public-void-println-args"><a href="#public-void-println-args" class="headerlink" title="public void println(args..)"></a>public void println(args..)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 换行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    newLine();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印一个boolean值并换行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">boolean</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        print(x);</span><br><span class="line">        println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印一个字符并换行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        print(x);</span><br><span class="line">        println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印一个数字并换行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        print(x);</span><br><span class="line">        println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印一个long型数字并换行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        print(x);</span><br><span class="line">        println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印一个单精度浮点数值并换行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        print(x);</span><br><span class="line">        println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印一个双精度浮点数值并换行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        print(x);</span><br><span class="line">        println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印一个字符数组并换行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">char</span> x[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        print(x);</span><br><span class="line">        println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印一个字符串并换行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        print(x);</span><br><span class="line">        println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印一个对象obj并换行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">    String s = String.valueOf(x);</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        print(s);</span><br><span class="line">        println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="public-PrintWriter-printf-String-format-Object-…-args"><a href="#public-PrintWriter-printf-String-format-Object-…-args" class="headerlink" title="public PrintWriter printf(String format, Object … args)"></a>public PrintWriter printf(String format, Object … args)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PrintWriter <span class="title">printf</span><span class="params">(String format, Object ... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> format(format, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;按照format指定的格式将args中的数据内容打印输出到底层输出流中。实际调用后执行效果同方法<strong>format(String format, Object …  args)</strong>。</p>
<h4 id="public-PrintWriter-format-String-format-Object-…-args"><a href="#public-PrintWriter-format-String-format-Object-…-args" class="headerlink" title="public PrintWriter format(String format, Object … args)"></a>public PrintWriter format(String format, Object … args)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PrintWriter <span class="title">format</span><span class="params">(String format, Object ... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            ensureOpen();</span><br><span class="line">            <span class="keyword">if</span> ((formatter == <span class="keyword">null</span>)</span><br><span class="line">                || (formatter.locale() != Locale.getDefault()))</span><br><span class="line">                formatter = <span class="keyword">new</span> Formatter(<span class="keyword">this</span>);</span><br><span class="line">            formatter.format(Locale.getDefault(), format, args);</span><br><span class="line">            <span class="keyword">if</span> (autoFlush)</span><br><span class="line">                out.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedIOException x) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">        trouble = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;按照format指定的格式将args中带有的内容打印输出到底层输出流中。在根据格式进行内容拼装时采用的运行机器默认的语言环境（Locale）。如果允许自动推送数据，那么就将当前底层输出流中含有的字符数据推送到目标输出位置。</p>
<h4 id="public-PrintWriter-printf-Locale-l-String-format-Object-…-args"><a href="#public-PrintWriter-printf-Locale-l-String-format-Object-…-args" class="headerlink" title="public PrintWriter printf(Locale l, String format, Object … args)"></a>public PrintWriter printf(Locale l, String format, Object … args)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PrintWriter <span class="title">printf</span><span class="params">(Locale l, String format, Object ... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> format(l, format, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;按照format指定的格式、Locale指定的语言环境将args中的数据内容打印输出到底层输出流中。实际调用后执行效果同方法<strong>format(Locale l, String format, Object …  args)</strong>。</p>
<h4 id="public-PrintWriter-format-Locale-l-String-format-Object-…-args"><a href="#public-PrintWriter-format-Locale-l-String-format-Object-…-args" class="headerlink" title="public PrintWriter format(Locale l, String format, Object … args)"></a>public PrintWriter format(Locale l, String format, Object … args)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PrintWriter <span class="title">format</span><span class="params">(Locale l, String format, Object ... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            ensureOpen();</span><br><span class="line">            <span class="keyword">if</span> ((formatter == <span class="keyword">null</span>) || (formatter.locale() != l))</span><br><span class="line">                formatter = <span class="keyword">new</span> Formatter(<span class="keyword">this</span>, l);</span><br><span class="line">            formatter.format(l, format, args);</span><br><span class="line">            <span class="keyword">if</span> (autoFlush)</span><br><span class="line">                out.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedIOException x) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">        trouble = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;按照format指定的格式、Locale指定的语言环境将args中带有的内容打印输出到底层输出流中。在根据格式进行内容拼装时采用的运行机器默认的语言环境（Locale）。如果允许自动推送数据，那么就将当前底层输出流中含有的字符数据推送到目标输出位置。</p>
<h4 id="public-PrintWriter-append-CharSequence-csq"><a href="#public-PrintWriter-append-CharSequence-csq" class="headerlink" title="public PrintWriter append(CharSequence csq)"></a>public PrintWriter append(CharSequence csq)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PrintWriter <span class="title">append</span><span class="params">(CharSequence csq)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (csq == <span class="keyword">null</span>)</span><br><span class="line">        write(<span class="string">"null"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        write(csq.toString());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将CharSequence对象中含有的内容追加输出到底层输出流中。实际调用后执行效果同方法<strong>write(String s)</strong>。</p>
<h4 id="public-PrintWriter-append-CharSequence-csq-int-start-int-end"><a href="#public-PrintWriter-append-CharSequence-csq-int-start-int-end" class="headerlink" title="public PrintWriter append(CharSequence csq, int start, int end)"></a>public PrintWriter append(CharSequence csq, int start, int end)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PrintWriter <span class="title">append</span><span class="params">(CharSequence csq, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    CharSequence cs = (csq == <span class="keyword">null</span> ? <span class="string">"null"</span> : csq);</span><br><span class="line">    write(cs.subSequence(start, end).toString());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将CharSequence对象中自start至end之间的内容追加输出到底层输出流中。实际调用后执行效果同方法<strong>write(String s)</strong>。</p>
<h4 id="public-PrintWriter-append-char-c"><a href="#public-PrintWriter-append-char-c" class="headerlink" title="public PrintWriter append(char c)"></a>public PrintWriter append(char c)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PrintWriter <span class="title">append</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    write(c);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将入参字符c追加输出到底层输出流中。实际调用后执行效果同方法<strong>write(int c)</strong>。</p>
<h4 id="public-void-flush"><a href="#public-void-flush" class="headerlink" title="public void flush()"></a>public void flush()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            ensureOpen();</span><br><span class="line">            out.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">        trouble = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将当前输出流中存储的数据推送到目标输出位置。通过使用synchronized关键字保证了多线程环境下的线程安全。在底层输出流开启的情况下通过调用底层输出流的flush()方法将数据推送到输出流指定的目标输出位置。如果在过程中出现了异常，当前方法不会向上抛出异常，而是将<strong>trouble</strong>字段标记为true，通过checkError()方法了解当前方法是否出现了异常。</p>
<h4 id="public-void-close"><a href="#public-void-close" class="headerlink" title="public void close()"></a>public void close()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (out == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            out.close();</span><br><span class="line">            out = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">        trouble = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;关闭当前输出流。通过使用synchronized关键字保证了多线程环境下的线程安全。如果底层输出流已经关闭，那么直接返回，否则通过调用底层输出流的close()方法关闭底层输出流并释放占用的相关资源。如果在过程中出现了异常，当前方法不会向上抛出异常，而是将<strong>trouble</strong>字段标记为true，通过checkError()方法了解当前方法是否出现了异常。</p>
<p>&emsp;</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li>NIL</li>
</ol>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>NIL</li>
</ol>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java I/O 20 - PushbackReader</title>
    <url>/2018/java-PushbackReader.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;关于<em> <strong>java.io.PushbackReader</strong> </em> 的部分笔记。本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;PushbackReader允许将读取到的字符内容再回退到输入流中（实际上这些内容被保存在了底层的一个缓冲区数组buf中），在调用read方法获取字符数据时会首先从缓冲区buf中获取内容，当从buf中无法得到所要求的内容时则向底层输入流获取数据。</p>
<p>&emsp;</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PushbackReader</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.io.Reader</span><br><span class="line">    --java.io.FilterReader</span><br><span class="line">      --java.io.PushbackReader</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类名</th>
<th style="text-align:center">实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PushbackReader</td>
<td style="text-align:center">Closeable, AutoCloseable,Readable</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="PushbackReader"><a href="#PushbackReader" class="headerlink" title="PushbackReader"></a>PushbackReader</h2><h3 id="Constructor-Summary"><a href="#Constructor-Summary" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="public-PushbackReader-Reader-in-int-size"><a href="#public-PushbackReader-Reader-in-int-size" class="headerlink" title="public PushbackReader(Reader in, int size)"></a>public PushbackReader(Reader in, int size)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PushbackReader</span><span class="params">(Reader in, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(in);</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"size &lt;= 0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.buf = <span class="keyword">new</span> <span class="keyword">char</span>[size];</span><br><span class="line">    <span class="keyword">this</span>.pos = size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个PushbackReader字符流。</p>
<h4 id="public-PushbackReader-Reader-in"><a href="#public-PushbackReader-Reader-in" class="headerlink" title="public PushbackReader(Reader in)"></a>public PushbackReader(Reader in)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PushbackReader</span><span class="params">(Reader in)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(in, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个PushbackReader字符流。</p>
<h3 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="private-void-ensureOpen"><a href="#private-void-ensureOpen" class="headerlink" title="private void ensureOpen()"></a>private void ensureOpen()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureOpen</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (buf == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Stream closed"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;检查当前buf是否有效且是否含有内容。</p>
<h4 id="public-int-read"><a href="#public-int-read" class="headerlink" title="public int read()"></a>public int read()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; buf.length)</span><br><span class="line">            <span class="keyword">return</span> buf[pos++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;读取一个字符的内容并返回。通过synchronized关键字可以保证多线程环境下的线程安全。如果在调用read()方法之前曾经调用过unread()方法，那么buf中就存有unread()方法中传入的内容，在调用read()方法时需要首先读取缓冲区buf中的内容，即(pos &lt; buf.length)。反之，直接从底层输出流中获取一个字符内容并返回。</p>
<h4 id="public-int-read-char-cbuf-int-off-int-len"><a href="#public-int-read-char-cbuf-int-off-int-len" class="headerlink" title="public int read(char cbuf[], int off, int len)"></a>public int read(char cbuf[], int off, int len)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> cbuf[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((off &lt; <span class="number">0</span>) || (off &gt; cbuf.length)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> avail = buf.length - pos;</span><br><span class="line">            <span class="keyword">if</span> (avail &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (len &lt; avail)</span><br><span class="line">                    avail = len;</span><br><span class="line">                System.arraycopy(buf, pos, cbuf, off, avail);</span><br><span class="line">                pos += avail;</span><br><span class="line">                off += avail;</span><br><span class="line">                len -= avail;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                len = <span class="keyword">super</span>.read(cbuf, off, len);</span><br><span class="line">                <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> (avail == <span class="number">0</span>) ? -<span class="number">1</span> : avail;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> avail + len;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> avail;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;读取长度为len的内容并保存到数组b中起始位置为off的空间中。通过synchronized关键字保证了多线程环境下的线程安全。第5 ~ 12行代码完成了参数的有效性校验。</p>
<p>&emsp;&emsp;第13行代码计算缓冲区buf的数据内容长度，如果有未读取的内容，那么将首先返回buf中的内容并保存到cbuf中。将数据保存到cbuf后更新计算pos、off、len值。如果buf中的内容未能满足len的长度要求，那么接着从底层输入流中获取数据。第23行代码依赖底层输入流将数据填充到cbuf中，计算实际读取的数据长度并返回。</p>
<h4 id="public-void-unread-int-c"><a href="#public-void-unread-int-c" class="headerlink" title="public void unread(int c)"></a>public void unread(int c)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unread</span><span class="params">(<span class="keyword">int</span> c)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line">        <span class="keyword">if</span> (pos == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Pushback buffer overflow"</span>);</span><br><span class="line">        buf[--pos] = (<span class="keyword">char</span>) c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;回退一个字符到回退buf中。一旦执行了该方法，下一次调用read()方法获取的第一个字符会是该方法的入参c。通过synchronized关键字保证了多线程环境下的线程安全。如果pos到达了buf头部，那么意味着缓冲区buf已经没有空间容纳新的内容，所以向上抛出异常。反之，则将入参字符c保存到回退buf中。</p>
<h4 id="public-void-unread-char-cbuf-int-off-int-len"><a href="#public-void-unread-char-cbuf-int-off-int-len" class="headerlink" title="public void unread(char cbuf[], int off, int len)"></a>public void unread(char cbuf[], int off, int len)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unread</span><span class="params">(<span class="keyword">char</span> cbuf[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line">        <span class="keyword">if</span> (len &gt; pos)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Pushback buffer overflow"</span>);</span><br><span class="line">        pos -= len;</span><br><span class="line">        System.arraycopy(cbuf, off, buf, pos, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unread</span><span class="params">(<span class="keyword">char</span> cbuf[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    unread(cbuf, <span class="number">0</span>, cbuf.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将字符数组cbuf中的内容回退到缓冲区buf中。一旦执行了该方法，下一次调用read()方法获取的第一个字符会是cbuf[off]，依次类推。通过synchronized关键字保证了多线程环境下的线程安全。通过调用系统方法<strong>System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</strong>将cbuf中的内容复制保存到缓冲区buf中。</p>
<h4 id="public-boolean-ready"><a href="#public-boolean-ready" class="headerlink" title="public boolean ready()"></a>public boolean ready()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">ready</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line">        <span class="keyword">return</span> (pos &lt; buf.length) || <span class="keyword">super</span>.ready();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通知方法调用方当前输入流是否可提供字符内容。通过synchronized关键字保证了多线程环境下的线程安全。如果缓冲区buf中尚有可读取的字符内容，或者底层输入流可以继续通过read方法提供数据，那么则认为当前输入流可以继续对外提供数据内容。</p>
<h4 id="public-boolean-markSupported"><a href="#public-boolean-markSupported" class="headerlink" title="public boolean markSupported()"></a>public boolean markSupported()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">markSupported</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;PushbackReader不支持标记重读操作，所以返回false。</p>
<h4 id="public-void-mark-int-readAheadLimit"><a href="#public-void-mark-int-readAheadLimit" class="headerlink" title="public void mark(int readAheadLimit)"></a>public void mark(int readAheadLimit)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> readAheadLimit)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"mark/reset not supported"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;PushbackReader不支持标记重读操作，所以在调用mark()方法时向上抛出异常。</p>
<h4 id="public-void-reset"><a href="#public-void-reset" class="headerlink" title="public void reset()"></a>public void reset()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"mark/reset not supported"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;PushbackReader不支持标记重读操作，所以在调用reset()方法时向上抛出异常。</p>
<h4 id="public-void-close"><a href="#public-void-close" class="headerlink" title="public void close()"></a>public void close()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.close();</span><br><span class="line">    buf = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;关闭当前输入流。首先将底层输入流关闭，接着释放缓冲区buf占用的资源。</p>
<h4 id="public-long-skip-long-n"><a href="#public-long-skip-long-n" class="headerlink" title="public long skip(long n)"></a>public long skip(long n)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"skip value is negative"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line">        <span class="keyword">int</span> avail = buf.length - pos;</span><br><span class="line">        <span class="keyword">if</span> (avail &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &lt;= avail) &#123;</span><br><span class="line">                pos += n;</span><br><span class="line">                <span class="keyword">return</span> n;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pos = buf.length;</span><br><span class="line">                n -= avail;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> avail + <span class="keyword">super</span>.skip(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;跳过n个长度的字符内容。n不可为负数，所以若传入一个负数长度，那么则向上抛出一个非法参数异常。第6行代码计算缓冲区buf中是否有回退的字符内容以及回退字符的长度。第8 ~ 10行代码表明需要跳过的长度n小于缓冲区buf中回退字符的长度，可以直接更新pos值完成跳过操作。反之则需要跳过缓冲区buf中的所有内容，同时跳过底层输入流中的若干字符内容以完成最终操作。最后计算实际跳过的字符长度并返回。</p>
<p>&emsp;</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li>NIL</li>
</ol>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>NIL</li>
</ol>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java I/O 15 - Reader &amp; Writer</title>
    <url>/2018/java-Reader-Writer.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;关于<em> <strong>java.io.Reader</strong> </em> 和 <em> <strong>java.io.Writer</strong> </em>的部分笔记，这两个类是所有的字符流读写类的父类。继承这两个类的子类出于性能等方面的考虑会重写其方法。本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;Reader和Writer是用来完成关于字符流读写操作的公共父类。继承这两个类的子类分别实现读写操作和关闭操作。虽然自身实现了部分的读写方法，但是出于高效、额外功能的考虑，子类需要重写覆盖Reader和Writer自身已经实现的方法来获取更好的使用性能。</p>
<p>&emsp;&emsp;在使用Writer向底层输出流输出数据内容时，Writer仅保证通过flush操作可以将数据从内存输出给操作系统，但是并不保证数据可以正确完整的写入到特定的物理设备中，这一点在使用时需要加以注意。</p>
<p>&emsp;</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Reader</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.io.Reader</span><br><span class="line"></span><br><span class="line"><span class="comment">// Writer</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.io.Writer</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类名</th>
<th style="text-align:center">实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Reader</td>
<td style="text-align:center">Closeable, AutoCloseable,Readable</td>
</tr>
<tr>
<td style="text-align:center">Writer</td>
<td style="text-align:center">Closeable, Flushable, AutoCloseable, Appendable</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h2><h3 id="Constructor-Summary"><a href="#Constructor-Summary" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="protected-Reader"><a href="#protected-Reader" class="headerlink" title="protected Reader()"></a>protected Reader()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.lock = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="protected-Reader-Object-lock"><a href="#protected-Reader-Object-lock" class="headerlink" title="protected Reader(Object lock)"></a>protected Reader(Object lock)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Reader</span><span class="params">(Object lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lock == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.lock = lock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="public-int-read-java-nio-CharBuffer-target"><a href="#public-int-read-java-nio-CharBuffer-target" class="headerlink" title="public int read(java.nio.CharBuffer target)"></a><span id="publicIntReadCharBuffer">public int read(java.nio.CharBuffer target)</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(java.nio.CharBuffer target)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = target.remaining();</span><br><span class="line">    <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">    <span class="keyword">int</span> n = read(cbuf, <span class="number">0</span>, len);</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">        target.put(cbuf, <span class="number">0</span>, n);</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从底层读取数据并保存到一个CharBuffer对象中。实际读取的长度由CharBuffer对象的剩余可用空间决定。通过调用方法read(char cbuf[], int off, int len)读取到数据后再封装回CharBuffer对象，最后返回实际读取的字符长度。</p>
<h4 id="public-int-read"><a href="#public-int-read" class="headerlink" title="public int read()"></a><span id="publicIntReadNull">public int read()</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> cb[] = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (read(cb, <span class="number">0</span>, <span class="number">1</span>) == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> cb[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从底层读取一个字符并返回。实际调用的方法是read(char cbuf[])。</p>
<h4 id="public-int-read-char-cbuf"><a href="#public-int-read-char-cbuf" class="headerlink" title="public int read(char cbuf[])"></a><span id="publicIntReadCbuf">public int read(char cbuf[])</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> cbuf[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> read(cbuf, <span class="number">0</span>, cbuf.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> cbuf[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从底层输入流中读取数据并将读取的数据保存到数组cbuf中。实际调用的方法是read(char cbuf[], int off, int len)，该方法被声明为抽象方法，需要在子类中实现。</p>
<h4 id="public-long-skip-long-n"><a href="#public-long-skip-long-n" class="headerlink" title="public long skip(long n)"></a><span id="publicLongSkip">public long skip(long n)</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"skip value is negative"</span>);</span><br><span class="line">        <span class="keyword">int</span> nn = (<span class="keyword">int</span>) Math.min(n, maxSkipBufferSize);</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((skipBuffer == <span class="keyword">null</span>) || (skipBuffer.length &lt; nn))</span><br><span class="line">                skipBuffer = <span class="keyword">new</span> <span class="keyword">char</span>[nn];</span><br><span class="line">            <span class="keyword">long</span> r = n;</span><br><span class="line">            <span class="keyword">while</span> (r &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> nc = read(skipBuffer, <span class="number">0</span>, (<span class="keyword">int</span>)Math.min(r, nn));</span><br><span class="line">                <span class="keyword">if</span> (nc == -<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                r -= nc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> n - r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;跳过长度为n的字节数并开始从第n+1个位置读取数据。代码段通过synchronized保证了多线程环境的线程安全要求。第6 ~ 7行代码计算理论上需要跳过的数据长度并初始化一个数据存储buffer空间。第9 ~ 14行则循环从输入流中读取数据并将读取的数据保存到数组buffer中，如果读取结束则退出循环。最后计算实际跳过的长度并返回给方法调用方，需要注意的是实际跳过的长度有可能小于入参长度n。</p>
<h4 id="public-boolean-ready"><a href="#public-boolean-ready" class="headerlink" title="public boolean ready()"></a><span id="publicBooleanReady">public boolean ready()</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">ready</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;判断当前输入流是否可以通过read()方法获取数据。</p>
<h4 id="public-boolean-markSupported"><a href="#public-boolean-markSupported" class="headerlink" title="public boolean markSupported()"></a><span id="publicBooleanMarkSupported">public boolean markSupported()</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">markSupported</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;是否支持标记重读。Reader自身不支持标记重读操作，所以返回false给接口调用方。</p>
<h4 id="public-void-mark-int-readAheadLimit"><a href="#public-void-mark-int-readAheadLimit" class="headerlink" title="public void mark(int readAheadLimit)"></a><span id="publicVoidMark">public void mark(int readAheadLimit)</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> readAheadLimit)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"mark() not supported"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;标记重读的起点。Reader类自身不支持标记重复读取字符的起点，所以直接抛出异常给方法调用方。</p>
<h4 id="public-void-reset"><a href="#public-void-reset" class="headerlink" title="public void reset()"></a><span id="publicVoidReset">public void reset()</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"reset() not supported"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;重置下一个字符读取位置。Reader类自身不支持重置操作，所以直接抛出异常给方法调用方。</p>
<h4 id="abstract-public-void-close"><a href="#abstract-public-void-close" class="headerlink" title="abstract public void close()"></a><span id="publicVoidCloseIn">abstract public void close()</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;关闭流并释放占用资源。该方法是一个抽象方法，需要子类去实现具体的关闭流程。</p>
<p>&emsp;</p>
<h2 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h2><h3 id="Constructor-Summary-1"><a href="#Constructor-Summary-1" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="protected-Writer"><a href="#protected-Writer" class="headerlink" title="protected Writer()"></a>protected Writer()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.lock = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="protected-Writer-Object-lock"><a href="#protected-Writer-Object-lock" class="headerlink" title="protected Writer(Object lock)"></a>protected Writer(Object lock)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Writer</span><span class="params">(Object lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lock == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.lock = lock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="部分方法-1"><a href="#部分方法-1" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="public-void-write-int-c"><a href="#public-void-write-int-c" class="headerlink" title="public void write(int c)"></a><span id="publicVoidWriteIC">public void write(int c)</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> c)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (writeBuffer == <span class="keyword">null</span>)&#123;</span><br><span class="line">            writeBuffer = <span class="keyword">new</span> <span class="keyword">char</span>[writeBufferSize];</span><br><span class="line">        &#125;</span><br><span class="line">        writeBuffer[<span class="number">0</span>] = (<span class="keyword">char</span>) c;</span><br><span class="line">        write(writeBuffer, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;向缓冲区buffer中写入一个字符数据。该方法被synchronized关键字包围起来保证了多线程环境下的线程安全。缓冲区buffer数组的长度默认为1024。该方法已经被<strong>java.io.OutputStreamWriter</strong>等子类重写覆盖。</p>
<h4 id="public-void-write-char-cbuf"><a href="#public-void-write-char-cbuf" class="headerlink" title="public void write(char cbuf[])"></a><span id="publicVoidWriteCC">public void write(char cbuf[])</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> cbuf[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    write(cbuf, <span class="number">0</span>, cbuf.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;向缓冲区buffer中写入数组cbuf中的字符数据。该方法通过调用方法write(char cbuf[], int off, int len)实现相关操作。</p>
<h4 id="abstract-public-void-write-char-cbuf-int-off-int-len"><a href="#abstract-public-void-write-char-cbuf-int-off-int-len" class="headerlink" title="abstract public void write(char cbuf[], int off, int len)"></a><span id="publicVoidWriteCCIOIL">abstract public void write(char cbuf[], int off, int len)</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> cbuf[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;向缓冲区buffer中写入数组cbuf中包含的字符数据。该方法被声明为一个抽象方法，需要在子类中实现该方法。</p>
<h4 id="public-void-write-String-str"><a href="#public-void-write-String-str" class="headerlink" title="public void write(String str)"></a><span id="publicVoidWriteSS">public void write(String str)</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String str)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    write(str, <span class="number">0</span>, str.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将一个String字符串写入到缓冲区buffer中。</p>
<h4 id="public-void-write-String-str-int-off-int-len"><a href="#public-void-write-String-str-int-off-int-len" class="headerlink" title="public void write(String str, int off, int len)"></a><span id="publicVoidWriteSSIOIL">public void write(String str, int off, int len)</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String str, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">char</span> cbuf[];</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= writeBufferSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (writeBuffer == <span class="keyword">null</span>) &#123;</span><br><span class="line">                writeBuffer = <span class="keyword">new</span> <span class="keyword">char</span>[writeBufferSize];</span><br><span class="line">            &#125;</span><br><span class="line">            cbuf = writeBuffer;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">// Don't permanently allocate very large buffers.</span></span><br><span class="line">            cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">        &#125;</span><br><span class="line">        str.getChars(off, (off + len), cbuf, <span class="number">0</span>);</span><br><span class="line">        write(cbuf, <span class="number">0</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将一个String字符串中自下标off位置起长度为len的内容写入到缓冲区buffer中。通过将String字符串转成char数组，再调用write(char cbuf[], int off, int len)方法完成操作。该方法已经被<strong>java.io.OutputStreamWriter</strong>等子类重写覆盖。</p>
<h4 id="public-Writer-append-CharSequence-csq"><a href="#public-Writer-append-CharSequence-csq" class="headerlink" title="public Writer append(CharSequence csq)"></a><span id="publicWriteAppendCSC">public Writer append(CharSequence csq)</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Writer <span class="title">append</span><span class="params">(CharSequence csq)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (csq == <span class="keyword">null</span>)</span><br><span class="line">        write(<span class="string">"null"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        write(csq.toString());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将一个CharSequence对象中包含的内容写入到底层输出流的缓冲区buffer中。该方法的实际效果等同于<strong>write(String str)</strong>，其底层实现也是通过将CharSequence转成String字符串，然后在调用上述方法来完成操作的。</p>
<h4 id="public-Writer-append-CharSequence-csq-int-start-int-end"><a href="#public-Writer-append-CharSequence-csq-int-start-int-end" class="headerlink" title="public Writer append(CharSequence csq, int start, int end)"></a><span id="publicWriteAppendCCISIE">public Writer append(CharSequence csq, int start, int end)</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Writer <span class="title">append</span><span class="params">(CharSequence csq, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    CharSequence cs = (csq == <span class="keyword">null</span> ? <span class="string">"null"</span> : csq);</span><br><span class="line">    write(cs.subSequence(start, end).toString());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将一个CharSequence对象中从起始位置start到结束end之间的内容写入到底层输出流的缓冲区buffer中。</p>
<h4 id="public-Writer-append-char-c"><a href="#public-Writer-append-char-c" class="headerlink" title="public Writer append(char c)"></a><span id="publicWriteAppendCC">public Writer append(char c)</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Writer <span class="title">append</span><span class="params">(<span class="keyword">char</span> c)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    write(c);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将一个字符写入到底层输出了的缓冲区buffer中。该方法的实际效果等同于<strong>write(int c)</strong>。</p>
<h4 id="abstract-public-void-flush"><a href="#abstract-public-void-flush" class="headerlink" title="abstract public void flush()"></a><span id="publicVoidFlush">abstract public void flush()</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将buffer缓冲区中保存的数据推到底层输出流中。该方法是一个抽象方法，具体流程需要由子类自行完成实现。</p>
<h4 id="abstract-public-void-close-1"><a href="#abstract-public-void-close-1" class="headerlink" title="abstract public void close()"></a><span id="publicVoidCloseOut">abstract public void close()</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;关闭当前输出流。该方法是一个抽象方法，具体关闭流的流程需要由子类自行完成实现。</p>
<p>&emsp;</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li>NIL<br>&emsp;</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>NIL<br>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java I/O 12 - SequenceInputStream</title>
    <url>/2018/java-SequenceInputStream.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;关于<em> <strong>java.io.SequenceInputStream</strong> </em>的部分笔记，SequenceInputStream中包含了多个输入流，多个输入流之间按照先后顺序依次通过read()方法提供新数据。本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;SequenceInputStream在其中维护了多个输入流，这些输入流按照先后顺序依次提供输入数据。如果当前输入流已经无法继续提供输入数据，那么就会取得下一个数据流，并从下一个输入流的read()方法中获取新的数据流。如果最后一个输入流的数据也已经读取完毕，那么就不会有新数据可以读取了。输入流的获取按照先后顺序依次进行。</p>
<p>&emsp;</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SequenceInputStream</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.io.InputStream</span><br><span class="line">    --java.io.SequenceInputStream</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类名</th>
<th style="text-align:center">实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SequenceInputStream</td>
<td style="text-align:center">Closeable, AutoCloseable</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="ByteArrayInputStream"><a href="#ByteArrayInputStream" class="headerlink" title="ByteArrayInputStream"></a>ByteArrayInputStream</h2><h3 id="Constructor-Summary"><a href="#Constructor-Summary" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="public-SequenceInputStream-Enumeration-lt-extends-InputStream-gt-e"><a href="#public-SequenceInputStream-Enumeration-lt-extends-InputStream-gt-e" class="headerlink" title="public SequenceInputStream(Enumeration&lt;? extends InputStream&gt; e)"></a>public SequenceInputStream(Enumeration&lt;? extends InputStream&gt; e)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SequenceInputStream</span><span class="params">(Enumeration&lt;? extends InputStream&gt; e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.e = e;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        nextStream();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="comment">// This should never happen</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"panic"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;入参是一个元素枚举类。通过遍历枚举类中的每一个元素(在SequenceInputStream为输入流)，完成输入流的初始化操作。</p>
<h4 id="public-SequenceInputStream-InputStream-s1-InputStream-s2"><a href="#public-SequenceInputStream-InputStream-s1-InputStream-s2" class="headerlink" title="public SequenceInputStream(InputStream s1, InputStream s2)"></a>public SequenceInputStream(InputStream s1, InputStream s2)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SequenceInputStream</span><span class="params">(InputStream s1, InputStream s2)</span> </span>&#123;</span><br><span class="line">    Vector  v = <span class="keyword">new</span> Vector(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    v.addElement(s1);</span><br><span class="line">    v.addElement(s2);</span><br><span class="line">    e = v.elements();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        nextStream();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="comment">// This should never happen</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"panic"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;依次加入入参的两个输入流，遍历入参完成输入流的初始化操作。</p>
<h3 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="final-void-nextStream"><a href="#final-void-nextStream" class="headerlink" title="final void nextStream()"></a>final void nextStream()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">nextStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e.hasMoreElements()) &#123;</span><br><span class="line">        in = (InputStream) e.nextElement();</span><br><span class="line">        <span class="keyword">if</span> (in == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> in = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;获取下一个输入流。在初始化操作时会通过该方法获取第一个输入流。如果当前已有可用的输入流，且该输入流中已无可读取的数据，那么该方法会返回下一个输入流完成数据的读取操作。如果当前底层输入流不为空，那么关闭当前底层输入流并释放其占用的所有资源。</p>
<h4 id="public-int-available"><a href="#public-int-available" class="headerlink" title="public int available()"></a>public int available()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">available</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(in == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// no way to signal EOF from available()</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> in.available();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;获取当前输入流中剩余可读取的数据长度。直接通过底层输入流中的available()方法获取计算结果。如果已无任何可用的输入流，那么返回0。</p>
<h4 id="public-int-read"><a href="#public-int-read" class="headerlink" title="public int read()"></a>public int read()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (in == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> c = in.read();</span><br><span class="line">    <span class="keyword">if</span> (c == -<span class="number">1</span>) &#123;</span><br><span class="line">        nextStream();</span><br><span class="line">        <span class="keyword">return</span> read();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;尝试从当前底层输入流中读取一个字节的内容并返回。如果当前底层输入流中数据读取结束，那么在第7行代码中切换到下一个底层输入流，递归调用read()方法读取数据，直到最后一个底层输入流的内容也读取完毕。</p>
<h4 id="public-int-read-byte-b-int-off-int-len"><a href="#public-int-read-byte-b-int-off-int-len" class="headerlink" title="public int read(byte b[], int off, int len)"></a>public int read(byte b[], int off, int len)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (in == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (off &lt; <span class="number">0</span> || len &lt; <span class="number">0</span> || len &gt; b.length - off) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = in.read(b, off, len);</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        nextStream();</span><br><span class="line">        <span class="keyword">return</span> read(b, off, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;尝试从当前底层输入流中读取长度为len个字节的内容并保存到数组b中。第2 ~ 10行代码完成方法入参的有效性校验，避免发生越界溢出。第12行代码从底层输入流中读取数据并保存到数组b中，如果未读取到任何数据，那么切换到下一个底层输入流，继续尝试读取数据。最后返回实际读取的数据长度。</p>
<h4 id="public-void-close"><a href="#public-void-close" class="headerlink" title="public void close()"></a>public void close()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        nextStream();</span><br><span class="line">    &#125; <span class="keyword">while</span> (in != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;关闭所有的底层输入流。</p>
<p>&emsp;</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li>NIL</li>
</ol>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>NIL<br>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java I/O 16 - StringReader &amp; StringWriter</title>
    <url>/2018/java-StringReader-StringWriter.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;关于<em> <strong>java.io.StringReader</strong> </em> 和 <em> <strong>java.io.StringWriter</strong> </em>的部分笔记，这两个类维护了一套对于String/ StringBuffer的流操作集合。其底层的流内容来源和最终存储位置也是String/StringBuffer而非其他第三方的输入输出流位置。本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;StringReader和StringWriter的底层输入输出位置是String/StringBuffer，事实上是把String/StringBuffer当做了一个虚拟的输入输出流来对待处理而不依赖第三个真正意义上的输入输出流。所有的操作都是围绕着String/ StringBuffer进行。这两个类可以用在一些需要字符流作为参数，且内容单纯的只有String的场景中。</p>
<p>&emsp;</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// StringReader</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.io.Reader</span><br><span class="line">    --java.io.StringReader</span><br><span class="line"></span><br><span class="line"><span class="comment">// StringWriter</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.io.Writer</span><br><span class="line">    --java.io.StringWriter</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类名</th>
<th style="text-align:center">实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">StringReader</td>
<td style="text-align:center">Closeable, AutoCloseable,Readable</td>
</tr>
<tr>
<td style="text-align:center">StringWriter</td>
<td style="text-align:center">Closeable, Flushable, AutoCloseable, Appendable</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;</p>
<h2 id="StringReader"><a href="#StringReader" class="headerlink" title="StringReader"></a>StringReader</h2><h3 id="Constructor-Summary"><a href="#Constructor-Summary" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="public-StringReader-String-s"><a href="#public-StringReader-String-s" class="headerlink" title="public StringReader(String s)"></a>public StringReader(String s)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringReader</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.str = s;</span><br><span class="line">    <span class="keyword">this</span>.length = s.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个String内容的输入流，流的源头是入参字符串<strong>s</strong>。输入流的内容的长度是<strong>s</strong>的字符串长度。</p>
<h3 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="public-int-read"><a href="#public-int-read" class="headerlink" title="public int read()"></a>public int read()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line">        <span class="keyword">if</span> (next &gt;= length)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> str.charAt(next++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;读取一个字符的内容并返回。通过synchronized关键字保证了多线程环境下的线程安全。如果底层的字符串不为空，那么返回下一个字符串。如果已经到达了字符串尾部，那么就返回-1标识文件已经读取完毕。第3行代码中的ensureOpen()方法则用来判断底层的字符串是否有效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureOpen</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Stream closed"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果字符为空，那么向上抛出一个异常提示当前流已关闭。</p>
<h4 id="public-int-read-char-cbuf-int-off-int-len"><a href="#public-int-read-char-cbuf-int-off-int-len" class="headerlink" title="public int read(char cbuf[], int off, int len)"></a>public int read(char cbuf[], int off, int len)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> cbuf[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line">        <span class="keyword">if</span> ((off &lt; <span class="number">0</span>) || (off &gt; cbuf.length) || (len &lt; <span class="number">0</span>) ||</span><br><span class="line">            ((off + len) &gt; cbuf.length) || ((off + len) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (next &gt;= length)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = Math.min(length - next, len);</span><br><span class="line">        str.getChars(next, next + n, cbuf, off);</span><br><span class="line">        next += n;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从底层读取长度为len的字符内容并保存到字符数组cbuf中。通过synchronized关键字保证了多线程环境下的线程安全。第3行代码用来判断底层字符串内容是否存在且可用。第4 ~ 6行代码用来完成参数的边界校验，防止越界溢出。第10 ~ 11行代码如果已经读到了字符串尾部，那么返回-1。第12行代码用来判断当前剩余未读取的字符串长度和入参长度len之间的大小关系，如果剩余未读取的字符串长度小于len，那么剩余未读取的字符串会全部返回，否则就返回长度为len的字符串内容。第13行代码完成实际的读取操作。之后计算实际读取的字符串长度并返回。</p>
<h4 id="public-long-skip-long-ns"><a href="#public-long-skip-long-ns" class="headerlink" title="public long skip(long ns)"></a>public long skip(long ns)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> ns)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line">        <span class="keyword">if</span> (next &gt;= length)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// Bound skip by beginning and end of the source</span></span><br><span class="line">        <span class="keyword">long</span> n = Math.min(length - next, ns);</span><br><span class="line">        n = Math.max(-next, n);</span><br><span class="line">        next += n;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;跳过流底层字符串中指定长度的字符数。下一个读取的位置会是当前next+ns位置。如果ns为负数，那么执行的实际效果是会前推到next-ns位置。通过synchronized关键字保证了多线程环境下的线程安全。第3行代码用来判断底层字符串内容是否存在且可用。第4 ~ 5行代码如果当前字符串已经到达字符串尾部（正常读取或者跳过）那么直接返回0。第7 ~ 9行代码计算实际需要跳过的字符长度，具体如下分析：</p>
<ol>
<li>ns &gt; 0。第7行代码会返回两个计算值的较小值作为实际跳过长度值。第8行代码由于next永远为正，所以得到的较大值是第7行代码的计算结果。第9行代码执行正数加法，计算后的next值大于计算前的next值，下一个读取位置后移：</li>
<li>ns &lt; 0，|ns| &lt; next。第7行代码永远返回负数值ns。第8行代码由于 |ns| &lt; next，所以ns &gt; -next，所以实际返回ns。第9行代码执行负数加法，计算后的next小于计算前的next值但next依然大于0。下一个读取位置前移；</li>
<li>ns &lt; 0，|ns| &gt; next。第7行代码永远返回负数值ns。第8行代码由于 |ns| &gt; next，所以ns &lt; -next，所以实际返回 -next。第9行代码执行负数加法，计算后的next值等于0。下一个读取位置归零到字符串第一个位置。</li>
</ol>
<p>最后返回实际跳过的位置，综上分析，该返回值可能为负数。</p>
<h4 id="public-boolean-ready"><a href="#public-boolean-ready" class="headerlink" title="public boolean ready()"></a>public boolean ready()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">ready</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通知方法调用方当前输入流可以对外提供数据读取操作。如果ensureOpen()没有抛出异常，那么底层字符串不为空，那么返回true表示有内容可供读取。</p>
<h4 id="public-boolean-markSupported"><a href="#public-boolean-markSupported" class="headerlink" title="public boolean markSupported()"></a><span id="publicBooleanMarkSupported">public boolean markSupported()</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">markSupported</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;是否支持标记重读。StringReader支持标记重读，所以返回true。</p>
<h4 id="public-void-mark-int-readAheadLimit"><a href="#public-void-mark-int-readAheadLimit" class="headerlink" title="public void mark(int readAheadLimit)"></a>public void mark(int readAheadLimit)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> readAheadLimit)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (readAheadLimit &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Read-ahead limit &lt; 0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line">        mark = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;记录当前读取位置。该位置值会在下次调用reset()方法时重新赋值给next完成重读操作。在StringReader中流数据来自于String字符串，所以没有实际的关于mark方法调用之后可读的字符长度的限制，所以入参readAheadLimit必须大于0。</p>
<h4 id="public-void-reset"><a href="#public-void-reset" class="headerlink" title="public void reset()"></a><span id="publicVoidReset">public void reset()</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line">        next = mark;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;重置下一个读取位置。如果在调用该方法之前没有调用过mark()方法，mark一直保持初始值（即mark = 0）状态，那么该方法调用后下一个读取位置会回归到字符串首部。</p>
<h4 id="public-void-close"><a href="#public-void-close" class="headerlink" title="public void close()"></a>public void close()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    str = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;关闭流并释放占用资源。在StringReader中直接将底层字符串置为null。</p>
<p>&emsp;</p>
<h2 id="StringWriter"><a href="#StringWriter" class="headerlink" title="StringWriter"></a>StringWriter</h2><h3 id="Constructor-Summary-1"><a href="#Constructor-Summary-1" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="public-StringWriter"><a href="#public-StringWriter" class="headerlink" title="public StringWriter()"></a>public StringWriter()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringWriter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    buf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    lock = buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个String输出流。底层输出位置是一个StringBuffer，写入的数据会存储到StringBuffer中。之所以使用StringBuffer是因为StringWriter可能用于多线程环境，而StringBuffer可以保证多线程环境下的线程安全。</p>
<h4 id="public-StringWriter-int-initialSize"><a href="#public-StringWriter-int-initialSize" class="headerlink" title="public StringWriter(int initialSize)"></a>public StringWriter(int initialSize)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringWriter</span><span class="params">(<span class="keyword">int</span> initialSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialSize &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Negative buffer size"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    buf = <span class="keyword">new</span> StringBuffer(initialSize);</span><br><span class="line">    lock = buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个String输出流。底层输出位置是一个StringBuffer，写入的数据会存储到StringBuffer中。通过参数initialSize来指定StringBuffer的长度。</p>
<h3 id="部分方法-1"><a href="#部分方法-1" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="public-void-write-int-c"><a href="#public-void-write-int-c" class="headerlink" title="public void write(int c)"></a><span id="publicVoidWriteIC">public void write(int c)</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    buf.append((<span class="keyword">char</span>) c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;向缓冲区buf中写入一个字符数据。</p>
<h4 id="public-void-write-char-cbuf-int-off-int-len"><a href="#public-void-write-char-cbuf-int-off-int-len" class="headerlink" title="public void write(char cbuf[], int off, int len)"></a>public void write(char cbuf[], int off, int len)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> cbuf[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((off &lt; <span class="number">0</span>) || (off &gt; cbuf.length) || (len &lt; <span class="number">0</span>) ||</span><br><span class="line">        ((off + len) &gt; cbuf.length) || ((off + len) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buf.append(cbuf, off, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;向缓冲区buf中写入数组cbuf中的字符数据。第2 ~ 4行代码完成入参的有效性校验，避免发生越界溢出。第8行代码则将cbuf中的内容追加到buf中。</p>
<h4 id="public-void-write-String-str"><a href="#public-void-write-String-str" class="headerlink" title="public void write(String str)"></a>public void write(String str)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    buf.append(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将一个String字符串写入到缓冲区buf中。</p>
<h4 id="public-void-write-String-str-int-off-int-len"><a href="#public-void-write-String-str-int-off-int-len" class="headerlink" title="public void write(String str, int off, int len)"></a>public void write(String str, int off, int len)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String str, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span>  </span>&#123;</span><br><span class="line">    buf.append(str.substring(off, off + len));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将一个String字符串写入到缓冲区buf中，由参数off指定写入的起始位置，由参数len指定实际写入的字符长度。</p>
<h4 id="public-StringWriter-append-CharSequence-csq"><a href="#public-StringWriter-append-CharSequence-csq" class="headerlink" title="public StringWriter append(CharSequence csq)"></a>public StringWriter append(CharSequence csq)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringWriter <span class="title">append</span><span class="params">(CharSequence csq)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (csq == <span class="keyword">null</span>)</span><br><span class="line">        write(<span class="string">"null"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        write(csq.toString());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将一个CharSequence对象中包含的内容写入到底层的缓冲区buf中。该方法的实际效果等同于<strong>write(String str)</strong>。</p>
<h4 id="public-StringWriter-append-CharSequence-csq-int-start-int-end"><a href="#public-StringWriter-append-CharSequence-csq-int-start-int-end" class="headerlink" title="public StringWriter append(CharSequence csq, int start, int end)"></a>public StringWriter append(CharSequence csq, int start, int end)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringWriter <span class="title">append</span><span class="params">(CharSequence csq, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    CharSequence cs = (csq == <span class="keyword">null</span> ? <span class="string">"null"</span> : csq);</span><br><span class="line">    write(cs.subSequence(start, end).toString());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将一个CharSequence对象中从起始位置start到结束end之间的内容写入到底层输出流的缓冲区buf中。</p>
<h4 id="public-StringWriter-append-char-c"><a href="#public-StringWriter-append-char-c" class="headerlink" title="public StringWriter append(char c)"></a>public StringWriter append(char c)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringWriter <span class="title">append</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    write(c);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将一个字符写入到底层输出了的缓冲区buf中。该方法的实际效果等同于<strong>write(int c)</strong>。</p>
<h4 id="public-String-toString"><a href="#public-String-toString" class="headerlink" title="public String toString()"></a>public String toString()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> buf.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将底层StringBuffer中的内容转换成String字符串并输出给方法调用方。</p>
<h4 id="public-StringBuffer-getBuffer"><a href="#public-StringBuffer-getBuffer" class="headerlink" title="public StringBuffer getBuffer()"></a>public StringBuffer getBuffer()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">getBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回底层StringBuffer自身给方法调用方。</p>
<h4 id="public-void-flush"><a href="#public-void-flush" class="headerlink" title="public void flush()"></a>public void flush()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将buf缓冲区中保存的数据推到底层输出流中。该方法的方法体中不含有任何代码段，因为底层输出位置就是一个StringBuffer，所以无需做任何操作。</p>
<h4 id="public-void-close-throws-IOException"><a href="#public-void-close-throws-IOException" class="headerlink" title="public void close() throws IOException"></a>public void close() throws IOException</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;关闭当前输出流。该方法的方法体中不含有任何操作，同时该方法可以多次重复调用而不会抛出异常。</p>
<p>&emsp;</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li>NIL</li>
</ol>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>NIL</li>
</ol>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程 - ThreadLocal解释</title>
    <url>/2019/java-multiThread-ThreadLocal.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;关于 <em> <strong>java.io.ThreadLocal </strong> </em> 的部分笔记，ThreadLocal维护了多线程环境中每个线程的私有变量内容，保证这些私有变量内容只对特定的线程可见，其他线程无法访问、修改非自身线程中的变量内容。本文演示代码段的执行环境基于JDK版本<strong>1.7</strong>。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;ThreadLocal实现了多线程环境中每个线程独自访问、维护其私有的变量实例的特性。在实际的多线程环境中，每个线程内部维护了一个<a href="#threadlocalMap">ThreadLocalMap</a>集合，集合中的每个Entry维护了一个Threadlocal引用和线程内变量的映射关系。每个Threadlocal引用具有唯一的用于执行散列操作的<strong>threadLocalHashCode</strong>字段值，因此如果某个线程内部需要多个变量的话只需要创建多个Threadlocal实例，并将Threadlocal实例和变量的映射关系维护到线程的ThreadLocalMap集合中即可。当前线程可以通过ThreadLocal提供的get和set()等方法完成对线程内私有变量的访问操作。</p>
<p>&emsp;&emsp;由于每个线程都维护了一个ThreadLocalMap集合，因此Thread、ThreadLocalMap、ThreadLocal这三者之间的关系如图1所示：</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1547194863/BlogImages/java-multiThread/java-multiThread-threadLocal-demo.png" alt></p>
<div align="center">
<div align="center">图 - 1 Thread、ThreadLocal、ThreadLocalMap关系</div>
&emsp;
</div>

<p>&emsp;&emsp;ThreadLocalMap是Threadlocal的内部类，用来维护单个线程内的可用变量实例。<a href="#entry">Entry</a>是ThreadLocalMap集合的底层数据结构。Entry的父类是弱引用的实现类，内部拥有一个类型为Object的value字段。通过Entry实现了Threadlocal实例和线程内变量对象的映射关系。ThreadLocal的结构如图1所示(PS：实线箭头为强引用，虚线箭头为弱引用)：</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1547190563/BlogImages/java-multiThread/threadlocal-entry-demo.png" alt></p>
<div align="center">
<div align="center">图 - 2  ThreadLocal结构$图^1$</div>
&emsp;
</div>

<p>&emsp;&emsp;Entry之所以继承自弱引用，是出于如下的考虑：</p>
<p>&emsp;&emsp;如图2所示，Entry实例的key以弱引用的方式指向ThreadLocal实例，因此当ThreadLocalRef不再引用ThreadLocal实例时，弱引用可以保证ThreadLocal实例对象在每次GC时都能得到清除以释放其占用的内存空间。如果该ThreadLocal实例不再使用，那么还需要断开value和Map对该Entry的指向关系，这样当前Entry和value指向的对象实例就都会被GC处理并释放空间了。</p>
<p>&emsp;&emsp;ThreadLocal如果使用不当的话容易出现内存泄漏的问题。图2中出现的弱引用解决了ThreadLocal实例可以被GC回收的问题，但是图2中value引用和ThreadLocalMap与Entry实例的引用都是强引用。当ThreadLocal被回收了以后，其对应的value也应该被回收掉，但是强引用不允许这么做，所以在确定线程内私有变量不会再次使用时需要调用remove()方法断开value以及Entry实例的引用关系，保证内存资源可以顺利被回收。除此之外，在set()方法中也包含了检测并删除无效元素的操作过程。</p>
<p>&emsp;</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ThreadLocal</span></span><br><span class="line">--java.lang.Object</span><br><span class="line">  --java.lang.ThreadLocal&lt;T&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><p>NIL</p>
<p>&emsp;</p>
<h2 id="ThreadLocal-lt-T-gt"><a href="#ThreadLocal-lt-T-gt" class="headerlink" title="ThreadLocal&lt;T&gt;"></a>ThreadLocal&lt;T&gt;</h2><h3 id="Constructor-Summary"><a href="#Constructor-Summary" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="public-ObjectInputStream-InputStream-in"><a href="#public-ObjectInputStream-InputStream-in" class="headerlink" title="public ObjectInputStream(InputStream in)"></a>public ObjectInputStream(InputStream in)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadLocal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;创建一个ThreadLocal实例。</p>
<h3 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="ThreadLocalMap-getMap-Thread-t"><a href="#ThreadLocalMap-getMap-Thread-t" class="headerlink" title="ThreadLocalMap getMap(Thread t)"></a>ThreadLocalMap getMap(Thread t)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;获取<strong>当前线程t</strong>维护的ThreadLocal实例。</p>
<h4 id="public-T-get"><a href="#public-T-get" class="headerlink" title="public T get()"></a>public T get()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> (T)e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;获取当前线程t维护的线程私有变量副本的值。</p>
<p>&emsp;&emsp;基本操作是首先取得当前线程信息，然后拿到当前线程维护的ThreadLocalMap集合，然后从中取出当前ThreadLocal实例映射的变量并返回。如果当前线程维护的ThreadLocalMap集合不存在，或者当前线程维护的局部变量的值不存在，那么设置一个初始值并返回这个初始值。底层调用<a href="#getEntry">ThreadLocalMap.getEntry</a>方法完成操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;生成初始值并赋值。</p>
<p>&emsp;&emsp;由于ThreadLocal存储的是Object，所以生成初始值的过程直接返回null。得到当前线程和当前线程维护的ThreadLocalMap后，将当前线程的变量的初始值设置为value。最后返回设置的value。底层调用<a href="#setEntry">ThreadLocalMap.set</a>方法完成操作。</p>
<p>&emsp;&emsp;initialValue()的代码非常简单，具体如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="public-void-set-T-value"><a href="#public-void-set-T-value" class="headerlink" title="public void set(T value)"></a>public void set(T value)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将当前线程中的局部变量的值设置为入参value。</p>
<p>&emsp;&emsp;操作过程很简单，取得当前线程和线程维护的ThreadLocalMap实例，之后建立当前value和ThreadLocal实例的映射关系。如果map不存在，那么就为当前线程实例化一个map集合并将ThreadLocal实例和value的映射关系存入集合中。底层调用<a href="#setEntry">ThreadLocalMap.set</a>方法完成操作。</p>
<h4 id="public-void-remove"><a href="#public-void-remove" class="headerlink" title="public void remove()"></a>public void remove()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;协助子类读取和验证它们自己的流头部，过程中会读取和校验魔数和版本号。这两个数都是序列化过程中写入到流里的。底层调用<a href="#removeEntry">ThreadLocalMap.remove</a>方法完成操作。</p>
<h4 id="void-createMap-Thread-t-T-firstValue"><a href="#void-createMap-Thread-t-T-firstValue" class="headerlink" title="void createMap(Thread t, T firstValue)"></a>void createMap(Thread t, T firstValue)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;为当前线程创建一个ThreadLocalMap集合。构造参数是当前ThreadLocal实例引用和value值。</p>
<h4 id="static-ThreadLocalMap-createInheritedMap-ThreadLocalMap-parentMap"><a href="#static-ThreadLocalMap-createInheritedMap-ThreadLocalMap-parentMap" class="headerlink" title="static ThreadLocalMap createInheritedMap(ThreadLocalMap parentMap)"></a>static ThreadLocalMap createInheritedMap(ThreadLocalMap parentMap)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ThreadLocalMap <span class="title">createInheritedMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalMap(parentMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;为当前线程创建一个ThreadLocalMap集合。构造参数是一个ThreadLocalMap集合。</p>
<h4 id="T-childValue-T-parentValue"><a href="#T-childValue-T-parentValue" class="headerlink" title="T childValue(T parentValue)"></a>T childValue(T parentValue)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">childValue</span><span class="params">(T parentValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个方法是为<strong>InheritableThreadLocal</strong>设计的，ThreadLocal自身对该方法不支持，所以直接抛出异常。</p>
<p>&emsp;</p>
<h2 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a><span id="threadlocalMap">ThreadLocalMap</span></h2><h3 id="Fields"><a href="#Fields" class="headerlink" title="Fields"></a>Fields</h3><h4 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a><span id="entry">Entry</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Entry是ThreadLocalMap集合中的底层数据结构。Entry自身是一个弱引用对象，该弱引用指向的对象是当前ThreadLocal实例。Entry内部还有一个value属性，该属性字段存储了单个线程中的一个变量的数据内容。</p>
<h3 id="Constructor-Summary-1"><a href="#Constructor-Summary-1" class="headerlink" title="Constructor Summary"></a>Constructor Summary</h3><h4 id="ThreadLocalMap-ThreadLocal-firstKey-Object-firstValue"><a href="#ThreadLocalMap-ThreadLocal-firstKey-Object-firstValue" class="headerlink" title="ThreadLocalMap(ThreadLocal firstKey, Object firstValue)"></a>ThreadLocalMap(ThreadLocal firstKey, Object firstValue)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal firstKey, Object firstValue) &#123;</span><br><span class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个当前线程需要维护的ThreadLocalMap集合实例。该集合中维护了当前线程独享的若干个变量信息。</p>
<p>&emsp;&emsp;根据入参ThreadLocal实例来确定ThreadLocal-value键值对在ThreadLocalMap中底层数组结构的下标索引，之后生成一个新的Entry实例并将该对象放入到计算得到的下标位置处。最后完成扩容阈值的设定。</p>
<h4 id="private-ThreadLocalMap-ThreadLocalMap-parentMap"><a href="#private-ThreadLocalMap-ThreadLocalMap-parentMap" class="headerlink" title="private ThreadLocalMap(ThreadLocalMap parentMap)"></a>private ThreadLocalMap(ThreadLocalMap parentMap)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">    Entry[] parentTable = parentMap.table;</span><br><span class="line">    <span class="keyword">int</span> len = parentTable.length;</span><br><span class="line">    setThreshold(len);</span><br><span class="line">    table = <span class="keyword">new</span> Entry[len];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        Entry e = parentTable[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocal key = e.get();</span><br><span class="line">            <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Object value = key.childValue(e.value);</span><br><span class="line">                Entry c = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">                <span class="keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                table[h] = c;</span><br><span class="line">                size++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化一个当前线程需要维护的ThreadLocalMap集合实例。该方法仅适用于InheritableThreadLocal实现。</p>
<p>&emsp;&emsp;在完成ThreadLocalMap实例对象的初始化相关工作后，遍历入参ParentMap中的元素，依次将其加入到新创建的ThreadLocalMap集合中。</p>
<h3 id="部分方法-1"><a href="#部分方法-1" class="headerlink" title="部分方法"></a>部分方法</h3><h4 id="private-Entry-getEntry-ThreadLocal-key"><a href="#private-Entry-getEntry-ThreadLocal-key" class="headerlink" title="private Entry getEntry(ThreadLocal key)"></a><span id="getEntry">private Entry getEntry(ThreadLocal key)</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;获取当前线程中某个变量的键值对映射实体。</p>
<p>&emsp;&emsp;在获取过程中，首先根据ThreadLocal的threadLocalHashCode属性来确定该键值对在当前ThreadLocalMap集合中的下标位置。threadLocalHashCode保证了每个ThreadLocal实例都会有一个唯一的int值，以此来保证ThreadLocal实例可以正确的参与到ThreadLocalMap集合的运算中。该值是通过如下代码来获取的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每个ThreadLocal实例会有一个唯一的int型值。final关键字保证了该字段只会被创建一次，保证了不变性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 所有ThreadLocal实例共享该AtomicInteger实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增量0x61c88647在table的长度是2的n次方的大小的时候，效果非常好，会最大程度均匀分布，减少冲突。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体的生成方法，每个ThreadLocal对象初始化之后都会得到一个唯一的int值，且该值是递增的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在获取了下标位置之后，如果该位置存在有效的键值对实体对象且该对象的弱引用指向的就是当前传入的ThreadLocal实例，那么就返回该键值对，否则调用<strong>getEntryAfterMiss()</strong>方法按照散列冲突的场景查找对象。</p>
<h4 id="private-Entry-getEntryAfterMiss-ThreadLocal-key-int-i-Entry-e"><a href="#private-Entry-getEntryAfterMiss-ThreadLocal-key-int-i-Entry-e" class="headerlink" title="private Entry getEntryAfterMiss(ThreadLocal key, int i, Entry e)"></a>private Entry getEntryAfterMiss(ThreadLocal key, int i, Entry e)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过key未找到对应Entry实例时调用当前方法完成数据查找过程。</p>
<p>&emsp;&emsp;当该方法被调用时，说明要获取的Entry可能存在散列冲突，而在ThreadLocalMap中，解决散列冲突的思想是<strong>开放定址法</strong>法中的<strong>线性探测再散列</strong>，所以从入参下标位置 <strong>i</strong> 开始，每次向后移动一个空间位置检查是否存在和入参key匹配的Entry实体。</p>
<p>&emsp;&emsp;在比较过程中如果发现了可以匹配入参key的Entry实例，那么就返回该实例。如果发现引用为null，那么需要执行清空操作，清除无效的Entry释放空间。</p>
<h4 id="private-static-int-nextIndex-int-i-int-len"><a href="#private-static-int-nextIndex-int-i-int-len" class="headerlink" title="private static int nextIndex(int i, int len)"></a>private static int nextIndex(int i, int len)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<strong>开发定址法</strong>法中的<strong>线性探测再散列</strong>函数，每次向后偏移一个位置。</p>
<h4 id="private-static-int-prevIndex-int-i-int-len"><a href="#private-static-int-prevIndex-int-i-int-len" class="headerlink" title="private static int prevIndex(int i, int len)"></a>private static int prevIndex(int i, int len)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prevIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;和nextIndex()函数相反，当前方法执行的是前向遍历，每次向前偏移一个位置。</p>
<h4 id="private-int-expungeStaleEntry-int-staleSlot"><a href="#private-int-expungeStaleEntry-int-staleSlot" class="headerlink" title="private int expungeStaleEntry(int staleSlot)"></a>private int expungeStaleEntry(int staleSlot)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;清除当前线程的ThreadLocalMap集合中的无效Entry实例。</p>
<p>&emsp;&emsp;第6 ~ 7行代码的执行顺序保证了Entry实例中的ThreadLocal实例对象和当前线程中的变量对象的引用都会被置为null从而在GC过程中会被回收掉。如果这两行代码的执行顺序颠倒一下则会导致当前线程的变量对象的引用仍然和Entry实例有联系使得该变量占用的内存得不到及时释放。</p>
<p>&emsp;&emsp;从入参staleSlot执行的位置开始遍历，如果发现Entry实例的引用已经无效，那么就把该Entry及其内部的value全部清空，反之则重新计算该Entry在当前ThreadLocalMap集合中的下标位置。</p>
<h4 id="private-void-set-ThreadLocal-key-Object-value"><a href="#private-void-set-ThreadLocal-key-Object-value" class="headerlink" title="private void set(ThreadLocal key, Object value)"></a><span id="setEntry">private void set(ThreadLocal key, Object value)</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// We don't use a fast path as with get() because it is at</span></span><br><span class="line">    <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">    <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">    <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将某个ThreadLocal实例和对应的变量内容存入到当前线程的ThreadLocalMap集合中。</p>
<p>&emsp;&emsp;第9行代码根据Threadlocal的threadLocalHashCode字段做取模运算得到了在集合的下标位置。从该下标位置开始遍历，如果发现了key一致的Entry实例，那么用入参value值替换当前Entry实例的value。如果发现当前Entry的引用指向无效，那么就调用<strong>replaceStaleEntry()</strong>函数完成替换操作。</p>
<p>&emsp;&emsp;如果在当前ThreadLocalMap集合中尚未发现可以匹配当前ThreadLocal的Entry实例，那么就新建一个Entry实例，并将该实例加入到当前集合的下标位置处。最后根据当时的实际情况决定是否需要调用<strong>rehash()</strong>方法完成元素调整操作。</p>
<h4 id="private-void-replaceStaleEntry-ThreadLocal-key-Object-value-int-staleSlot"><a href="#private-void-replaceStaleEntry-ThreadLocal-key-Object-value-int-staleSlot" class="headerlink" title="private void replaceStaleEntry(ThreadLocal key, Object value, int staleSlot)"></a>private void replaceStaleEntry(ThreadLocal key, Object value, int staleSlot)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal key, Object value, <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Back up to check for prior stale entry in current run.</span></span><br><span class="line">    <span class="comment">// We clean out whole runs at a time to avoid continual</span></span><br><span class="line">    <span class="comment">// incremental rehashing due to garbage collector freeing</span></span><br><span class="line">    <span class="comment">// up refs in bunches (i.e., whenever the collector runs).</span></span><br><span class="line">    <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find either the key or trailing null slot of run, whichever</span></span><br><span class="line">    <span class="comment">// occurs first</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we find key, then we need to swap it</span></span><br><span class="line">        <span class="comment">// with the stale entry to maintain hash table order.</span></span><br><span class="line">        <span class="comment">// The newly stale slot, or any other stale slot</span></span><br><span class="line">        <span class="comment">// encountered above it, can then be sent to expungeStaleEntry</span></span><br><span class="line">        <span class="comment">// to remove or rehash all of the other entries in run.</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line"></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start expunge at preceding stale entry if it exists</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we didn't find stale entry on backward scan, the</span></span><br><span class="line">        <span class="comment">// first stale entry seen while scanning for key is the</span></span><br><span class="line">        <span class="comment">// first still present in the run.</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If key not found, put new entry in stale slot</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there are any other stale entries in run, expunge them</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;用入参value替换掉当前ThreadLocalMap集合中key为入参key且匹配key的第一个无效元素的下标位置staleSlot。</p>
<p>&emsp;&emsp;方法最开始会遍历集合，确定第一个无效的元素位置。所以第10 ~ 15行代码做的就是这个事情，从当前staleSlot位置向前遍历找到第一个无效元素的下标索引。从第19行代码开始，执行真正的替换操作。这里有个地方需要注意一下：<strong>开始遍历的位置是在staleSlot位置的下一个位置</strong>。因为在调用当前方法时，已经确认了传入的staleSlot位置是无效元素的，所以可以正确的从下一个位置开始遍历和检查。在遍历过程中，如果当前Entry元素的引用指向和入参ThreadLocal一致，那么就将当前位置的Entry元素和staleSlot位置的元素完成交换操作。</p>
<p>&emsp;&emsp;第36 ~ 37代码的判断表明如果在第10 ~ 15行代码执行完成后发现staleSlot位置之前的元素都是有效的，那么当前位置 <strong>i</strong> 就是找到的第一个无效元素位置。第38行代码会在完成无效元素的清除工作后返回到方法调用处。</p>
<p>&emsp;&emsp;第45 ~ 46行代码中，如果当前Entry元素无效，且发现staleSlot位置之前的元素都是有效的，那么当前位置 <strong>i</strong> 就是找到的第一个无效元素位置。</p>
<p>&emsp;&emsp;第19 ~ 47行的遍历会一直进行直到遇到第一个不存储Entry实例的下标位置。</p>
<p>&emsp;&emsp;第50 ~ 51行代码完成了value值的替换更新操作。如果发现维护的第一个无效元素位置和入参staleSlot位置不一致，那么就清除自第一个无效元素位置起的无效元素内容。</p>
<h4 id="private-boolean-cleanSomeSlots-int-i-int-n"><a href="#private-boolean-cleanSomeSlots-int-i-int-n" class="headerlink" title="private boolean cleanSomeSlots(int i, int n)"></a>private boolean cleanSomeSlots(int i, int n)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        i = nextIndex(i, len);</span><br><span class="line">        Entry e = tab[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            n = len;</span><br><span class="line">            removed = <span class="keyword">true</span>;</span><br><span class="line">            i = expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;判断是否需要清空当前ThreadLocalMap集合中的无效元素。</p>
<p>&emsp;&emsp;从当前下标 <strong>i</strong> 开始（不包括 <strong>i</strong>），判断集合中的元素是否有效，如果无效，那么置removed标签为true，且调用方法expungeStaleEntry()完成无效元素的清除操作。</p>
<p>&emsp;&emsp;需要注意的是，这个方法的时间复杂度因为实际情况的不同而不一样。如果当前ThreadLocalMap集合确实存在无效元素，那么由于需要遍历和移动元素的缘故，导致其复杂度为O(n)。相反，如果在最开始的$log(n)$次操作中都没有发现无效的元素，那么就认为不需要做无效元素清除。</p>
<p>&emsp;&emsp;个人认为这么做的原因可能是出于执行效率的考虑吧。</p>
<h4 id="private-void-remove-ThreadLocal-key"><a href="#private-void-remove-ThreadLocal-key" class="headerlink" title="private void remove(ThreadLocal key)"></a><span id="removeEntry">private void remove(ThreadLocal key)</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal key)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            e.clear();</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;删除当前线程中指定的ThreadLocal变量实例。</p>
<p>&emsp;&emsp;根据threadLocalHashCode找到对应的元素，执行<strong>Entry.clear()</strong>方法完成引用关系断开的操作。这样就完成了Entry实例的删除操作，之后在GC执行时这些被断开的引用就会被GC回收掉并释放了其占用的内存。</p>
<p>&emsp;&emsp;最后会调用expungeStaleEntry()方法重新整理当前ThreadLocalMap集合中元素的存储位置关系。</p>
<h4 id="private-void-rehash"><a href="#private-void-rehash" class="headerlink" title="private void rehash()"></a>private void rehash()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use lower threshold for doubling to avoid hysteresis</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;重新排列当前ThreadLocalMap集合的元素存储位置。</p>
<p>&emsp;&emsp;首先调用 expungeStaleEntries()方法完成无效元素的清空操作。之后如果当前集合存储的Entry实例个数超过了当前ThreadLocalMap集合容量的一半（threshold是当前容量的$\frac{2}{3}$，所以第5行代码<strong>&gt;=</strong>的右边部分的值为$\frac{1}{2}$当前容量），那么就调用<strong>resize()</strong>方法执行扩容处理。扩容规则是按照当前集合容量的两倍进行扩容。</p>
<h4 id="private-void-expungeStaleEntries"><a href="#private-void-expungeStaleEntries" class="headerlink" title="private void expungeStaleEntries()"></a>private void expungeStaleEntries()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        Entry e = tab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;遍历整个ThreadLocalMap集合，清除无效的Entry引用。底层直接调用<strong>expungeStaleEntry()</strong>方法完成操作。</p>
<h4 id="private-void-resize"><a href="#private-void-resize" class="headerlink" title="private void resize()"></a>private void resize()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">    Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">        Entry e = oldTab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocal k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size = count;</span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;实际完成ThreadLocalMap集合扩容操作的方法。扩容规则是<strong>按照当前集合容量的两倍</strong>进行扩容。</p>
<p>&emsp;&emsp;在得到当前集合的容量后，按照两倍于当前集合容量的规则实例化一个新的Entry数组，遍历整个当前集合的数组，按照插入的过程将当前集合中的所有Entry元素全部插入到新的数组中。最后重新计算新的扩容阈值，并将新的数组指向table属性字段。</p>
<p>&emsp;</p>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li><p><strong>Hash冲突的解决方案：</strong></p>
<p>&emsp;&emsp;常用的方法有开放定址法、再哈希法、链地址法、建立公共溢出区等。其中，开放定址法又可细分为线性探测再散列、二次探测再散列和伪随机探测再散列等方法。</p>
<p>&emsp;&emsp;ThreadLocalMap采用的<strong>开放定址法中的线性探测再散列</strong>思想。开放定址法的基本思想是：如果关键字key的散列地址根据散列函数计算后出现冲突时，以计算得到的地址为基础，调用如下的再散列函数完成新的散列地址的计算：</p>
<script type="math/tex; mode=display">\begin{equation} H_i = (hash(key) + d_i) \% n，i = 1,2,3,4,\cdots,n \end{equation}</script><p>在线性探测再散列法中，$d_i = 1,2,3,4,5,6,\cdots,m$ 。其实就是当发生冲突时每次向后偏移一个单位，检查是否为空闲位置。</p>
</li>
<li><p><strong>强引用、软引用、弱引用的区别：</strong></p>
<p><strong>强引用</strong>：应用最频繁的一种引用方式，如果一个对象拥有强引用，那么GC将不会对其尝试进行垃圾回收操作，内存空间不足时通过抛出OutOfMemoryException异常的方式来提示GC回收异常。只有当对象的引用被清除后，GC才会对其尝试进行回收操作。示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object testObj = <span class="keyword">new</span> Object();   <span class="comment">//  强引用</span></span><br><span class="line">testObj = <span class="keyword">null</span>; <span class="comment">//GC可回收</span></span><br></pre></td></tr></table></figure>
<p><strong>软引用</strong>：如果一个对象拥有软引用，那么当内存空间足够时，GC不会对其尝试进行垃圾回收操作，如果内存空间不足时，GC会尝试回收其占用的内存空间。示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str=<span class="keyword">new</span> String(<span class="string">"MARCUS"</span>);                                     <span class="comment">// 强引用</span></span><br><span class="line">SoftReference&lt;String&gt; testObj=<span class="keyword">new</span> SoftReference&lt;String&gt;(str);     <span class="comment">// 软引用</span></span><br></pre></td></tr></table></figure>
<p><strong>弱引用</strong>：如果一个对象拥有弱引用，不管内存空间是否足够，GC工作时都会回收弱引用对象占用的内存空间。示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str=<span class="keyword">new</span> String(<span class="string">"MARCUS"</span>);    <span class="comment">// 强引用</span></span><br><span class="line">WeakReference&lt;String&gt; testObj = <span class="keyword">new</span> WeakReference&lt;String&gt;(str); <span class="comment">// 弱引用</span></span><br></pre></td></tr></table></figure>
<p>如图3和图4所示：</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1547200132/BlogImages/java-multiThread/java-multiThread-threadLocal-weakreference-sence1-demo.png" alt></p>
<div align="center">
<div align="center">图 - 3 弱引用关系建立</div>
&emsp;
</div>

<p>创建的弱引用关系在str还持有对“marcus”对象的引用时，GC不会对其做任何处理。</p>
<p><img src="https://res.cloudinary.com/jknight/image/upload/v1547200132/BlogImages/java-multiThread/java-multiThread-threadLocal-weakreference-sence2-demo.png" alt></p>
<div align="center">
<div align="center">图 - 4 强引用关系丢弃，弱引用对象被GC处理</div>
&emsp;
</div>

<p>当str对象不再持有对“marcus”对象的引用时，此时“marcus”对象是一个弱引用，原来对它的强引用str不再对其持有引用，所以GC可以对其进行回收处理。</p>
</li>
</ol>
<p>&emsp;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>陶邦仁. <a href="https://my.oschina.net/xianggao/blog/392440" target="_blank" rel="noopener">深入JDK源码之ThreadLocal类</a> [E]</li>
<li>技术世界. <a href="http://www.jasongj.com/java/threadlocal/" target="_blank" rel="noopener">Java进阶（七）正确理解Thread Local的原理与适用场景</a> [E]</li>
<li>bear13. <a href="https://my.oschina.net/u/852678/blog/1578079" target="_blank" rel="noopener">ThreadLocal源码浅析</a> [E]</li>
<li>你听__. <a href="https://juejin.im/post/5aeeb3e8518825672f19c52c" target="_blank" rel="noopener">一篇文章，从源码深入详解ThreadLocal内存泄漏问题</a> [E]</li>
</ol>
<p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK 1.7</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
</search>

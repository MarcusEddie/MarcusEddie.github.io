<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="google-site-verification" content="I-tP-pxN_zm4opKxF0P8T1R4yQMAPQ7OLMamNToLgTw">
    

    <title>
      K8s network之一：K8s网络模型与网络策略 | Mr.Muzi 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="Nathan R. Lee">
    
    

    <meta name="description" content="&amp;emsp;&amp;emsp;Kubernetes网络是Kubernetes得以正常工作的重要基础之一，这其中涉及到了包括但不限于IP地址划分、MAC地址学习、路由转发、服务发现、网络通信等诸多领域。借助于CNI接口及其实现产品，Kubernetes可以提供丰富的网络配置架构方案。关于Kubernetes网络，将会有一系列笔记，本篇是第一篇—关于Kubernetes网络模型和策略的初步学习，知其然，稍微">
<meta name="keywords" content="IP-Per-Pod,CNI,Container Network Interface,IPAM,Overlay,VXLAN,CNI插件,Network Policy,Kubernetes">
<meta property="og:type" content="article">
<meta property="og:title" content="K8s network之一：K8s网络模型与网络策略 | Mr.Muzi">
<meta property="og:url" content="https://marcuseddie.github.io/2021/K8s-Network-Architecture-section-one.html">
<meta property="og:site_name" content="Mr.Muzi">
<meta property="og:description" content="&amp;emsp;&amp;emsp;Kubernetes网络是Kubernetes得以正常工作的重要基础之一，这其中涉及到了包括但不限于IP地址划分、MAC地址学习、路由转发、服务发现、网络通信等诸多领域。借助于CNI接口及其实现产品，Kubernetes可以提供丰富的网络配置架构方案。关于Kubernetes网络，将会有一系列笔记，本篇是第一篇—关于Kubernetes网络模型和策略的初步学习，知其然，稍微">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://res.cloudinary.com/jknight/image/upload/v1623247049/BlogImages/CloudSerials/K8s-cluster-IP-allocation-demo.png">
<meta property="og:image" content="https://res.cloudinary.com/jknight/image/upload/v1623247220/BlogImages/CloudSerials/K8s-CNI-Structure.png">
<meta property="og:image" content="https://res.cloudinary.com/jknight/image/upload/v1623247301/BlogImages/CloudSerials/CNI-Plugins-Dependency.png">
<meta property="og:image" content="https://res.cloudinary.com/jknight/image/upload/v1623248224/BlogImages/CloudSerials/Overlay-Network-Demo-W.webp">
<meta property="og:image" content="https://res.cloudinary.com/jknight/image/upload/v1623247382/BlogImages/CloudSerials/VXLAN-Network-Model.png">
<meta property="og:image" content="https://res.cloudinary.com/jknight/image/upload/v1623247433/BlogImages/CloudSerials/VXLAN-Frame-Format-with-IPv4-Outer-Header.png">
<meta property="og:image" content="https://res.cloudinary.com/jknight/image/upload/v1623247519/BlogImages/CloudSerials/VXLAN-Frame-Format-with-IPv4-Outer-Header-Simple.png">
<meta property="og:image" content="https://res.cloudinary.com/jknight/image/upload/v1623248080/BlogImages/CloudSerials/MAC-Learning-In-a-VNI.webp">
<meta property="og:image" content="https://res.cloudinary.com/jknight/image/upload/v1623933012/BlogImages/CloudSerials/MAC-Learning-In-Different-VNI.webp">
<meta property="og:image" content="https://res.cloudinary.com/jknight/image/upload/v1624198377/BlogImages/CloudSerials/kubelet-cri-cni-flowchart.png">
<meta property="og:image" content="https://res.cloudinary.com/jknight/image/upload/v1623247691/BlogImages/CloudSerials/K8s-Network-Policy-Basic.png">
<meta property="og:image" content="https://res.cloudinary.com/jknight/image/upload/v1623247761/BlogImages/CloudSerials/Calico-Network-Policy-Implement.png">
<meta property="og:image" content="https://res.cloudinary.com/jknight/image/upload/v1623330489/BlogImages/CloudSerials/K8s-NetworkPolicy-Demo.webp">
<meta property="og:updated_time" content="2023-11-03T09:11:26.349Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="K8s network之一：K8s网络模型与网络策略 | Mr.Muzi">
<meta name="twitter:description" content="&amp;emsp;&amp;emsp;Kubernetes网络是Kubernetes得以正常工作的重要基础之一，这其中涉及到了包括但不限于IP地址划分、MAC地址学习、路由转发、服务发现、网络通信等诸多领域。借助于CNI接口及其实现产品，Kubernetes可以提供丰富的网络配置架构方案。关于Kubernetes网络，将会有一系列笔记，本篇是第一篇—关于Kubernetes网络模型和策略的初步学习，知其然，稍微">
<meta name="twitter:image" content="https://res.cloudinary.com/jknight/image/upload/v1623247049/BlogImages/CloudSerials/K8s-cluster-IP-allocation-demo.png">
    
    
    
      <link rel="icon" type="image/x-icon" href="/images/icon_log1.png">
    
    <link rel="stylesheet" href="/css/uno.css">
    <link rel="stylesheet" href="/css/hint.min.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/archive.css">
    <link rel="stylesheet" href="/css/china-social-icon.css">
    <link rel="stylesheet" href="/css/font-awesome.css">
    <link rel="stylesheet" href="/css/suspend.css">
    <link rel="stylesheet" href="/css/popup.css">

</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    <div class="suspend">
      <div class="site-search">
        <div class="popup">
          <span class="search-icon fa fa-search"></span>
          <input type="text" id="local-search-input" placeholder="输入关键字">
          <div id="local-search-result"></div>
          <span class="popup-btn-close">close</span>
        </div>
      </div>      
    </div>
    
    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

  
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        
        <a href="/" title="link to homepage for Mr.Muzi"><img src="/images/icon_log1.png" width="80" alt="Mr.Muzi logo" class="panel-cover__logo logo"></a>
        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">Mr.Muzi</a></h1>
        <hr class="panel-cover__divider">

        
        <p class="panel-cover__description">
          一只很安静的monkey
        </p>
        <hr class="panel-cover__divider panel-cover__divider--secondary">
        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/library" title class>图书馆</a></li>
              
                
                <li class="navigation__item"><a href="/archive" title class>归档</a></li>
              
                
                <li class="navigation__item"><a href="/en/#blog" title class>英文</a></li>
              
                
                <li class="navigation__item"><a href="/about" title class>关于</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



<nav class="cover-navigation navigation--social">
  <ul class="navigation">

    
      <!-- Github -->
      <li class="navigation__item">
        <a href="https://github.com/MarcusEddie" title="GitHub">
          <i class="icon icon-social-github"></i>
          <span class="label">GitHub</span>
        </a>
      </li>
    

    
      <!-- Github -->
      <li class="navigation__item">
        <a href="javascript:;" class="popup-trigger" title="search">
          <i class="icon icon-page-search"></i>
          <span class="label">Search</span>
        </a>
      </li>
    

    <!-- China social icon -->
    <!--
    
      <li class="navigation__item">
        <a href="" title="">
          <i class='icon cs-icon-douban'></i>
          <span class="label">Douban</span>
        </a>
      </li>

      <li class="navigation__item">
        <a href="" title="">
          <i class='icon cs-icon-weibo'></i>
          <span class="label">Weibo</span>
        </a>
      </li>

    -->



  </ul>
</nav>



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">
  	<header class="post-header">
	    <h1 class="post-title"><b>K8s network之一：K8s网络模型与网络策略</b></h1>
	    
		    <div class="post-meta">
		      	<time datetime="2021-04-24" class="post-meta__date date">2021-04-24</time> 
		        <span class="post-meta__count count">字数统计:&nbsp;8k&emsp;阅读时长:&nbsp;30&nbsp;mins</span>
		      	<span class="post-meta__tags tags">
			        
			            <font class="categories">
				            &#8226; 分类:
				            <a class="categories-link" href="/categories/Cloud-Computing/">Cloud Computing</a>
			            </font>
			        

			        
			            &#8226; 标签:
			            <font class="tags">
			              	<a class="tags-link" href="/tags/CNI/">CNI</a>, <a class="tags-link" href="/tags/Kubernetes/">Kubernetes</a>, <a class="tags-link" href="/tags/network/">network</a>
			            </font>
			        
		    	</span>
		    </div>
	    
  	</header>

  	<section id="post-content" class="article-content post">
  		

    	<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;Kubernetes网络是Kubernetes得以正常工作的重要基础之一，这其中涉及到了包括但不限于IP地址划分、MAC地址学习、路由转发、服务发现、网络通信等诸多领域。借助于CNI接口及其实现产品，Kubernetes可以提供丰富的网络配置架构方案。关于Kubernetes网络，将会有一系列笔记，本篇是第一篇—关于Kubernetes网络模型和策略的初步学习，知其然，稍微知其所以然。出于篇幅考虑，相关的yaml配置不会在文章中出现，特殊情况除外，相关的yaml配置可以参考<a href="https://kubernetes.io/" target="_blank" rel="noopener">Kubernetes</a>官方文档。</p>
<a id="more"></a>
<p>&emsp;&emsp;<a href="/2021/K8s-Network-Architecture-section-two.html">2. K8s network之二：Kubernetes的域名解析、服务发现和外部访问</a> </p>
<p>&emsp;&emsp;<a href="/404.html">3.Linux网络在Kubernetes集群中的应用</a> </p>
<p>&emsp;&emsp;<a href="/2021/K8s-Network-Architecture-section-four.html">4.K8s network之四：Kubernetes集群通信的实现原理</a> </p>
<p>&emsp;&emsp;<a href="/2021/K8s-Network-Architecture-section-five.html">5.K8s network之五：Kubernetes集群Pod和Service之间通信的实现原理</a> </p>
<h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><p>&emsp;&emsp;Kubernetes网络模型遵循的一个核心原则是每个Pod都拥有一个唯一且独立的IP地址，只要彼此通信的Pod在同一个集群里，那么就可以通过IP地址的方式实现Pod间的直接访问而无需借助其他工具和手段，即使它们不在同一个node节点上。也就是说，同一个集群里的所有Pod形成了一个扁平的、可相互通信的网络组织。于是乎，每个Pod可以像虚拟机或者物理机实体那样执行诸如端口分配、命名、服务发现、负载均衡、应用配置和迁移等动作。因此，基于这个核心原则建立的模型就是“<strong>IP-Per-Pod</strong>”模型。</p>
<p>&emsp;&emsp;<strong>IP-Per-Pod</strong>模型认为，Pod之间会通过目标方的IP地址来完成通信和交互行为，无论是在Pod的内部还是外部，这个Pod的IP地址、端口等信息都是一致的，因此，Pod内部和外部之间、Pod和Pod之间、Node和Pod之间也就不再需要NAT操作来确保通信成功。没有了NAT之后，整个集群的通信性能会更好，源地址伪装的情况也就不复存在，因此具备了源地址可溯源的能力，对于集群维护和排障都有非常重要的帮助。而且这个模型可以很好的兼容现有的应用架构，如果我们的应用是运行在虚拟机上，每个虚拟机有自己的IP地址而且彼此之间可以相互通信，那么这个应用就可以很容易的迁移到Kubernetes集群上，降低成本和风险。这个模型还有另外一个好处，那就是同一个Pod内的容器之间共享了同一个网络命名空间，这些容器之间通过同一个IP地址对外发送消息，通过同一个IP地址接收来自Pod之外的消息。它们相互之间的访问可以通过localhost加端口的形式直接访问。在整个集群范围内，每个Node都有一个与其他Node节点无交集的IP地址段，这个IP地址段内的IP地址会拿来分配给该节点上的Pod使用。</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1623247049/BlogImages/CloudSerials/K8s-cluster-IP-allocation-demo.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 1 Kubernetes 集群网络IP分布 </div>
&emsp;
</div>

<p>为了保证集群的正常运行和工作，Kubernetes对集群网络提出了如下的要求：</p>
<ol>
<li>任意节点上的Pod可以在不借助NAT的情况下与任意节点上的任意Pod进行通信；</li>
<li>节点上的代理（诸如系统守护进程、kubelet等）可以在不借助NAT的情况下与该节点上的任意Pod进行通信；</li>
<li>处于一个节点的主机网络中的Pod可以在不借助NAT的情况下与任意节点上的任意Pod进行通信（当且仅当支持Pod运行在主机网络的平台上，比如Linux等）；</li>
<li>不论在Pod内部还是外部，该Pod的IP地址和端口信息都是一致的。</li>
</ol>
<p>在上述要求得到保证后，Kubernetes网络主要聚焦于两个任务—<strong>IP地址管理和路由</strong>，并致力于解决如下问题：</p>
<ol>
<li>同一个Pod内多个容器之间如何通信</li>
<li>同一个Node节点中多个Pod之间如何通信</li>
<li>不同Node节点上的多个Pod之间如何通信</li>
<li>Pod和Service之间如何通信</li>
<li>Pod和集群外的实体如何通信</li>
<li>Service和集群外的实体如何通信</li>
</ol>
<h2 id="Container-Network-Interface（CNI）"><a href="#Container-Network-Interface（CNI）" class="headerlink" title="Container Network Interface（CNI）"></a>Container Network Interface（CNI）</h2><p>&emsp;&emsp;众所周知，Kubernetes是由Google开源并维护的一个容器编排工具，是Google十多年容器技术应用经验的集大成之作。于是乎，支撑Kubernetes正常工作的公有云GCE（Google Compute Engine Network）自然满足上述提及的各种要求。但并非所有的Kubernetes集群都部署在GCE、AWS、Azure等公有云环境上，私有云的部署方案也日渐增多。在这种情况下，如何保证集群网络可以满足Kubernetes的要求就成为了一个首要问题。换句话说，Kubernetes仅关注和负责容器编排领域的相关事宜，而网络管理并不是它最核心的分内之事。起初，Kubernetes通过开发Kubenet来实现网络管理功能以提供满足要求的集群网络。Kubenet是一个非常简单、基础的网络插件实现。但它本身并不支持任何跨节点之间的网络通信和网络策略等高级功能，且仅适用于Linux系统，所以Kubernetes试图找到一个更优秀的方案来替代Kubenet。为了解决这个问题，CoreOs公司和Docker各自推出了<strong>CNI</strong>（Container Network Interface）和<strong>CNM</strong> (Container Network Model）规范，CNI以其完善的规范和优雅的设计击败了CNM，并成为了Kubernetes首选的网络插件接口规范。</p>
<p>&emsp;&emsp;CNI的基本思想是在容器运行时环境中创建容器时，先创建好网络命名空间（netns），然后调用CNI插件为这个网络命名空间配置网络，之后再启动容器内的进程。CNI通过Json Schema定义了容器运行环境和网络插件之间的接口声明，描述当前容器网络的配置和规范，尝试通过一种普适的方式来实现容器网络的标准化 。它仅专注于在创建容器时分配网络资源（IP、网卡、网段等）和在容器被回收时如何删除网络资源两个方面的能力。CNI作为Kubernetes和底层网络之间的一个抽象存在，屏蔽了底层网络实现的细节、实现了Kubernetes和具体网络实现方案的解耦，继而为Kubernetes建立一个满足其运行要求的网络组织结构，同时也克服了Kubenet不能实现跨主机容器间的相互通信等不足和短板。CNI凭借其轻便、实现成本小等优点，成功地被Kubernetes、rkt、Apache Mesos等项目所认可和采纳，各个公司和社区也发布了包括但不限于Flannel、Calico、Weave等CNI规范实现方案，进一步增强了CNI规范的影响力。</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1623247220/BlogImages/CloudSerials/K8s-CNI-Structure.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 2 CNI <sup id="fnref:1" style="font-size:80%;line-height:80%;"><a href="#fn:1" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[1]</span></a></sup> </div>
&emsp;
</div>

<p>&emsp;&emsp;如前所述，CNI规范只是一个规范，规定了如何连接容器编排系统（比如K8s）和网络插件以完成Pod网络管理。实际执行Pod网络管理的是遵循CNI规范的各个CNI网络插件，目前官方提供的CNI网络插件包括如下三类<sup id="fnref:2" style="font-size:80%;line-height:80%;"><a href="#fn:2" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[2]</span></a></sup>：</p>
<p><strong>Main: interface-creating</strong></p>
<ul>
<li>bridge: 创建一个桥接网络，并将宿主机和容器加入到这个桥接网络中</li>
<li>ipvlan: 在容器中加入一个<a href="https://www.kernel.org/doc/Documentation/networking/ipvlan.txt" target="_blank" rel="noopener">ipvlan</a>接口</li>
<li>loopback: 设置环回接口的状态为up状态</li>
<li>macvlan: 创建一个新的mac地址，并将所有到该地址的流量转发到容器</li>
<li>ptp: 创建一个新的veth对</li>
<li>vlan: 分配一个vlan设备</li>
<li>host-device: 将宿主机现有的网络接口移到容器内。</li>
</ul>
<p><strong>IPAM: IP address allocation</strong></p>
<ul>
<li>dhcp: 在宿主机上运行一个daemon进程并代表容器发起DHCP请求。</li>
<li>host-local: 维护一个已分配IP的本地数据库</li>
<li>static: 向容器分配一个静态的IPv4/IPv6地址，这个地址仅用于调试目的。</li>
</ul>
<p><strong>Meta: other plugins</strong></p>
<ul>
<li>flannel: 根据flannel配置文件生成一个网络接口</li>
<li>tuning: 调整一个已有网络接口的sysctl参数</li>
<li>portmap: 一个基于iptables的端口映射插件，将宿主机地址空间的端口映射到容器中</li>
<li>bandwidth: 通过流量控制工具tbf来实现带宽限制</li>
<li>sbr: 为接口配置基于源IP地址的路由</li>
<li>firewall: 一个借助iptables或者firewalld来添加规则来限制出入容器流量的防火墙插件。</li>
</ul>
<p>&emsp;&emsp;针对这三种类型的插件，官方都提供了一些内置的实现方案可供用户直接使用。Main插件也称为“网络插件（NetPlugin）”，它是一个由容器编排系统调用的可执行文件，实现某种特定的网络功能，负责创建/删除网络、向容器的网络空间插入一个网络接口以及向网络添加/删除容器，专注于连通容器与容器之间以及容器和宿主机之间的通信。</p>
<p>&emsp;&emsp;为网络接口分配和维护IP地址以及配置与该接口相关的路由信息是CNI插件的一个重要职责，这使得CNI插件变得更加灵活的同时也带来了很大的负担。诸多CNI插件为了向用户提供期望的IP管理功能（诸如DHCP、HOST-LOCAL等）可能会使用相同的代码实现。为了减轻CNI插件的负担，也为了让IP管理策略和前述的NetPlugin插件的职责和功能相互独立，于是便定义了一种新的插件类型—<strong>IPAM</strong>（IP Address Management）。IPAM不提供网络功能，仅负责创建/删除IP地址池以及分配/回收容器的IP地址。IPAM由Main插件调用，并向Main插件提供接口的IP、子网、网关、路由等信息，与Main插件协同完成工作。IPAM的独立使得各个网络插件可以基于自己的实际需要和期望选择最适合自己的IPAM策略。</p>
<p>&emsp;&emsp;和Main插件一样，IPAM也是一个可执行文件，通过变量CNI_PATH指定IPAM的二进制文件位置，和Main插件共享相同的环境变量，并且通过stdin和stdout接收网络配置和返回结果输出。如果执行结果是成功状态，那么会返回一个0标识执行状态，并将成功执行的结果类型输出到stdout。</p>
<p>&emsp;&emsp;Meta插件不实现任何网络功能，不参与IP地址分配和回收，它调用其他网络工具或者插件完成一些管理或者测试功能。</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1623247301/BlogImages/CloudSerials/CNI-Plugins-Dependency.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 3 CNI插件依赖关系</div>
&emsp;
</div>

<p>&emsp;&emsp;在上述的三个插件中，Main插件是最重要的一个，由它来完成创建虚拟网络、为Pod生成网络接口设备、将Pod接入网络等核心任务。除了上面的提到的几种内置实现方案，诸多公司和社区也提供了遵循CNI规范的第三方插件实现，他们中的大多数属于Main插件类型，致力于提供Netplugin功能，用来提供配置容器接口和网络。也有不少方案甚至能够支持Kubernetes的网络策略。这些第三方插件实现常用的网络架构有Overlay网络和Underlay网络两大类：</p>
<ul>
<li><strong>Overlay 网络:</strong> 一个建立在现有物理网络之上的虚拟的、逻辑的网络。Overlay网络是建立在已有物理网络上的虚拟网络，具有独立的控制和转发平面，对于连接到Overlay的终端设备（例如服务器）来说，物理网络是透明的，从而可以实现承载网络（物理网络）和业务网络（逻辑网络）的分离。</li>
<li><strong>Underlay 网络：</strong>就是传统IT基础设施网络架构，由交换机、路由器、网关等设备主组成，借助以太网协议、路由协议和VLAN协议等诸多协议完成网络通信和维护。此外，它还是Overlay网络的底层支撑网络，为Overlay网络提供数据通信服务。在容器技术中，Underlay网络特指借助驱动程序将宿主机的底层网络接口直接暴露给容器使用的一种网络构建技术，常用的实现方案包括MacVLAN、IP VLAN 和直接路由等。</li>
</ul>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1623248224/BlogImages/CloudSerials/Overlay-Network-Demo-W.webp" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 4 Overlay 网络架构</div>
&emsp;
</div>

<p>&emsp;&emsp;Overlay借助VXLAN、UDP、IPIP、GRE等隧道协议建立通信隧道，通过隧道协议报文封装边缘设备之间的通信报文（二层的以太网帧或者三层的IP数据包）来构建虚拟网络。隧道转发数据的实质就是将通信设备的通信报文封装成各自边缘设备之间的报文，通过建立在边缘设备之间的网络隧道完成数据传输。这种方案只需要相互通信的边缘设备之间支持隧道协议即可，对底层网络没有任何特殊要求。Overylay网络通常由两个平面构成：控制平面和数据平面。控制平面专注于如下三个职责：</p>
<ol>
<li>服务发现。边缘设备如何感知其他边缘设备的存在，以便建立Overlay隧道</li>
<li>地址通告和映射。边缘设备如何交换其学习到的可达信息（包括但不限于Mac、IP以及其他相关地址信息）</li>
<li>隧道管理。这里需要SDN控制器的参与，由于SDN控制器了解整个网络的拓扑结构，便可以实现基于控制器的地址学习，提高了可靠性和扩展性</li>
</ol>
<p>而Overlay的数据平面则提供数据封装功能，并通过底层的物理承载网络实现数据传输。</p>
<p>&emsp;&emsp;上述协议中，<strong>VXLAN</strong>（Virtual Extensible LAN，虚拟可扩展局域网）是目前最流行的构建Overlay网络隧道的协议之一，是由ITEF定义的NVO3（Network Virtualization Over Layer 3）标准技术之一，采用<strong>L2 over L4（MAC-in-UDP）</strong>的报文封装格式，将二层报文用三层协议进行封装，依托UDP层构建overlay逻辑网络，使逻辑网络与物理网络解耦，满足快速变化的组网需求。VXLAN这类隧道网络的一个特点是对原有的网络架构影响小，不需要对原网络做任何改动，就可在原网络的基础上构建一层新的网络。VXLAN有点类似于VLAN，但是提供了比VLAN更好的灵活性和能力，相较于VLAN最多只能提供4096个网络ID而言，VXLAN可以提供最多16777216个网络ID（即 $2 ^ {24}$）。VXLAN的基本模型如下图所示：</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1623247382/BlogImages/CloudSerials/VXLAN-Network-Model.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 5 VXLAN网络工作模型</div>
&emsp;
</div>

<p>VXLAN主要有如下几个部分/概念组成：</p>
<ul>
<li>VTEP（VXLAN Tunnel End Point，VXLAN隧道端点）。VTEP是隧道的端点设备，由VTEP负责建立隧道。VXLAN的相关处理都在VTEP上进行，包括但不限于识别数据帧所属的VXLAN，数据帧的封装/解封装等。每个VTEP提供两个接口，一个接口负责本地主机桥接供能，另一个连接物理核心网络提供隧道建立和VXLAN封装/解封装等服务。</li>
<li>VNI（VXLAN Network Identifier，VXLAN网络识别号）。用来标识一个二层网络分段，一个VNI代表一个VXLAN网络段，可以分配一个用户/租户使用。不同的VNI之间不能直接通信。VNI的范围最大可达16777216（即 $2 ^ {24}$）。</li>
<li>VXLAN Tunnel。隧道是一个物理上没有对应实体的逻辑概念，两个VTEP设备之间建立隧道后便可以认为它们在直接通信。VXLAN报文在隧道之间传输。</li>
<li>BD（Broadcast Domain，广播域）。用来在VXLAN中划分广播域，在同一个广播域中的设备可以直接进行二层通信。同时，一个VNI映射一个BD。</li>
</ul>
<p>和其他协议一样，VXLAN在工作过程中也需要遵循一定的规范。在RFC 7348 <sup id="fnref:3" style="font-size:80%;line-height:80%;"><a href="#fn:3" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[3]</span></a></sup>中，给出了VXLAN报文的格式规范：</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1623247433/BlogImages/CloudSerials/VXLAN-Frame-Format-with-IPv4-Outer-Header.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 6 VXLAN帧格式（IPv4格式）</div>
&emsp;
</div>

<p>Inner Ethernet Header和Payload属于原生的二层以太网帧结构。</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1623247519/BlogImages/CloudSerials/VXLAN-Frame-Format-with-IPv4-Outer-Header-Simple.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 7 VXLAN帧格式（IPv4格式）抽象</div>
&emsp;
</div>

<p>&emsp;&emsp;VXLAN在正式通信之间需要先保证VTEP之间相互了解对方的存在及地址等相关信息。特别是当VTEP之间是首次通信时，由于本地的MAC表中并没有维护对方的MAC地址信息，所以需要通过ARP请求来进行MAC地址的学习。如果两个VTEP处于同一个VNI时，MAC学习过程如下：</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1623248080/BlogImages/CloudSerials/MAC-Learning-In-a-VNI.webp" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 8 VXLAN 同一VNI下VTEP的MAC学习过程</div>
&emsp;
</div>

<p>在完成MAC学习后，VTEP设备之间即可根据学习到的MAC地址信息相互通信。</p>
<p>&emsp;&emsp;如果两个VTEP不在同一个VNI时，需要借助三层网关设备完成通信操作，具体流程如下：</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1623933012/BlogImages/CloudSerials/MAC-Learning-In-Different-VNI.webp" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 9 VXLAN 不同一VNI下VTEP的通信过程</div>
&emsp;
</div>

<p>Kubernetes目前支持两种网络插件的实现：</p>
<ul>
<li><p>CNI插件：根据CNI规范实现其接口，以与插件提供者进行对接。</p>
</li>
<li><p>kubenet插件：使用bridge和host-local CNI插件实现一个基本的cbr0。</p>
</li>
</ul>
<p>为了在Kubernetes集群中使用网络插件，需要在kubelet服务的启动参数上设置下面两个参数：</p>
<ul>
<li>—network-plugin-dir：kubelet启动时扫描网络插件的目录。</li>
<li>—network-plugin：网络插件名称，对于CNI插件，设置为cni即可，无须关注—network-plugin-dir的路径。对于kubenet插件，设置为kubenet，目前仅实现了一个简单的cbr0 Linux网桥。</li>
</ul>
<p>在设置—network-plugin=”cni”时，kubelet还需设置下面两个参数。</p>
<ul>
<li>—cni-conf-dir：CNI插件的配置文件目录，默认为/etc/cni/net.d。该目录下配置文件的内容需要符合CNI规范。</li>
<li>—cni-bin-dir：CNI插件的可执行文件目录，默认为/opt/cni/bin。</li>
</ul>
<p>&emsp;&emsp;Kubernetes借助CNI插件体系组合满足需要的网络插件完成网络配置和维护功能。在创建或删除Pod时，Kubelet在默认的<strong>—cni-conf-dir</strong>目录下查找JSON格式的CNI配置文件，基于该配置文件中各插件的type属性（指明要调用的网络插件的名称）到<strong>—cni-bin-dir</strong>中查找相关插件的二进制可执行文件，执行它们以完成创建虚拟设备接口到相关的底层网络、为其设置IP地址、路由信息并将其添加到Pod的网络命名空间等操作。</p>
<p>&emsp;&emsp;在创建Pod的过程中，当Scheduler选定了一个Node节点来运行新创建的Pod时，该节点上的kubelet收到消息后会完成一个Pod的创建工作，当涉及到网络部分时，它首先会读取刚才我们所说的配置目录中的配置文件，获得将要使用的插件的相关信息。然后进入插件的可执行文件的目录来执行指明的 CNI 插件的二进制文件，由 CNI 插件进入 Pod 的网络空间去配置 Pod 的网络。</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1624198377/BlogImages/CloudSerials/kubelet-cri-cni-flowchart.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 10 kubelet调用CRI和CNI流程 <sup id="fnref:4" style="font-size:80%;line-height:80%;"><a href="#fn:4" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[4]</span></a></sup></div>
&emsp;
</div>

<p>&emsp;&emsp;在面对诸多的CNI插件实现时，我们需要结合自身的实际情况和未来期望来选择一个最合适我们自己的产品。在进行评估时可以从如下角度来选择：</p>
<ol>
<li><p>应用场景</p>
<ol>
<li><p>虚拟化环境</p>
<p> 虚拟环境（以OpenStack为例）因实现方案不同可能会对网络产生很多限制，比如不允许L2访问、限制机器可以使用的IP范围等。在这种网络限制比较严格的环境中，Overlay插件是更好的选择。常见的包括但不限于Flannel-vxlan, Calico-ipip, Weave等。</p>
</li>
<li><p>物理机环境</p>
<p> 物理机因为是真实的物理环境，对网络的限制相较于虚拟化环境来说会宽松很多。所以除了Overlay之外也可以选择Underlay或者直接路由模式。这种环境下可以考虑Calico-bgp等。</p>
</li>
<li><p>公有云环境</p>
<p> 公有云通常会考虑适配容器来提高容器性能，因此会提供一些CNI插件来实现兼容和性能最大化。如果有，选择公有云提供的CNI插件会是更优解。</p>
</li>
</ol>
</li>
<li><p>功能需要</p>
<ol>
<li><p>安全相关</p>
<p> 尽管Kubernetes原生支持网络策略（Network Policy），但是不是所有的CNI插件都实现了这个功能。所以如果需要网络策略的相关服务，就可以过滤掉那些不支持网络策略的插件了。常见的支持网络策略的插件包括但不限于Calico、Weave等。</p>
</li>
<li><p>是否需要与集群外通信</p>
<p> 如果Kubernetes上的应用有对应的非容器化版本，或者说Kubernetes上的应用需要和非云环境下的应用通信，那么就需要考虑集群外通信能力。此时就需要考虑Underlay网络架构而非Overlay网络架构。<a href="https://github.com/hustcat/sriov-cni" target="_blank" rel="noopener">sriov-cni</a>保证了Pod和虚拟机或者物理机可以在同一层网络，Calico的BGP模式实现了处于不同网段的集群网络和非集群网络（物理机、虚拟机）可以通过BGP路由机制实现相互通信。</p>
</li>
<li><p>是否需要Kubernetes的服务发现和负载均衡能力</p>
<p> Kubernetes的Service机制实现了高效的服务发现和负载均衡机制，但并非所有的CNI插件都能支持这两种能力。</p>
</li>
</ol>
</li>
<li><p>性能考量</p>
<ol>
<li><p>Pod的创建性能</p>
<p> Pod的创建性能限制了在诸如业务高峰等场景下需要紧急扩容来应对海量流量以及创建大量Pod的能力。Overlya和直接路由模式只需要通过调用内核接口就可以执行虚拟化操作完成创建Pod所需要的网络组件，所以速度会非常快。相反，Underlay需要创建所需的底层物理网络资源，所以相对来说会慢一些。</p>
</li>
<li><p>Pod的网络性能</p>
<p> 由于Overlay网络在相互通信时需要额外的封装/解封装操作，以及由此带来的一些资源开销，所以传输性能会差一些。如果对这些开销敏感，那么就需要考虑Underlay网络或者路由模式。</p>
</li>
</ol>
</li>
</ol>
<h2 id="网络策略"><a href="#网络策略" class="headerlink" title="网络策略"></a>网络策略</h2><p>&emsp;&emsp;在Kubernetes中，所有的Pod之间默认是允许通信的，但是在实际的生产业务中普遍存在允许满足某些条件的Pod访问的同时拒绝满足另一些条件的Pod的访问，这个时候就需要引入Network Policy（网络策略）来提供Pod访问的准入控制。Kubernetes从v1.3开始引入NetworkPolicy资源对象来定义网络策略，使得Kubernetes可以在<strong>IP地址/端口级别（OSI第三/四层）</strong>实现更为精细的流量控制，实现租户隔离机制。与此相对应的，还需要有一个Policy Controller（策略控制器）协作完成实际的网络准入控制。需要注意的是，控制器的实现是由第三方网络组件而非Kubernetes完成的，目前<a href="https://www.projectcalico.org" target="_blank" rel="noopener">Calico</a>、<a href="https://cilium.io" target="_blank" rel="noopener">Cilium</a>、<a href="https://www.kube-router.io" target="_blank" rel="noopener">Kube-router</a>、<a href="https://romana.io" target="_blank" rel="noopener">Romana</a>、<a href="https://www.weave.works/oss/net/" target="_blank" rel="noopener">Weave Net</a>等开源项目均支持网络策略的实现。就Kubernetes暴露的API而言，Kubernetes的网络策略实现了如下特性：</p>
<ul>
<li>策略可以是命名空间级别的</li>
<li>策略通过标签选择器作用于Pod上</li>
<li>策略规则可以基于Pods、命名空间、CIDR进行设置</li>
<li>策略规则可以基于协议（TCP/UDP/SCTP）、端口号进行设置（注：SCTP自Kubernetes v1.12后支持）</li>
</ul>
<p>&emsp;&emsp;网络策略规定Pod的流量分为流入流量（Ingress）和流出流量（Egress）两个类型，每个类型的流量有允许通过和禁止通过两个动作。默认情况下（也就是没有设置任何网络策略）Pod之间可以任意互联互通。但是一旦针对某个特定的Pod设置了网络策略，那么只有满足策略声明的流量允许通过。网络策略的基本工作原理如下图所示：</p>
<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1623247691/BlogImages/CloudSerials/K8s-Network-Policy-Basic.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 11 Kubernetes网络策略基本工作原理 <sup id="fnref:5" style="font-size:80%;line-height:80%;"><a href="#fn:5" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[5]</span></a></sup></div>
&emsp;
</div>
&emsp;&emsp;以Calico为例，Calico在每个工作节点都借助Linux 内核实现了一个高效的虚拟路由器vRouter来负责数据通信。每个 vRouter 都通过BGP协议把在本节点上运行的Pod的路由信息向整个Calico网络广播，并自动设置到达其他节点的路由转发规则。Calico保证所有Pod之间的数据流量都是通过IP路由的方式完成通信。Calico节点组网时可以直接利用数据中心的网络结构，不需要额外的NAT、隧道或者Overlay Network，由于不存在额外的封包解包，所以一定程度上能够有效提高网络通信效率。

<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1623247761/BlogImages/CloudSerials/Calico-Network-Policy-Implement.png" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center">图 - 12 Calico网络策略实现原理 <sup id="fnref:6" style="font-size:80%;line-height:80%;"><a href="#fn:6" rel="footnote" style="font-size:80%;line-height:80%;"><span style="font-size:80%;line-height:80%;">[6]</span></a></sup></div>
&emsp;
</div>
网络策略的配置文件如下所示：

<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: NetworkPolicy</span><br><span class="line">metadata:</span><br><span class="line">  name: NP-NRL</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  podSelector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      role: db-MySQL</span><br><span class="line">  policyTypes:</span><br><span class="line">  - Ingress</span><br><span class="line">  - Egress</span><br><span class="line">  ingress:</span><br><span class="line">  - from:</span><br><span class="line">    - ipBlock:</span><br><span class="line">        cidr: 172.17.0.0/16</span><br><span class="line">        except:</span><br><span class="line">        - 172.17.1.0/24</span><br><span class="line">    - namespaceSelector:</span><br><span class="line">        matchLabels:</span><br><span class="line">          project: backend-service</span><br><span class="line">    - podSelector:</span><br><span class="line">        matchLabels:</span><br><span class="line">          role: bk-service</span><br><span class="line">    ports:</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 80</span><br><span class="line">  egress:</span><br><span class="line">  - to:</span><br><span class="line">    - ipBlock:</span><br><span class="line">        cidr: 10.0.0.0/24</span><br><span class="line">    ports:</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 5978</span><br></pre></td></tr></table></figure>

<div style="text-align: center; width: 100%;">
<img src="https://res.cloudinary.com/jknight/image/upload/v1623330489/BlogImages/CloudSerials/K8s-NetworkPolicy-Demo.webp" style="margin: 0 auto;">
</div>
<div align="center">
    <div align="center"><br>图 - 13 Network Policy 配置实例</div>
&emsp;
</div>

<p>&emsp;&emsp;关于<strong>namespaceSelector</strong>和<strong>podSelector</strong>，需要作一些说明：在入站和出站配置中，<strong>namespaceSelector</strong>和<strong>podSelector</strong>可以单独设置，也可以组合配置。如果仅配置<strong>podSelector</strong>，则表示podSelector指定的Pod与spec部分中指定的Pod处在同一个命名空间；如果两者都有配置，则指的是<strong>namespaceSelector</strong>指定的命名空间下的符合podSelector规则的Pod会被选中参与策略控制行为。</p>
<p>&emsp;&emsp;Kubernetes还提供了命名空间级别的网络策略配置，以方便管理员对整个Namespace进行统一的网络策略设置。默认提供了如下5种类型的控制策略：</p>
<ul>
<li><p>默认拒绝所有入站流量</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: NetworkPolicy</span><br><span class="line">metadata:</span><br><span class="line">  name: default-deny-ingress</span><br><span class="line">spec:</span><br><span class="line">  podSelector: &#123;&#125;</span><br><span class="line">  policyTypes:</span><br><span class="line">  - Ingress</span><br></pre></td></tr></table></figure>
<p>  创建选择所有Pod但不允许任何进入这些Pod的入站流量的名为<strong>default-deny-ingress</strong>策略。这样即使Pod没有选择其他策略，也会被隔离。 此策略不会更改默认的出口隔离行为。</p>
</li>
<li><p>默认允许所有入站流量</p>
  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: NetworkPolicy</span><br><span class="line">metadata:</span><br><span class="line">  name: allow-all-ingress</span><br><span class="line">spec:</span><br><span class="line">  podSelector: &#123;&#125;</span><br><span class="line">  ingress:</span><br><span class="line">  - &#123;&#125;</span><br><span class="line">  policyTypes:</span><br><span class="line">  - Ingress</span><br></pre></td></tr></table></figure>
<p>  创建允许所有流量进入某个名字空间中的所有 Pod的名为<strong>allow-all-ingress</strong>的策略。</p>
</li>
<li><p>默认拒绝所有出站流量</p>
  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: NetworkPolicy</span><br><span class="line">metadata:</span><br><span class="line">  name: default-deny-egress</span><br><span class="line">spec:</span><br><span class="line">  podSelector: &#123;&#125;</span><br><span class="line">  policyTypes:</span><br><span class="line">  - Egress</span><br></pre></td></tr></table></figure>
<p>  创建选择所有Pod但不允许来自这些Pod的任何出站流量的名为<strong>default-deny-egress</strong>的策略。此策略可以确保即使没有被其他任何策略选择的 Pod 也不会被允许流出流量。 此策略不会更改默认的入站流量隔离行为。</p>
</li>
<li><p>默认允许所有出站流量</p>
  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: NetworkPolicy</span><br><span class="line">metadata:</span><br><span class="line">  name: allow-all-egress</span><br><span class="line">spec:</span><br><span class="line">  podSelector: &#123;&#125;</span><br><span class="line">  egress:</span><br><span class="line">  - &#123;&#125;</span><br><span class="line">  policyTypes:</span><br><span class="line">  - Egress</span><br></pre></td></tr></table></figure>
<p>  创建允许所有流量流出某个名字空间中的所有 Pod的名为<strong>allow-all-egress</strong>的策略。</p>
</li>
<li><p>默认拒绝所有流量（入站和出站）</p>
  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: NetworkPolicy</span><br><span class="line">metadata:</span><br><span class="line">  name: default-deny-all</span><br><span class="line">spec:</span><br><span class="line">  podSelector: &#123;&#125;</span><br><span class="line">  policyTypes:</span><br><span class="line">  - Ingress</span><br><span class="line">  - Egress</span><br></pre></td></tr></table></figure>
<p>  创建选择所有Pod但不允许来自这些Pod的任何入站和出站流量的名为<strong>default-deny-all</strong>的策略。</p>
</li>
</ul>
<h2 id="涉及基础知识点"><a href="#涉及基础知识点" class="headerlink" title="涉及基础知识点"></a>涉及基础知识点</h2><ol>
<li><p><strong>源地址伪装和端口转发</strong></p>
<p>源地址伪装：NAT设备将经过源主机发出的包转发到指定的接收方，同时将通过的数据包的源地址更改为NAT设备的接口地址。当返回的数据包到达时，会将目的地址修改为源主机的地址并将该数据包转发给源主机。地址伪装可以实现局域网多个地址共享一个公网地址与外界通信。</p>
<p>端口转发：也可以称之为目的地址转换或端口映射。通过端口转发，将指定IP地址及端口的流量转发到相同计算机上的不同端口，或不同计算机上的端口上。一般而言，公司/机构内网的服务器会采用私网地址构建网络，然后通过端口转发将外部用户的请求转发到内网的某个特定位置上，以便让外部能够访问到内网的服务器。</p>
</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top;">Lee, Calcote. &quot;<a href="https://thenewstack.io/container-networking-landscape-cni-coreos-cnm-docker/" target="_blank" rel="noopener">THE CONTAINER NETWORKING LANDSCAPE: CNI FROM COREOS AND CNM FROM DOCKER.</a>&quot; <em>The New Stack</em>. N.p., 16 Sept. 2016. Web. 13 Apr. 2021.</span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top;">cni-dev. &quot;<a href="https://github.com/containernetworking/plugins#plugins" target="_blank" rel="noopener">Github - Containernetworking/Plugins: Some Reference and Example Networking Plugins, Maintained by the CNI Team.</a>&quot; <em>Github</em>. N.p., n.d. Web. 11 Apr. 2021.</span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top;">Mahalingam, Mallik, et al. &quot;Virtual eXtensible Local Area Network (VXLAN): A Framework for Overlaying Virtualized Layer 2 Networks over Layer 3 Networks.&quot; ITEF <a href="https://www.rfc-editor.org/rfc/pdfrfc/rfc7348.txt.pdf" target="_blank" rel="noopener">RFC 7348</a>, August 2014.</span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top;">Nathani, Ronak. &quot;<a href="https://ronaknathani.com/blog/2020/08/how-a-kubernetes-pod-gets-an-ip-address/#" target="_blank" rel="noopener">How a Kubernetes Pod Gets an IP Address.</a>&quot; <em>Ronak Nathani</em>. N.p., 21 Aug. 2020. Web. 14 Apr. 2021.</span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top;">龚正, et al. <em>Kubernetes权威指南：从Docker到Kubernetes实践全接触</em>. 4th ed. 北京: 电子工业出版社, 2019. Print.</span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top;">高庆. '<a href="https://www.kubernetes.org.cn/4960.html" target="_blank" rel="noopener">Calico on Kubernetes 从入门到精通.</a>&quot; <em>Kubernetes中文社区</em>. N.p., 22 Dec. 2018. Web. 10 Apr. 2021.</span></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline-block; vertical-align: top;">CE资料. “<a href="https://forum.huawei.com/enterprise/zh/thread-334207.html" target="_blank" rel="noopener">【华为悦读汇】技术发烧友：认识VXLAN.</a>” <em>华为企业互动社区</em>. N.p., 23 Nov. 2015. Web. 15 Apr. 2021.</span></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">8.</span><span style="display: inline-block; vertical-align: top;">HUAWEI contributors. “<a href="https://support.huawei.com/enterprise/en/doc/EDOC1100023542?section=j015" target="_blank" rel="noopener">Overlay Networking - Huawei DCN Design Guide.</a>” <em>HUAWEI Enterprise</em>. N.p., 14 June 2018. Web. 15 Apr. 2021.</span></li><li id="fn:9"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">9.</span><span style="display: inline-block; vertical-align: top;">Luksa, Marko. <em>Kubernetes in Action中文版</em>. Trans. 七牛容器云团队. 1st ed. 北京: 电子工业出版社, 2019. Print.</span></li><li id="fn:10"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">10.</span><span style="display: inline-block; vertical-align: top;">杜军. <em>Kubernetes网络权威指南：基础、原理与实践</em>. 1st ed. 北京: 电子工业出版社, 2019. Print.</span></li><li id="fn:11"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">11.</span><span style="display: inline-block; vertical-align: top;">闫健勇, et al. <em>Kubernetes权威指南：企业级容器云实战</em>. 1st ed. 北京: 电子工业出版社, 2018. Print.</span></li><li id="fn:12"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">12.</span><span style="display: inline-block; vertical-align: top;">马永亮. <em>Kubernetes进阶实战</em>. 2nd ed. 北京: 机械工业出版社, 2019. Print.</span></li><li id="fn:13"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">13.</span><span style="display: inline-block; vertical-align: top;">溪恒. &quot;<a href="https://www.infoq.cn/article/6mdfWWGHzAdihiq9lDST?utm_source=related_read_bottom&amp;utm_medium=article" target="_blank" rel="noopener">从零开始入门 K8s：理解 CNI 和 CNI 插件.</a>&quot; <em>InfoQ</em>. N.p., 26 Mar. 2020. Web. 15 Apr. 2021.</span></li><li id="fn:14"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">14.</span><span style="display: inline-block; vertical-align: top;">Kubernetes contributors. &quot;<a href="https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/" target="_blank" rel="noopener">Network Plugins.</a>&quot; <em>Kubernetes</em>. N.p., 5 May 2018. Web. 15 Apr. 2021.</span></li><li id="fn:15"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">15.</span><span style="display: inline-block; vertical-align: top;">Project Calico contributors. &quot;<a href="https://docs.projectcalico.org/reference/architecture/overview" target="_blank" rel="noopener">Component Architecture.</a>&quot; <em>Project Calico</em>. N.p., n.d. Web. 15 Apr. 2021.</span></li><li id="fn:16"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">16.</span><span style="display: inline-block; vertical-align: top;">Balkan, Ahmet Alp . &quot;<a href="https://github.com/ahmetb/kubernetes-network-policy-recipes#kubernetes-network-policy-recipes" target="_blank" rel="noopener">Kubernetes Network Policy Recipes.</a>&quot; <em>GitHub</em>. N.p., 30 July 2017. Web. 10 Apr. 2021.</span></li><li id="fn:17"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">17.</span><span style="display: inline-block; vertical-align: top;">Kubernetes contributors. &quot;<a href="https://kubernetes.io/blog/2016/09/high-performance-network-policies-kubernetes/" target="_blank" rel="noopener">High Performance Network Policies in Kubernetes Clusters.</a>&quot; <em>Kubernetes</em>. N.p., 26 Sept. 2016. Web. 10 Apr. 2021.</span></li><li id="fn:18"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">18.</span><span style="display: inline-block; vertical-align: top;">Kubernetes contributors. &quot;<a href="https://kubernetes.io/docs/concepts/services-networking/network-policies/" target="_blank" rel="noopener">Network Policies.</a>&quot; <em>Kubernetes</em>. N.p., 15 July 2018. Web. 13 Apr. 2021.</span></li><li id="fn:19"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">19.</span><span style="display: inline-block; vertical-align: top;">Kubernetes contributors. &quot;<a href="https://kubernetes.io/blog/2016/01/why-kubernetes-doesnt-use-libnetwork/" target="_blank" rel="noopener">Why Kubernetes Doesn’t Use Libnetwork.</a>&quot; <em>Kubernetes Blog</em>. N.p., 14 Jan. 2016. Web. 14 Apr. 2021.</span></li><li id="fn:20"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">20.</span><span style="display: inline-block; vertical-align: top;">马旻. &quot;<a href="https://www.cisco.com/web/CN/partners/industry/pdf/culture_finance_01.pdf" target="_blank" rel="noopener">虚拟叠加网络--数据中心私有云建设的基石.</a>&quot; N.p., Apr. 2014. Web. 14 Apr. 2021.</span></li><li id="fn:21"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">21.</span><span style="display: inline-block; vertical-align: top;">马旻. &quot;<a href="https://www.cisco.com/web/CN/partners/industry/pdf/manufacture_solutions_06.pdf" target="_blank" rel="noopener">VxLAN技术 探讨和方案选择.</a>&quot; N.p., Mar. 2014. Web. 14 Apr. 2021.</span></li><li id="fn:22"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">22.</span><span style="display: inline-block; vertical-align: top;">Hedlund, Brad. &quot;<a href="https://bradhedlund.com/2012/10/06/mind-blowing-l2-l4-network-virtualization-by-midokura-midonet/" target="_blank" rel="noopener">Mind Blowing L2-L4 Network Virtualization by Midokura MidoNet.</a>&quot; <em>Brad Hedlund</em>. N.p., 6 Oct. 2012. Web. 14 Apr. 2021.</span></li><li id="fn:23"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">23.</span><span style="display: inline-block; vertical-align: top;">Hedlund, Brad. &quot;<a href="https://bradhedlund.com/2011/10/12/network-virtualization-is-like-a-big-virtual-chassis/" target="_blank" rel="noopener">Network Virtualization is like a big virtual chassis.</a>&quot; <em>Brad Hedlund</em>. N.p., 12 Oct. 2011. Web. 14 Apr. 2021.</span></li><li id="fn:24"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">24.</span><span style="display: inline-block; vertical-align: top;">Wikipedia contributors. &quot;<a href="https://en.wikipedia.org/wiki/Virtual_Extensible_LAN" target="_blank" rel="noopener">Virtual Extensible LAN.</a>&quot; Wikipedia, The Free Encyclopedia. Wikipedia, The Free Encyclopedia, 17 May. 2021. Web. 20 Jun. 2021.</span></li><li id="fn:25"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">25.</span><span style="display: inline-block; vertical-align: top;">Spreitzer, Mike, et al. &quot;<a href="https://github.com/containernetworking/cni/blob/master/SPEC.md#container-network-interface-cni-specification" target="_blank" rel="noopener">Container Network Interface (CNI) Specification.</a>&quot; <em>GitHub</em>. N.p., 30 May 2015. Web. 14 Apr. 2021.</span></li><li id="fn:26"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">26.</span><span style="display: inline-block; vertical-align: top;">乾坤李. &quot;<a href="https://qiankunli.github.io/2018/10/11/cni.html" target="_blank" rel="noopener">CNI——容器网络是如何打通的.</a>&quot; 李乾坤的博客. N.p., 11 Oct. 2018. Web. 14 Apr. 2021.</span></li><li id="fn:27"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">27.</span><span style="display: inline-block; vertical-align: top;">Helios. &quot;<a href="https://github.com/helios741/myblog/blob/new/learn_go/src/2020/0303_k8s_cni/README.md" target="_blank" rel="noopener">深入浅出kubernetes中的CNI.</a>&quot; <em>GitHub</em>. N.p., 3 Mar. 2020. Web. 14 Apr. 2021.</span></li></ol></div><p><br><br><br><br></p></div></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
  	</section>
  	
	  	<div>
		  	
				<div>
	<div style="text-align:center;color: #ccc;font-size:20px;">------------- End of this article, thanks! -------------
	<br>&emsp;</div>
</div>
		  	
		</div>
	    
		 	
		      	<section class="post-declare">
<p>
<div style="background-color:#E8E8E8;color:#000;padding:10px 15px 15px 20px;"><br><b>&emsp;&emsp;版权声明</b>：本文由<b><a href="/about" target="_blank" title="Nathan R. Lee">Nathan R. Lee</a></b>创作和发表，采用<b>署名(BY)</b>-<b>非商业性使用(NC)</b>-<b>相同方式共享(SA)</b>国际许可协议进行许可，转载请注明作者及出处。<br>&emsp;&emsp;本文作者为&nbsp;<b><a href="/about" target="_blank" title="Nathan R. Lee">Nathan R. Lee</a></b><br>&emsp;&emsp;本文标题为&nbsp;<b><a href="/2021/K8s-Network-Architecture-section-one.html" target="_blank" title="K8s network之一：K8s网络模型与网络策略">K8s network之一：K8s网络模型与网络策略</a></b><br>&emsp;&emsp;本文链接为&nbsp;<b><a href="/2021/K8s-Network-Architecture-section-one.html" target="_blank" title="K8s network之一：K8s网络模型与网络策略">https://marcuseddie.github.io/2021/K8s-Network-Architecture-section-one.html</a></b></div>
</p>
<section class="post-declare">
		  	
	  	
	  	
	  	<section class="post-comments">

    <!-- 将评论系统（例如Disqus、多说、友言、畅言等）提供的代码片段粘贴在这里 -->
    
</section>
	
	
<div class="prev_next clearfix">
	<div style="width:50%;float:left;">
		
			
				<a href="/2021/K8s-Network-Architecture-section-two.html" class="alignleft prev" title="K8s network之二：Kubernetes的域名解析、服务发现和外部访问"> 上一篇： K8s network之二：Kubernetes的域名解析、服务发现和...</a>
			
		
	</div>
	<div style="width:50%;float:right;">
		
			
				<a href="/2021/IP-Subnet-Mask.html" class="alignright next" title="IP子网划分方法简述"> 下一篇： IP子网划分方法简述</a>
			
		
	</div>
</div>

	<script>
	    function createImgEventFullScreen() {
	        var imgs = $(".post").find("img");
	        for (var i = 0; i < imgs.length; i++) {
	            imgs[i].onclick = function (e) {
	                var ent = e.srcElement ? e.srcElement : e.target; // 兼容ie、Firefox、Chrome等
	                var src = ent.currentSrc;
	                var _this = $(this);
	                createCover(src,_this);
	            }
	        }
	        function createCover(src,_this) {
	            var cover = $("<div id='outerDiv' style='position:fixed;top:0;left:0;background:rgba(0,0,0,0.9);z-index:900;width:100%;height:100%;display:none;'><div id='innerDiv' style='position:absolute;'><img  id='bigImg' style='border:5px solid #fff;' src=''/></div></div>");
	            $("#outerDiv").remove();
	            $("body").append(cover);
	            imgShow("#outerDiv", "#innerDiv", "#bigImg", _this,src);
	        }
	    }

	    function imgShow(outerDiv, innerDiv, bigImg, _this,src) {
	        $(bigImg).attr("src", src); //设置#bigImg元素的src属性
	        /*获取当前点击图片的真实大小，并显示弹出层及大图*/
	        $("<img/>").attr("src", src).load(function () {
	            var windowW = $(window).width(); //获取当前窗口宽度
	            var windowH = $(window).height(); //获取当前窗口高度
	            var realWidth = this.width; //获取图片真实宽度
	            var realHeight = this.height; //获取图片真实高度
	            var imgWidth, imgHeight;
	            var scale = 0.8; //缩放尺寸，当图片真实宽度和高度大于窗口宽度和高度时进行缩放

	            if (realHeight > windowH * scale) { //判断图片高度
	                imgHeight = windowH * scale; //如大于窗口高度，图片高度进行缩放
	                imgWidth = imgHeight / realHeight * realWidth; //等比例缩放宽度
	                if (imgWidth > windowW * scale) { //如宽度仍大于窗口宽度
	                    imgWidth = windowW * scale; //再对宽度进行缩放
	                }
	            } else if (realWidth > windowW * scale) { //如图片高度合适，判断图片宽度
	                imgWidth = windowW * scale; //如大于窗口宽度，图片宽度进行缩放
	                imgHeight = imgWidth / realWidth * realHeight; //等比例缩放高度
	            } else { //如果图片真实高度和宽度都符合要求，高宽不变
	                imgWidth = realWidth;
	                imgHeight = realHeight;
	            }
	            $(bigImg).css("width", imgWidth); //以最终的宽度对图片缩放

	            var w = (windowW - imgWidth) / 2; //计算图片与窗口左边距
	            var h = (windowH - imgHeight) / 2; //计算图片与窗口上边距
	            $(innerDiv).css({ "top": h, "left": w }); //设置#innerDiv的top和left属性
	            $(outerDiv).fadeIn("fast"); //淡入显示#outerDiv
	        });

	        $(outerDiv).click(function () { //再次点击淡出消失弹出层
	            $(this).fadeOut("fast");
	        });
	    }
	    setTimeout(function () {
	        createImgEventFullScreen();
	    }, 1000)
	</script>
</section></section></article>


            <footer class="footer">

    <span class="footer__copyright">&copy; 2018-2020. | 由<a href="https://hexo.io/">Hexo</a>强力驱动 </span>
    
</footer>
        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>

    
    <script src="/js/d3@6"></script>
    <!--
      <script src="/js/markmap-view@0.2.7"></script>
    -->
    

      <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
		  
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
		  
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
		isfetched = false;
        $('.popup').hide();
		$(".popoverlay").remove();
		$('body').css('overflow', '');
      };
    });

    $('.popup-btn-close').click(function(e){
	  isfetched = false;
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


    

    <script type="text/javascript" src="/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/js/jquery.min.js"></script>
    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>
